[{"title":"前端思考之2018年初计划安排","date":"2018-02-23T16:00:00.000Z","path":"2018/02/24/thinking-in-the-front-end-knowledge-20180224-planning/","text":"新年新气象，给自己2018年初做个安排 1 工作安排1.1 完善地类分析功能（已完成） 将分析结果中table转化为tab页切换的时候，tab页的header内容修改为每个table的Caption 将分析结果中每个table的Caption剔除。 1.2 完善截屏功能 研究在不使用map.setExtent()的情况下，保证PrintTemplate的extent是利用drawbar圈选出来的范围。 保证所有浏览器中截图图片的正常下载，看是再找相关帮助库，还是可以直接自己写方法达到至少支持ie8的图片下载功能。 1.3 解决测量功能错误 面积量算和距离量算使用报错，目前不确定原因，要进一步核查 1.4 坐标书签功能 第一步，确定书签保存是入库还是保存到浏览器本地，保存到浏览器本地。 一条数据记录内容 唯一id（程序生成） 书签name x坐标值 y坐标值 一条页面记录内容 x坐标值 y坐标值 删除按钮 数据量比较少，可以通过localstroge完成，但是如果要入库的话，需要进一步研究空间库的表结构，确定是否需要新建表来满足功能需求，这个要和C/S组同事沟通，不知道是否能够随意新增表，会不会导致其他正在使用webgis服务的抗拒。 第二步，确定保存的书签列表展示是通过引入插件，做分页展示，还是手动做table内容拼接。 第三步，确定书签列表展示内容列和展示标题，还有其他功能展示细节内容。 第四步，根据设计逻辑，做出单独案例demo，并做相关功能测试。 第五步，迁移demo到项目中来，确定绑定坐标书签功能弹窗是否正常显示，确定相关功能是否正确绑定。 1.5 范围书签功能 第一步，确定书签保存是入库还是保存到浏览器本地，保存到浏览器本地。 一条数据记录内容 唯一id（程序生成） 书签name 坐标点集合，但是随便一个范围的坐标点个数加上每个点的长度精度，这个对字段类型长度必须要很大。 一条页面记录内容 书签name 范围面积 删除按钮 数据量比较多，不确定是否可以通过localstroge完成，但是如果要入库的话，需要进一步研究空间库的表结构，确定是否需要新建表来满足功能需求，这个要和C/S组同事沟通，不知道是否能够随意新增表，会不会导致其他正在使用webgis服务的抗拒。 第二步，确定保存的书签列表展示是通过引入插件，做分页展示，还是手动做table内容拼接。 第三步，确定书签列表展示内容列和展示标题，还有其他功能展示细节内容。 第四步，根据设计逻辑，做出单独案例demo，并做相关功能测试。 第五步，迁移demo到项目中来，确定绑定坐标书签功能弹窗是否正常显示，确定相关功能是否正确绑定。 1.6 双屏和四屏功能 第一步，确定在什么条件下，可以使用双屏和四屏功能。 第二步，确认默认的矢量主图层，默认的双屏图层和四屏图层。 第三步，确定每个分屏对应的缩略图片，和唯一名称。 第四步，根据设计逻辑，做出单独案例demo，并做相关功能测试。 第五步，迁移demo到项目中来，确定绑定坐标书签功能弹窗是否正常显示，确定相关功能是否正确绑定。 1.7 后续功能扩展 时态演变，单击时态演变按钮 ，通过动画的形式，实现历史数据的展示与对比。 三维，单击三维按钮 ，实现三维数据与2D数据对比。 业务查询，需要支持：建设用地报批、土地开发整理、农村土地整治、土地储备、土地供应及监管、土地登记、违法用地等的图形查询和属性查询。 查询模式应支持：1、空间关系查询，通过点查询、拉框查询得到各业务的图形数据；2、时间关系查询：根据某个时间段或者某个时点作为条件进行查询；3、智能查询：通过构造国土资源智能搜索引擎，根据任意输入项目编号、权利人、地块要素等查询条件进行搜索；4、图属对照查询，实现业务信息图文一体化。（查询条件、查询结果描述） 图表展示功能，对于项目中一些分析结果，以图表的形式叠加在地图上。 热力分布显示功能，对于项目中一些分析结果，以热力图的形式叠加在地图上。 后台管理平台，现有的所有配置，主要是在config.xml和web.config中进行配置，对于测试人员来说比较麻烦，最好做一个页面进行配置管理。 2 学习安排2.1 填坑 string引用类型文章写完 inoic学习记录写完 python3学习记录写完 2.2 读书计划 js高程3 js语言精粹 js忍者秘术 js设计模式 js数据结构学习 etc. 2.3 框架学习计划 vue深入学习 react深入学习 react native深入学习 ng5深入学习 preact学习和了解 moon学习和了解 微信小程序的深入学习 node-express的深入学习和实战 antd-pro的深入学习和实战 iceworks的深入学习和实战 docker学习和了解 etc. 2.4 项目计划 一个完整新闻类的webapp项目，主要使用mongodb，ionic，react和antd-design，路由跳转控制，默认需要登录，才能够进入功能页，参考coding冒泡广场设计。 一个完整音乐类的webapp项目，主要使用mongodb，react native和antd-design，路由跳转控制，默认需要登录，才能够进入功能页，参考growio音乐网站设计。 一个完整诗歌类的桌面项目，主要使用mongodb，Electron和mdui，参考古诗词典app页面设计。 etc. 2.5 交流会 多参加感兴趣的交流会，并且记得在电脑上实战 对知识点研究深一些，争取也可以做技术交流讲解人。 3 生活安排3.1 饮食 保持每天至少吃一个鸡蛋。 保证每天都要吃早餐。 保证午餐不要吃的太少。 保证自己弄的晚餐，有荤有素。 保证自己弄的晚餐，自己觉得还不错。 可以尝试多认识一些调料，不要只用盐做菜。 尽量少吃刺激性食品。 周末要记得出去吃好吃的，犒劳自己。 3.2 运动 保持每天至少5000步。 周末出去尽量步行，最好将步数刷到一万五步以上。 尝试恢复早起，做些运动。 3.3 睡眠 在非必要的情况下，不要晚睡。 如果出于某些原因，必须要晚睡，在保证进度的情况下面，不要在打瞌睡的情况下继续坚持。 在前一天没有睡的特别晚的情况下，早上不要起的太晚。 3.4 交友 可以多认识一些朋友。 对于值得学习的语录，要做及时的记录。","tags":[{"name":"计划安排","slug":"计划安排","permalink":"https://mowatermelon.github.io/tags/计划安排/"},{"name":"2018","slug":"2018","permalink":"https://mowatermelon.github.io/tags/2018/"},{"name":"前端思考","slug":"前端思考","permalink":"https://mowatermelon.github.io/tags/前端思考/"}]},{"title":"前端思考之2018新年规划公司版","date":"2018-01-27T16:00:00.000Z","path":"2018/01/28/thinking-in-the-front-end-knowledge-working/","text":"1 doing1.1 what前端相关项目需求 1.2 where 维护新产品webgis板块 参与新产品前端页面公用组件开发 1.3 how 查看地图相关的vue组件开发案例 研究arcgis和vue的兼容可能性 查看awesome-vue项目中是否有值得借鉴的项目 通过研究，参与整理新产品组件开发规范制定（详见2.4） 2 suggest2.1 company无 2.2 department 增强技术交流次数 每次交流可以是自由交流 也可以是有详细主题的交流 重点在于各自掌握的技术点互换，或者工作疑惑迁移 不一定要求所有人都去 不一定是要在上班日，可以周末找个茶馆，各种交流 加强代码规范的管理 制定可以严格执行的代码规范 增加代码复查，可以是组员互查，可以是项目负责人的对组员代码的核查 代码复查的目的是为了写出更好的产品代码，不要简单的绑定奖惩机制 代码的易读性、可扩展性和可维护性，都要注意，而且也值得鼓励。 2.3 product 规范产品开发流程，方便每个岗位更专注的做事情 新产品为了很好的通用性，可以参考阿里出的iceworks 可以抽取表单设计器，专门用来做代码转化，方便web项目中表单的快速开发 可以抽取政务框架，作为cms项目进行销售，可以参考layui社区 可以考虑做webapp使用mui或者react native 可以考虑.NET提供的app研发或者桌面端应用研发 2.4 Specification 代码规范 组件命名规范 路由命名规范 js变量和函数命名规范 js设计规范（可以借鉴函数式编程） css样式和id命名规范 css设计规范（可以借鉴OOCSS,BEM等等） 文件夹和文件命名规范 文档规范 接口文档的统一格式规范 接口文档的必备板块规定","tags":[{"name":"2018","slug":"2018","permalink":"https://mowatermelon.github.io/tags/2018/"},{"name":"前端思考","slug":"前端思考","permalink":"https://mowatermelon.github.io/tags/前端思考/"},{"name":"新年规划","slug":"新年规划","permalink":"https://mowatermelon.github.io/tags/新年规划/"}]},{"title":"框架学习之Docker拉取centos镜像","date":"2017-11-06T16:00:00.000Z","path":"2017/11/07/framework-learning-docker/","text":"1 安装与配置 Docker1.1 安装 Docker Docker 软件包已经包括在默认的 CentOS-Extras 软件源里。因此想要安装 docker，只需要运行下面的 yum 命令： 1yum install docker-io -y 直接yum安装，安装成功后查看版本 1docker -v 启动docker 1service docker start 设置开机启动 1chkconfig docker on 1.2 配置 Docker 更换腾讯云镜像源 1echo \"OPTIONS='--registry-mirror=https://mirror.ccs.tencentyun.com'\" &gt;&gt; /etc/sysconfig/docker 镜像源挂载 1systemctl daemon-reload 重启docker镜像 1service docker restart 2 Docker 的简单操作2.1 下载镜像 运行容器 这时我们可以在刚才下载的 CentOS 镜像生成的容器内操作了。生成一个 centos 镜像为模板的容器并使用 bash shell 1docker run -it centos /bin/bash 这个时候可以看到命令行的前端已经变成了 [root@(一串 hash Id)] 的形式, 这说明我们已经成功进入了 CentOS 容器。 在容器内执行任意命令, 不会影响到宿主机, 如下 1mkdir -p /data/simple_docker 可以看到 /data 目录下已经创建成功了 simple_docker 文件夹 1ls /data 退出容器 1exit 查看宿主机的 /data 目录, 并没有 simple_docker 文件夹, 说明容器内的操作不会影响到宿主机 1ls /data 2.2 保存容器 查看所有的容器信息， 能获取容器的id 1docker ps -a 请自行将 -m 后面的信息改成自己的容器的信息，保存镜像： 1docker commit -m=\"备注\" 你的CONTAINER_ID 你的IMAGE","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"centos","slug":"centos","permalink":"https://mowatermelon.github.io/tags/centos/"},{"name":"docker","slug":"docker","permalink":"https://mowatermelon.github.io/tags/docker/"}]},{"title":"框架学习之Arcgis for Js 4.6本地部署","date":"2017-11-05T16:00:00.000Z","path":"2017/11/06/framework-learning-Arcgis-for-js-local-build/","text":"1 部署包下载 下载对应版本 2 部署包举例 下载之后的目录效果，以4.6举例 3 安放部署包到项目中 将文件放到项目路径下面去，记住这个路径/static/plugins/arcgis46，我是把文件放在相对项目根文件夹的这个路径中 4 根据安放路径修改源码4.1 修改init.js修改上图中的init.js，将该文件中的baseUrl:&quot;https://[HOSTNAME_AND_PATH_TO_JSAPI]dojo，修改为baseUrl: (location.protocol === &#39;file:&#39; ? &#39;http:&#39; : location.protocol) + &#39;//&#39; + (function () { var result = &quot;&quot;; result = window.location.href.substr(window.location.href.indexOf(&quot;//&quot;) + 2); result = result.substr(0, result.lastIndexOf(&quot;/&quot;)); return result; })() + &quot;/static/plugins/arcgis46/dojo&quot; 即指向从项目根文件夹开始写实际的dojo.js所在路径，如果后期部署包，路径进行了修改，主要是对&quot;/static/plugins/arcgis46/dojo&quot;进行修改。 4.2 修改dojo.js同时修改/static/plugins/arcgis46/dojo/dojo.js，将该文件中的baseUrl:&quot;https://[HOSTNAME_AND_PATH_TO_JSAPI]dojo，修改为baseUrl: (location.protocol === &#39;file:&#39; ? &#39;http:&#39; : location.protocol) + &#39;//&#39; + (function () { var result = &quot;&quot;; result = window.location.href.substr(window.location.href.indexOf(&quot;//&quot;) + 2); result = result.substr(0, result.lastIndexOf(&quot;/&quot;)); return result; })() + &quot;/static/plugins/arcgis46/dojo&quot; 即指向从项目根文件夹开始写实际的dojo.js所在路径，如果后期部署包，路径进行了修改，主要是对&quot;/static/plugins/arcgis46/dojo&quot;进行修改。 5 测试引入情况5.1 安装esri依赖12cnpm i esri-loader --scnpm i dojo-loader --s 5.2 新建MapView组件 请注意 配置esriLoader的引入路径是../../static/plugins/arcgis46/init.js，即项目中实际的init.js的路径。 注意引入esri基础所需样式文件，@import &#39;./../../static/plugins/arcgis46/esri/css/main.css&#39;。 view对象实例化对应的标签一定要写一个固定的高度，要不然页面上不会显示。 请注意实例化view的过程中，通过esriLoader引入的依赖文件，一定要注意顺序，应该是&quot;esri/map&quot;, &quot;esri/views/MapView&quot;,&quot;dojo/domReady!&quot;，顺序有问题，页面会报错，说MapView不是一个constructor。 注意通过esriLoader.isLoaded()来监听esriLoader是否已经初始化过了 注意通过map.initialized来判断map对象是否已经初始化完成。 对于_this.view.hitTest(e)来解析当前鼠标行为，在3.X版本之中，监听到鼠标的evt对象之后，就可以直接通过evt.MapObject来获取当前鼠标的经纬度，但是在4.X版本之中，是需要先将鼠标的evt对象进行解析之后，才能获取相关的地理信息数据。 组件源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div class=\"map_box\"&gt; &lt;div id=\"viewDiv\" class=\"map_div\" @mousemove=\"showCoordinates($event)\" &gt;&lt;/div&gt; &lt;p class=\"text-right map-info\" :class=\"&#123;'hide': isHide&#125;\"&gt;当前坐标：x:&#123;&#123;evt.x&#125;&#125;,y:&#123;&#123;evt.y&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import esriLoader from 'esri-loader' export default &#123; name: 'MapView', data () &#123; return &#123; map: &#123;'loaded': ''&#125;, isHide: true, evt:&#123;x:'',y:''&#125;, camera:&#123;&#125;, view:&#123;&#125; &#125; &#125;, watch: &#123; 'map.loaded': function () &#123; if (this.map.initialized == true) &#123; this.isHide = false; &#125; &#125; &#125;, mounted: function () &#123; // 监听esriLoader是否存在，创建map if (!esriLoader.isLoaded()) &#123; // no, lazy load it the ArcGIS API before using its classes esriLoader.bootstrap((err) =&gt; &#123; if (err) &#123; console.error(err); &#125; else &#123; // once it's loaded, create the map this.createMap(); &#125; &#125;, &#123; // use a specific version instead of latest 4.x url: '../../static/plugins/arcgis46/init.js' &#125;); &#125; else &#123; // ArcGIS API is already loaded, just create the map this.createMap(); &#125; &#125;, methods: &#123; // 创建地图 createMap: function () &#123; let _this =this; esriLoader.dojoRequire([\"esri/map\", \"esri/views/MapView\",\"dojo/domReady!\"], (Map,MapView) =&gt; &#123; _this.map = new Map(&#123; basemap: \"osm\", ground: \"world-elevation\"// Use the world elevation service &#125;); _this.view = new MapView(&#123; container: \"viewDiv\", // Reference to the scene div created in step 5 map: _this.map, // Reference to the map object created before the scene scale: 50, // Sets the initial scale to 1:50,000,000 center: [114.40845006666666,30.456864444444443] // Sets the center point of view with lon/lat &#125;); &#125;); &#125;, // 缩放到中心图层 centerZoom: function () &#123; this.map.centerAndZoom([114.40845006666666,30.456864444444443], 16); &#125;, // 显示当前坐标 showCoordinates: function(e) &#123; let _this = this; _this.view.hitTest(e) .then(function(res)&#123; let point = res.screenPoint; if(!_this.isHide)&#123; _this.evt.x = point.x; _this.evt.y = point.y; &#125; &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=\"scss\" scoped&gt;@import './../../static/plugins/arcgis46/esri/css/main.css';.map_box .map_div &#123; width:100%; height: calc(100vh*0.8); cursor: pointer;&#125;&lt;/style&gt;","tags":[{"name":"webgis","slug":"webgis","permalink":"https://mowatermelon.github.io/tags/webgis/"},{"name":"Arcgis for js 4.6","slug":"Arcgis-for-js-4-6","permalink":"https://mowatermelon.github.io/tags/Arcgis-for-js-4-6/"},{"name":"local-build","slug":"local-build","permalink":"https://mowatermelon.github.io/tags/local-build/"},{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"}]},{"title":"前端思考之DevOps","date":"2017-11-04T16:00:00.000Z","path":"2017/11/05/thinking-in-the-front-end-knowledge-devops/","text":"前情概要，最近参加了一个关于DevOps的交流会，会上交流了很多，整理文档，确认思路 1 what1.1 historyDevOps运动的起源通常被放在2009年前后的欧洲，传统模式的运维之痛而生，伴随着许多运动的相辅相成和相互促进——效率研讨会运动，特别是由John Allspaw和Paul Hammond展示的开创性的一天10次部署，基础设施即代码运动(Mark Burgess 和Luke Kanies)，敏捷基础设施运动(Andrew Shafer)，敏捷系统管理运动(Patrick DeBois)，精益创业运动（Eric Ries），Jez Humble的持续集成和发布运动，以及Amazon的平台即服务运动等这些运动的相辅相成和相互促进而发展起来的。 DevOps早在2009年就有人提出来，但是，为什么近几年才开始受到越来越多的企业重视和实践呢？因为DevOps的发展是独木不成林的，现在有越来越多的技术支撑。微服务架构理念、容器技术使得DevOps的实施变得更加容易，计算能力提升和云环境的发展使得快速开发的产品可以立刻获得更广泛的使用。 1.2 Agile Manifesto敏捷宣言，也叫做敏捷软件开发宣言，正式宣布了对四种核心价值和十二条原则，可以指导迭代的以人为中心的软件开发方法。 敏捷宣言强调的敏捷软件开发的四个核心价值是： 个体和互动高于流程和工具工作的软件高于详尽的文档客户合作高于合同谈判响应变化高于遵循计划 敏捷选择提出的12条原则已经应用于管理大量的业务以及与IT相关项目中，包括商业智能（BI）。12原则包括： 通过早期和连续型的高价值工作交付满足“客户”。 大工作分成可以迅速完成的较小组成部门。 识别最好的工作是从自我组织的团队中出现的， 为积极员工提供他们需要的环境和支持，并相信他们可以完成工作。 创建可以改善可持续工作的流程。 维持完整工作的不变的步调。 欢迎改变的需求，即使是在项目后期。 在项目期间每天与项目团队和业务所有者开会。 在定期修正期，让团队反映如何能高效，然后进行相应地行为调整。 通过完成的工作量计量工作进度。 不断地追求完善。 利用调整获得竞争优势。 1.3 meaningDevOps一词的来自于Development和Operations的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。 除了触及工具链之外，作为文化和技术的方法论，DevOps还需要公司在组织文化上的变革。回顾软件行业的研发模式，可以发现大致有三个阶段：瀑布式开发、敏捷开发、DevOps。 无尽头的可能性 DevOps涵盖了代码、部署目标的发布和反馈等环节，闭合成一个无限大符号形状的DevOps能力闭环。 DevOps包含流程和管理，运维和自动化，架构和服务，以及文化和组织等等概念。 简单地来说，就是更好的优化开发(DEV)、测试(QA)、运维(OPS)的流程，开发运维一体化，通过高度自动化工具与流程来使得软件构建、测试、发布更加快捷、频繁和可靠。 2 why2.1 why create随着软件发布迭代的频率越来越高，传统的「瀑布型」（开发—测试—发布）模式已经不能满足快速交付的需求。2009 年左右 DevOps 应运而生，简单地来说，就是更好的优化开发(DEV)、测试(QA)、运维(OPS)的流程，开发运维一体化，通过高度自动化工具与流程来使得软件构建、测试、发布更加快捷、频繁和可靠。 DevOps是为了填补开发端和运维端之间的信息鸿沟，改善团队之间的协作关系。不过需要澄清的一点是，从开发到运维，中间还有测试环节。DevOps其实包含了三个部分：开发、测试和运维。 换句话说，DevOps希望做到的是软件产品交付过程中IT工具链的打通，良好的闭环可以大大增加整体的产出使得各个团队减少时间损耗，更加高效地协同工作。 2.2 why good DevOps的一个巨大好处就是可以高效交付，这也正好是它的初衷。Puppet和DevOps Research and Assessment (DORA) 主办了2016年DevOps调查报告，根据全球4600位各IT公司的技术工作者的提交数据统计，得出高效公司平均每年可以完成1460次部署。 与低效组织相比，高效组织的部署频繁200倍，产品投入使用速度快2555倍，服务恢复速度快24倍。在工作内容的时间分配上，低效者要多花22%的时间用在为规划好或者重复工作上，而高效者却可以多花29%的时间用在新的工作上。所以这里的高效不仅仅指公司产出的效率提高，还指员工的工作质量得到提升。 DevOps另外一个好处就是会改善公司组织文化、提高员工的参与感。员工们变得更高效，也更有满足和成就感；调查显示高效员工的雇员净推荐值（eNPS:employee Net Promoter Score）更高，即对公司更加认同。 代码的提交直接触发：消除等待时间，快速反馈 每个变化对应一个交付管道：使问题定位和调试变得简单 全开发流程高效自动化：稳定，快速，交付结果可预测 持续进行自动化回归测试：提升交付质量 设施共享并按需提供：资源利用最大化 快速部署同时提高IT稳定性。这难道不矛盾吗？ 快速的部署其实可以帮助更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应。而且，DevOps小步快跑的形式带来的变化是比较小的，出现问题的偏差每次都不会太大，修复起来也会相对容易一些。 因此，认为速度就意味着危险是一种偏见。此外，滞后软件服务的发布也并不一定会完全地避免问题，在竞争日益激烈的IT行业，这反而可能错失了软件的发布时机。 2.3 why hot条件成熟：技术配套发展 技术的发展使得DevOps有了更多的配合。早期时，大家虽然意识到了这个问题的，但是苦于当时没有完善丰富的技术工具，是一种“理想很丰满，但是现实很骨感”的情况。DevOps的实现可以基于新兴的容器技术；也可以在自动化运维工具Puppet、SaltStack、Ansible之后的延伸；还可以构建在传统的Cloud Foundry、OpenShift等PaaS厂商之上。 来自市场的外部需求：这世界变化太快 IT行业已经越来越与市场的经济发展紧密挂钩，专家们认为IT将会有支持中心变成利润驱动中心。事实上，这个变化已经开始了，这不仅体现在Google、苹果这些大企业中，而且也发生在传统行业中，比如出租车业务中的Uber、酒店连锁行业中的Airbnb、图书经销商Amazon等等。能否让公司的IT配套方案及时跟上市场需求的步伐，在今天显得至关重要。 DevOps 2016年度报告给出了一个运维成本的计算公式： 停机费用成本 = 部署频率 版本迭代失败概率 平均修复时间 * 断电的金钱损失 来自团队的内在动力：工程师也需要 对于工程师而言，他们也是DevOps的受益者。微软资深工程师Scott Hanselman说过“对于开发者而言，最有力的工具就是自动化工具”（The most powerful tool we have as developers is automation）。 工具链的打通使得开发者们在交付软件时可以完成生产环境的构建、测试和运行；正如Amazon的VP兼CTO Werner Vogels那句让人印象深刻的话：“谁开发谁运行”。（You build it, you run it） 3 whoDevOps正在增长，尤其是在大企业中：调查发现，DevOps的接受度有了显著提高。74%的受访者已经接受了DevOps，而去年这一比例为66%。目前，在81%的大企业开始接受DevOps，中小企业的接受度仅为70%。 那么具体而言都有些公司在采用DevOps呢？Adobe、Amazon、Apple、Airbnb、Ebay、Etsy、Facebook、LinkedIn、Netflix、NASA、Starbucks、Target（泛欧实时全额自动清算系统）、Walmart、Sony等等。 目前在国外，互联网巨头如Google、Facebook、Amazon、LinkedIn、Netflix、Airbnb，传统软件公司如Adobe、IBM、Microsoft、SAP等，亦或是网络业务非核心企业如苹果、沃尔玛、索尼影视娱乐、星巴克等都在采用DevOps或提供相关支持产品。 大企业主要是在自下而上接受DevOps，其中业务单位或部门（31%）以及项目和团队（29%）已经实施DevOps。不过，只有21%的大企业在整个公司范围内采用了DevOps。 4 how在工具层面上，DevOps工具的用量大幅激增。Chef和Puppet依然是最常用的DevOps工具，使用率均为32%。Docker是年增长率最快的工具，用量增长一倍以上。Ansible的用量也有显著增加，使用率从10%翻倍至20%。 并且调查还发现不到半数（43%）的公司在使用诸如Chef、Puppet、Ansible或Salt等配置工具；然而使用配置工具的公司更有可能同时使用多个工具。25%的受访者使用两种或更多配置工具，只使用一种工具的比例为18%。其中Chef和Puppet是最常用的组合：使用Chef的组织中有67%同时也使用Puppet，类似的，使用Puppet的组织中也有67%同时使用了Chef。 文中的统计数据来自于国外的DevOps调研报告。其中由Puppet发起的DevOps年度国际调查报告已经连续出版五年，先后收集了2.5万技术人员的答卷；2016年收集的有效答卷为4600份，不过仅有10%来自于亚洲。这样的采样率和采样数量并不可以充分地反映中国的DevOps行业现状。 4.1 tools demand 工具上的准备 工具链的打通，需要工具这块做好准备。现将工具类型及对应的不完全列举整理如下： 代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion 构建工具：Ant、Gradle、maven 自动部署：Capistrano、CodeDeploy 持续集成（CI）：Bamboo、Hudson、Jenkins 配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail 容器：Docker、LXC、第三方厂商如AWS 编排：Kubernetes、Core、Apache Mesos、DC/OS 服务注册与发现：Zookeeper、etcd、Consul 脚本语言：python、ruby、shell 日志管理：ELK、Logentries 系统监控：Datadog、Graphite、Icinga、Nagios 性能监控：AppDynamics、New Relic、Splunk 压力测试：JMeter、Blaze Meter、loader.io 预警：PagerDuty、pingdom、厂商自带如AWS SNS HTTP加速器：Varnish 消息总线：ActiveMQ、SQS 应用服务器：Tomcat、JBoss Web服务器：Apache、Nginx、IIS 数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库 项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker 在工具的选择上，需要结合公司业务需求和技术团队情况而定。（注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers） 4.2 soft demand 文化和人 DevOps成功与否，公司组织是否利于协作是关键。开发人员和运维人员可以良好沟通互相学习，从而拥有高生产力。并且协作也存在于业务人员与开发人员之间。 出席了2016年伦敦企业级DevOps峰会的ITV公司在2012年就开始落地DevOps，其通用平台主管Clark在接受了InfoQ的采访，在谈及成功时表示，业务人员非常清楚他们希望在最小化可行产品中实现什么，工程师们就按需交付，不做多余工作。 这样，工程师们使用通用的平台（即打通的工具链）得到更好的一致性和更高的质量。此外，DevOps对工程师个人的要求也提高了，很多专家也认为招募到优秀的人才也是一个挑战。","tags":[{"name":"前端思考","slug":"前端思考","permalink":"https://mowatermelon.github.io/tags/前端思考/"},{"name":"DevOps","slug":"DevOps","permalink":"https://mowatermelon.github.io/tags/DevOps/"}]},{"title":"框架学习之Hexo_deploy失败","date":"2017-11-04T06:29:17.000Z","path":"2017/11/04/framework-learning-hexo-d-error/","text":"最近公司网络比较艰苦，那天写了一个文章，执行hexo g -d，正常生成了public文件，但是一直发布不成功，记录一下我解决的过程 1. 问题产生操作步骤 文章写完 执行hexo s --watch 预览页面效果，修改部分细节 执行hexo g -d 出现错误提示，提示 12345678910delete mode 100644 placeholderwarning: LF will be replaced by CRLF in js/script.js.The file will have its original line endings in your working directory.bash: /xxx/xxx: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': Invalid argumentFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/do cs/troubleshooting.htmlError: bash: /xxx/xxx: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': Invalid argument 2. 尝试解决过程2.1 尝试一 执行hexo g,public文件夹生成成功 执行hexo d，控制台出现错误提示和上文一样 卒 2.2 尝试二 修改项目根文件夹下的_config.yml文件，修改请求地址属性名，将repository修改为repo。 修改前 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/&#123;&#123;注册呢称&#125;&#125;/&#123;&#123;注册呢称&#125;&#125;.github.io.git branch: master 修改后 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&#123;&#123;注册呢称&#125;&#125;/&#123;&#123;注册呢称&#125;&#125;.github.io.git branch: master 执行hexo g -d，控制台出现错误提示和上文一样 卒 2.3 尝试三 修改项目根文件夹下的_config.yml文件，请求仓库链接方式，将原有的http请求链接修改为SSH请求模式。 修改前 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/&#123;&#123;注册呢称&#125;&#125;/&#123;&#123;注册呢称&#125;&#125;.github.io.git branch: master 修改后 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:&#123;&#123;注册呢称&#125;&#125;/&#123;&#123;注册呢称&#125;&#125;.github.io.git branch: master 执行hexo g -d，出现错误提示。 12345678910111213141516171819202122Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATA Something's wrong.Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Warning; Permanently added the RSA host key for IP address'52.74.223.119' to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. at ChildProcess.&lt;anonymous&gt; (x:\\xx\\xxxx\\&#123;&#123;注册呢称&#125;&#125;.github.io\\node_modules\\hexo-util\\lib\\spawn.js:37:17) at emitTwo (events.js:126:13) st ChildProcess.emit (events.js:214:7) at ChildProcess.cp.emit (x:\\xx\\xxxx\\&#123;&#123;注册呢称&#125;&#125;.github.io\\node_modules\\cross-spawn\\1ib\\enoent.js:40:29) at maybeclose (internal/child_process.js :925 :16) at Process.ChildProcess._handle.onexit (internal/child_process.js:209:5) 卒 2.4 尝试四 保存上文修改修改项目根文件夹下的_config.yml文件中Deployment请求为SSH请求模式 重新生成SSH 在控制台执行ssh-keygen-t rsa -C {你的邮箱地址} 会出现三次询问过程，一般就直接默认了 生成成功 12345678910111213141516171819202122232425$ ssh-keygen-t rsa -C XXXX@XXXX.comGenerating public/private rsa key pairEnter file in which to save the key (/C/Users/Administrator/.ssh/id_rsa) :created directory'/C/Users/Administrator/ ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /C/Users/Administrator/.ssh/id_rsa.Your public key hasbeen saved in /C/Users/Administrator/ssh/id_rsa.pub.The key fingerprint is:SHA256:NF10yf+QE7HGu6S+j2Vz9PpN8dJ+uS/FVJ5qo XXXX@XXXX.comThe key's randomart image is:+-----[RSA 2048]----+| .o... || . +o... || o . .o++ || . . .o.. || s .oBo || o+o+* || ..o@+* || .oBoB= || EBO+. |+-----[SHA25 6]-----+ 访问上文的公钥地址c/Users/Administrator/.ssh/id_rsa 复制id_rsa.pub文件中内容。 访问https://github.com/settings/keys，选择New SSH Key按钮 在SSH keys / Add new中，主要需要填写两个内容，一个是将要新建的SSH的title，相当于这个SSH的alias，用于区分不同SSH；一个是需要填写的SSH Key内容。 SSH Key输入框中会有默认提示，Begins with &#39;ssh-rsa&#39;, &#39;ssh-dss&#39;, &#39;ssh-ed25519&#39;, &#39;ecdsa-sha2-nistp256&#39;, &#39;ecdsa-sha2-nistp384&#39;, or &#39;ecdsa-sha2-nistp521&#39;，即这个SSH Key必须要以ssh-rsa, ssh-dss, ssh-ed25519, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, 或者 ecdsa-sha2-nistp521。 将从id_rsa.pub文件中复制的内容，粘贴到SSH Key输入框。 选择Add SSH key按钮 github新建SSH key完成 在本地编辑器中添加全局用户设置 1234567$ git config --global user.name &#123;你的全局呢称&#125;$ git config --global user.email &#123;你的全局邮箱地址&#125;# 举个栗子$ git config --global user.name \"mowatermelon\"$ git config --global user.email \"neefoxmo@gmail.com\" 在本地编辑器控制台中进行验证SSH是否添加成功 1234$ ssh -T git@github.comHi xxxx! You've successfully authenticated, but GitHub does not provide shell access.# xxxx应该与你在上一步设置的`user.name`一致 在blog所在项目根文件夹，执行hexo g -d，执行一切顺利。 1INFO Deploy done:git 3 总结 感觉在远程仓库这块，网络是个很大因素，决定你是否能够成功访问，和成功发布。 之前用http请求没感觉，现在网络不太好，就很明显了。 http记得是基于TCP面向连接的，要求服务器可以保持持续连接状态 面向连接的请求，保证了数据的安全性，但是对于网络条件要求更高 但是这边SSH链接请求，似乎对网络条件要求低一些。","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"node","slug":"node","permalink":"https://mowatermelon.github.io/tags/node/"},{"name":"hexo","slug":"hexo","permalink":"https://mowatermelon.github.io/tags/hexo/"},{"name":"vscode","slug":"vscode","permalink":"https://mowatermelon.github.io/tags/vscode/"},{"name":"hexo d","slug":"hexo-d","permalink":"https://mowatermelon.github.io/tags/hexo-d/"}]},{"title":"西瓜有话说之Python小白之路","date":"2017-11-02T16:00:00.000Z","path":"2017/11/03/python-learning-base/","text":"很早就被安利过Python这个优雅的语言，由于各种原因（并不是因为拖延症，坚定的眼神.jpg），都没有学习过，主要是基于Python3.6.4做了一下整理，记录一下学习心得。 第一章 简介 1.1 Python的定义Python是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。 Python的这个名字来自于 BBC 的 Monty Python’s Flying Cirecus 节目，和爬行类动物没有任何关系。 龟叔给Python的定位是优雅、明确、简单，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。 Python 允许你将程序分割为不同的模块，以便在其他的 Python 程序中重用。Python 内置提供了大量的标准模块，你可以将其用作程序的基础，或者作为学习 Python 编程的示例。这些模块提供了诸如文件 I/O、系统调用、Socket 支持，甚至类似 Tk 的用户图形界面（GUI）工具包接口。 特性 解释 可读性强 相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。 解释型语言 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python 解释器可以交互的使用，这使得试验语言的特性、编写临时程序或在自底向上的程序开发中测试方法非常容易。 交互式语言 这意味着，你可以在一个Python提示符，直接互动执行写你的程序。 面向对象语言 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。 初学者的语言 Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 优雅的语言 Python 让程序编写的紧凑和可读。用 Python 编写的程序通常比同样的 C、C++ 或 Java 程序更短小。 内置电池和外置扩展 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作内置电池（batteries included）。用Python开发，许多功能不必从零编写，直接使用现成的即可。 除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。 开发效率更高 当你用一种语言开始作真正的软件开发时，你除了编写代码外，还需要很多基本的已经写好的现成的东西，来帮助你加快开发进度。 比如说，要编写一个电子邮件客户端，如果先从最底层开始编写网络协议相关的代码，那估计一年半载也开发不出来。高级编程语言通常都会提供一个比较完善的基础代码库，让你能直接调用。 比如，针对电子邮件协议的SMTP库，针对桌面环境的GUI库，在这些已有的代码库的基础上开发，一个电子邮件客户端几天就能开发出来。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 1.2 Python发展历史Python是由Guido van Rossum(龟叔)在1989年圣诞节期间，为了打发无聊的圣诞节，在荷兰国家数学和计算机科学研究所设计出来的。 Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。 像Perl语言一样, Python源代码同样遵循 GPL(GNU General Public License)协议。 现在Python是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。 现在，全世界差不多有600多种编程语言，但流行的编程语言也就那么20来种。根据TIOBE排行榜，总的来说，其他编程语言各有千秋，但是Python的使用率一直在稳定上涨。 1.3 Python的优点 易于学习 Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。 易于阅读 Python代码定义的更清晰。 易于维护 Python的成功在于它的源代码是相当容易维护的。 一个广泛的标准库 Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。 互动模式 互动模式的支持，您可以从终端输入并获得结果的语言，互动的测试和调试代码片断。 便携式 Python可以运行在多种硬件平台和所有平台上都具有相同的接口。 可扩展 可以添加低层次的模块到Python解释器。这些模块使程序员可以添加或定制自己的工具，更有效。 数据库 Python提供所有主要的商业数据库的接口。 GUI编程 Python支持GUI可以创建和移植到许多系统调用。 可扩展性 相比 shell 脚本，Python 提供了一个更好的结构，且支持大型程序。 1.4 Python的缺点 运行速度慢 和C相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C是运行前直接编译成CPU能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个下载MP3的网络应用程序，C的运行时间需要0.001秒，而Python程序的运行时间需要0.1秒，慢了100倍。 但由于网络更慢，需要等待1秒，你想，用户能感觉到1.001秒和1.1秒的区别吗？这就好比F1赛车和普通的出租车在北京三环路上行驶的道理一样，虽然F1赛车理论时速高达400公里，但由于三环路堵车的时速只有20公里，因此，作为乘客，你感觉的时速永远是20公里。 C是可以用来编写操作系统的贴近硬件的语言，所以，C适合开发那些追求运行速度、充分发挥硬件性能的程序。而Python是用来编写应用程序的高级编程语言。 代码不能加密。 如果要发布你的Python程序，实际上就是发布源代码，这一点跟C不同，C不用发布源代码，只需要把编译后的机器码（也就是你在Windows上常见的xxx.exe文件）发布出去。 要从机器码反推出C代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 这个缺点仅限于你要编写的软件需要卖给别人挣钱的时候。好消息是目前的互联网时代，靠卖软件授权的商业模式越来越少了，靠网站和移动应用卖服务的模式越来越多了，后一种模式不需要把源码给别人。 1.5 适合Python开发的应用 首选是网络应用，包括网站、后台服务等等 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 1.6 安装Python Unix &amp; Linux 打开WEB浏览器访问http://www.python.org/download/ 选择适用于Unix/Linux的源码压缩包。 下载及解压压缩包。 如果你需要自定义一些选项修改Modules/Setup 执行 ./configure 脚本 make make install 执行以上操作后，Python会安装在 /usr/local/bin 目录中，Python库安装在/usr/local/lib/pythonXX，XX为你使用的Python的版本号。 Window 打开WEB浏览器访问http://www.python.org/download/ 在下载列表中选择Window平台安装包，包格式为：python-XYZ.msi 文件 ， XYZ 为你要安装的版本号。 下载后，双击下载包，进入Python安装向导，安装非常简单，除了注意选择配置Python到环境变量中，其他只需要使用默认的设置一直点击下一步直到安装完成即可。 MAC 最近的MAC系统都自带有Python环境，但是自带的Python版本为旧版本，你可以通过链接http://www.python.org/download/mac/ 查看MAC上Python的新版功能介绍。 MAC上完整的Python安装教程你可以查看：http://homepages.cwi.nl/~jack/macpython/http://www.shouce.ren/api/view/a/7505 环境变量概念 程序和可执行文件可以在许多目录，而这些路径很可能不在操作系统提供可执行文件的搜索路径中。 path(路径)存储在环境变量中，这是由操作系统维护的一个命名的字符串。这些变量包含可用的命令行解释器和其他程序的信息。 Unix或Windows中路径变量为PATH（UNIX区分大小写，Windows不区分大小写）。 在Mac OS中，安装程序过程中改变了python的安装路径。如果你需要在其他目录引用Python，你必须在path中添加Python目录。 下面几个重要的环境变量，它应用于Python情况。 变量名 描述 PYTHONPATH PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。 PYTHONSTARTUP Python启动后，先寻找PYTHONSTARTUP环境变量，然后执行此文件中变量指定的执行代码。 PYTHONCASEOK 加入PYTHONCASEOK的环境变量, 就会使python导入模块的时候不区分大小写. PYTHONHOME 另一种模块搜索路径。它通常内嵌于的PYTHONSTARTUP或PYTHONPATH目录中，使得两个模块库更容易切换。 手动设置环境变量 在 Unix/Linux 设置环境变量,注意: /usr/local/bin/python代指Python的实际安装目录。 12345678#在 csh shell: 输入setenv PATH \"$PATH:/usr/local/bin/python\"#在 bash shell (Linux): 输入export PATH=\"$PATH:/usr/local/bin/python\"#在 sh 或者 ksh shell: 输入PATH=\"$PATH:/usr/local/bin/python\" 在 Windows 设置环境变量,在环境变量中添加Python目录 12#在命令提示框中(cmd) : 输入path %path%;C:\\Python 注意: C:\\Python代指Python的实际安装目录。 1.7 Python解释器当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。 由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。 IDLE 当我们从Python官方网站下载并安装好Python 3.6后，我们就直接获得了一个官方版本的解释器：IDLE。 IPython IPython是基于IDLE之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和IDLE是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。 IDLE用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。 PyPy PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。 绝大部分Python代码都可以在PyPy下运行，但是PyPy和IDLE有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和IDLE的不同点。 Jython Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。 IronPython IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 小结 Python的解释器很多，但使用最广泛的还是IDLE。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。 1.8 编码规范建议 使用 4 空格缩进，而非 TAB，在小缩进（可以嵌套更深）和大缩进（更易读）之间，4空格是一个很好的折中。TAB 引发了一些混乱，最好弃用。 折行以确保其不会超过 79 个字符。这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件。 使用空行分隔函数和类，以及函数中的大块代码。 可能的话，注释独占一行。 使用文档字符串。 把空格放到操作符两边，以及逗号后面，但是括号里侧不加空格：a = f(1, 2) + g(3, 4)。 统一函数和类命名。 推荐类名用 驼峰命名， 函数和方法名用 小写_和_下划线。总是用 self作为方法的第一个参数（关于类和方法的知识详见 初识类 ）。 不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python 的默认情况下，UTF-8，甚至普通的 ASCII 总是工作的最好。 同样，也不要使用非 ASCII 字符的标识符，除非是不同语种的会阅读或者维护代码。 第二章 基础2.1 注释2.1.1 单行注释Python中的注释有单行注释和多行注释： Python中单行注释以#开头， 12# 这是一个注释print(\"Hello, watermelon!\") 2.1.2 多行注释 单引号（’’’） 12345678# 三个单引号#!/usr/bin/python3'''这是多行注释，用三个单引号这是多行注释，用三个单引号这是多行注释，用三个单引号'''print(\"Hello, watermelon!\") 双引号（”””） 1234567# 三个双引号\"\"\"这是多行注释，用三个双引号这是多行注释，用三个双引号这是多行注释，用三个双引号\"\"\"print(\"Hello, watermelon!\") 2.2 输出语句2.2.1 基础 print(value, …, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) 参数名 原始定义 个人描述 是否有默认值 value, … the values to a stream 一组需要输出的内容序列，可以为空 无 sep string inserted between values, default a space. 每个value之间的默认间隔内容 有，默认是一个空格 end string appended after the last value, default a newline. 输出完成之后，以什么内容结尾 有，默认是一个换行符 file a file-like object (stream); defaults to the current sys.stdout. 定义流输出的文件，必须要是一个文件流对象 有，默认是标准的系统输出sys.stdout flush whether to forcibly flush the stream. 是否立即把内容输出到流文件，不作缓存。 有，默认是False 12345678910111213141516171819202122232425262728293031323334353637383940# 一个参数都不传print() # '' 不会报错，输出一个空值# 只传入一个value值print(\"欢迎来到西瓜的世界\") # 欢迎来到西瓜的世界#2进制转为10进制print(0b1001) # 9#8进制转为10进制print(0o12) # 10#16进制到10进制print(0xab) # 171print([&#123;name:melon,age:1&#125;,&#123;name:water,age:2&#125;]) # [&#123;name:melon,age:1&#125;,&#123;name:water,age:2&#125;]# 传入多个value值print(\"hello\",\"watermelon\",\"!\") # hello watermelon !# 传入多个不同数据类型的value值print(\"hello\",1,\"watermelon\",[1.2],\"!\") # hello 1 watermelon [1.2] !# 传入的value需要计算print('100 + 200 =', 100 + 200) # 100 + 200 = 300# 设置多个value值之间间隔内容print(\"hello\",\"watermelon\",\"!\",sep='/') # hello/watermelon/!# 设置多个value值的结尾内容print(\"hello\",\"watermelon\",\"!\",end='/') # hello watermelon !/# 设置多个value值的输出对象with open(r'chapter_1\\abc.txt', 'w') as demo: print('hello\",\"watermelon', file = demo) # hello watermelon# 这样就会在项目所在根文件夹下的chapter_1/abc.txt中，看到输出内容# 这个文本内容就是需要打印出来的内容，可以重复写入# 设置多个value值到流文件的时候，立即把内容输出到流文件，不作缓存。print(\"hello\",\"watermelon\",\"!\",flush=True) # hello watermelon !# 目前没有看到什么效果 2.2.2 格式化输出 基本概念 操作符%也可以用于字符串格式化。它以类似sprintf()-style的方式解析左参数，将右参数应用于此，得到格式化操作生成的字符串。 类型简写 完整单词 中文含义 s string 字符串 x or X hexadecimal 十六进制 d decimal 十进制 o octal 八进制 f or F float 浮点型 基础使用案例 基础使用就是在左参数传入一个%加一个数据类型，右参数通过一个%加一个空格加上一个参数值，或者右参数传入一个%加一个空格加上括号加上参数列表，参数列表中每个参数值以英文逗号做间隔。 123456789101112131415print (\"%s\" % \"Hello Watermelon\") # Hello Watermelonprint (\"%s\" % (\"Hello Watermelon\")) # Hello Watermelonprint('浮点的300.50转成10进制的%d' % 300.50)# 浮点的300.50转成10进制的300print('浮点的300.50转成10进制的%d' % (300.50))# 浮点的300.50转成10进制的300print('2进制的0b1001转成8进制的%o' % 0b1001)# 2进制的0b1001转成8进制的11print('2进制的0b1001转成8进制的%o' % (0b1001))# 2进制的0b1001转成8进制的11print('8进制的0o10转成16进制的%x' % 0o10) # 8进制的0o10转成16进制的8print('8进制的0o10转成16进制的%x' % (0o10)) # 8进制的0o10转成16进制的8print('10进制的10转成浮点型的%f' % 10) # 10进制的10转成浮点型的10.000000print('10进制的10转成浮点型的%f' % (10)) # 10进制的10转成浮点型的10.000000print('10进制的%d转成浮点型的%f' % (10,10)) # 10进制的10转成浮点型的10.000000 使用小技巧 左参数的数据类型前面可以加上数字，限制打印的数字或者文本长度。 右参数加上括号，可以传入多个参数。 12345print (\"%.*s\" % (4,\"Hello Watermelon\")) # Hellprint (\"%.3s \" % (\"Hello Watermelon\")) # Helprint('10进制的10转成浮点型的%.3f' % 10) # 10进制的10转成浮点型的10.000print (\"%s,%s %s\" % (\"Hello\",\"Watermelon\",\"!\")) # Hello,Watermelon ! 请注意 请注意左参数和右参数之间不存在逗号，如果写了逗号，会报错。 八进制类型，十进制类型和字符串类型的缩写必须是小写字母，换成大写字母会报错。 做类型转换的时候，浮点类型和十进制类型需要传入的参数必要是数字类型的。 做类型转换的时候，十六进制类型和八进制类型需要传入的参数必要是整型。 左参数的个数和右参数的个数一定要相等。 虽然大量 Python 代码还在使用 % 操作符，但是旧式的格式化方法最终将从语言中去掉，应该尽量使用str.format()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# print(\"%s,%s\", % (\"hello\",\"watermelon\"))# SyntaxError: invalid syntax# print (\"%O \" % (\"Hello Watermelon\"))'''Traceback (most recent call last): File \"&lt;pyshell#15&gt;\", line 1, in &lt;module&gt; print (\"%O \" % (\"Hello Watermelon\"))ValueError: unsupported format character 'O' (0x4f) at index 1'''# print (\"%D \" % (\"Hello Watermelon\"))'''Traceback (most recent call last): File \"&lt;pyshell#13&gt;\", line 1, in &lt;module&gt; print (\"%D \" % (\"Hello Watermelon\"))ValueError: unsupported format character 'D' (0x44) at index 1'''# print (\"%S \" % (\"Hello Watermelon\"))'''Traceback (most recent call last): File \"&lt;pyshell#14&gt;\", line 1, in &lt;module&gt; print (\"%S \" % (\"Hello Watermelon\"))ValueError: unsupported format character 'S' (0x53) at index 1'''# print (\"%d \" % (\"Hello Watermelon\"))'''Traceback (most recent call last): File \"&lt;pyshell#18&gt;\", line 1, in &lt;module&gt; print (\"%d \" % (\"Hello Watermelon\"))TypeError: %d format: a number is required, not str'''# print (\"%F \" % (\"Hello Watermelon\"))'''Traceback (most recent call last): File \"&lt;pyshell#19&gt;\", line 1, in &lt;module&gt; print (\"%F \" % (\"Hello Watermelon\"))TypeError: must be real number, not str'''# print (\"%X \" % (\"Hello Watermelon\"))'''Traceback (most recent call last): File \"&lt;pyshell#11&gt;\", line 1, in &lt;module&gt; print (\"%X \" % (\"Hello Watermelon\"))TypeError: %X format: an integer is required, not str'''# print (\"%o \" % (\"Hello Watermelon\"))'''Traceback (most recent call last): File \"&lt;pyshell#16&gt;\", line 1, in &lt;module&gt; print (\"%o \" % (\"Hello Watermelon\"))TypeError: %o format: an integer is required, not str'''# print (\"%s,%s\" % (\"Hello\",\"Watermelon\",\"!\"))'''Traceback (most recent call last): File \"&lt;pyshell#29&gt;\", line 1, in &lt;module&gt; print (\"%s,%s\" % (\"Hello\",\"Watermelon\",\"!\"))TypeError: not all arguments converted during string formatting'''print('&#123;0&#125; and &#123;1&#125;'.format('spam', 'eggs')) # spam and eggs 2.3 输入语句2.4 Numbers（数字）2.5 String（字符串）2.6 List（列表）2.7 Tuple（元组）2.8 Sets（集合）2.9 Dictionaries（字典）2.9.1 基础2.9.2 切片2.10 变量2.11 isinstance2.12 字符串和编码2.13 正则2.14 range 函数2.15 迭代器第三章 基础语句3.1 pass 语句3.2 if 语句3.3 while 语句3.4 for 语句3.4.1 基础3.4.2 多条件3.4.3 迭代3.4.4 循环技巧3.5 break和continue 语句3.6 try3.7 generator3.8 dir函数3.9 del 函数第四章 自定义函数4.1 函数定义4.2 函数参数4.3 函数调用4.4 递归函数4.5 列表生成式第五章 调试和测试5.1 错误5.1.1 错误类型5.1.2 错误处理5.2 异常5.2.1 异常处理5.2.2 抛出异常5.2.3 用户自定义异常5.2.4 定义清理行为5.2.5 预定义清理行为5.3 调试和测试5.3.1 单元测试5.3.2 调试5.3.3 文档测试5.4 进程和线程5.4.1 ThreadLocal5.4.2 多进程5.4.3 多线程5.4.4 分布式进程5.4.5 进程 vs 线程第六章 函数式编程6.1 返回值为函数6.2 参数为函数6.3 匿名函数6.4 偏函数6.5 装饰器第七章 面对对象编程7.1 作用域和命名空间7.2 获取对象信息7.3 继承和多态7.4 私有变量7.5 类和实例7.6 使用@property7.7 使用slots7.8 使用枚举类7.9 使用元类第八章 模块管理8.1 深入模块8.2 标准模块8.3 使用模块8.4 常用内建模块8.5 常用第三方模块8.6 文件读写（glob）第九章 应用9.1 网络编程9.1.1 TCP/Ip简介9.1.2 TCP编程9.1.2 UDP编程9.2 电子邮件9.2.1 POP3 收取邮件9.2.2 SMTP 发送邮件9.3 访问数据库9.3.1 使用 MySQL9.3.2 使用SQLAlchemy9.3.2 使用SQLite9.4 数据压缩9.5 性能度量9.6 质量控制9.7 IO编程9.7.1 StringIO和BytesIO9.7.2 操作文件和目录9.7.3 文件读写9.7.4 序列化9.8 生成日历9.9 斐波那契数列9.10 阿姆斯特朗数9.11 爬虫9.12 web项目9.13 数据挖掘9.14 机器学习第十章 源代码地址learn-Python","tags":[{"name":"小白之路","slug":"小白之路","permalink":"https://mowatermelon.github.io/tags/小白之路/"},{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"python","slug":"python","permalink":"https://mowatermelon.github.io/tags/python/"}]},{"title":"Js学习之new","date":"2017-11-01T16:00:00.000Z","path":"2017/11/02/js-Learning-new/","text":"一直不清楚显式声明和隐式原型的关系，整理了一下相关疑惑，并且整理了new和instanceof关于显式声明和隐式声明的相关知识 1 概念1.1 显式原型prototype — 显式原型 (explicit prototype property)，每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 请注意通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。 NOTE Function objects created using Function.prototype.bind do not have a prototype property or the [[Code]], [[FormalParameters]], and [[Scope]] internal properties. —– ECMAScript Language Specification 这个属性是一个指针，指向一个对象，它是显示修改对象的原型的属性。 1.2 隐式原型__proto__ — 隐式原型 (implicit prototype link)：JS中任意对象都有一个内置属性[[prototype]]，是JS内部使用寻找原型链的属性在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过__proto__来访问。 ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf()，即Object.getPrototypeOf(obj)===obj.__proto__，用chrome和FF都可以访问到对象的__proto__属性，IE不可以。 隐式原型指向创建这个对象的函数(constructor)的prototype。 但是请注意Object.prototype.__proto__ //null，即Object对象的显式原型的隐式原型是null，这个属于特例。 根据ECMA定义 to the value of its constructor’s &quot;prototype&quot;，指向创建这个对象的函数的显式原型。 所以关键的点在于找到创建这个对象的构造函数，接下来就来看一下JS中对象被创建的方式，一眼看过去似乎有三种方式： 对象字面量的方式 new 的方式 ES5中的Object.create() 但是本质上只有一种方式，也就是通过new来创建。为什么这么说呢，字面量的方式只是一种为了开发人员更方便创建对象的一个语法糖，本质就是 var o = new Object(); o.xx = xx;o.yy=yy;。 Object.create()是ES5中新增的方法，在这之前这被称为原型式继承。其实本质依然是通过new来创建的，如下面栗子中其实和new Boolean()，效果是比较相似的。 不同之处在于由 Object.create() 创建出来的对象没有构造函数，因为create()接收的就是一个内建函数的显式声明，如下栗子中，创建出来的对象的隐式声明其实是指向传入的实参，即ss.__proto__===Boolean.prototype。 12345678var ss =Object.create(Boolean.prototype)console.log(typeof ss);//objectconsole.log(ss.prototype);//undefined// console.log(ss.prototype.__proto__);//Cannot read property '__proto__' of undefinedconsole.log(ss.__proto__);//[Boolean: false]console.log(ss.__proto__.prototype);//undefinedconsole.log(ss.constructor);//[Function: Boolean] 2 作用2.1 显式原型用来实现基于原型的继承与属性的共享。 ECMAScript does not use classes such as those in C++, Smalltalk, or Java. Instead objects may be created in various ways including via a literal notation or via constructors which create objects and then execute code that initialises all or part of them by assigning initial values to their properties. Each constructor is a function that has a property named “prototype” that is used to implement prototype-based inheritance and shared properties.Objects are created by using constructors in new expressions; for example, new Date(2009,11) creates a new Date object. —-ECMAScript Language Specification 2.2 隐式原型构成原型链，同样用于实现基于原型的继承。 举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着__proto__依次查找。 Every object created by a constructor has an implicit reference (called the object’s prototype) to the value of its constructor’s “prototype” —-ECMAScript Language Specification 3 联合案例12345678//新建测试变量var temp_O = new Object();var temp_B = new Boolean();var temp_N = new Number();var temp_S = new String();var temp_A = new Array();var temp_D = new Date();var temp_F = new Function(); 3.1 显式声明的隐式声明除了undefined和null对象类型之外，对象的隐式声明(__proto__)都是{}，因为内建对象(built-in object)的显式声明和实例对象的显式声明都是一个对象。比如Array.prototype和temp_F.prototype都是一个对象，所以它们的隐式声明都是{}，指向的都是Object这个构造体的显示声明，即Object.prototype。 请注意Object.prototype.__proto__和Function.prototype.__proto__是一个特例。 变量 使用方法 结果 Object Object.prototype {} Boolean Boolean.prototype [Boolean: false] Number Number.prototype [Number: 0] String String.prototype [String: ‘’] Array Array.prototype [] Date Date.prototype Date {} Function Function.prototype [Function] Object Object.prototype.__proto__ null Boolean Boolean.prototype.__proto__ {} Number Number.prototype.__proto__ {} String String.prototype.__proto__ {} Array Array.prototype.__proto__ {} Date Date.prototype.__proto__ {} Function Function.prototype.__proto__ [Function] temp_O temp_O.prototype.__proto__ Cannot read property __proto__ of undefined temp_B temp_B.prototype.__proto__ Cannot read property __proto__ of undefined temp_N temp_N.prototype.__proto__ Cannot read property __proto__ of undefined temp_S temp_S.prototype.__proto__ Cannot read property __proto__ of undefined temp_A temp_A.prototype.__proto__ Cannot read property __proto__ of undefined temp_D temp_D.prototype.__proto__ Cannot read property __proto__ of undefined temp_F temp_F.prototype.__proto__ {} 3.2 隐式声明的显式声明除了undefined和null对象类型之外，所有对象的显式声明(prototype)都是undefined，因为内建对象(built-in object)的隐式声明和实例对象的隐式声明都是一个对象。比如Array.__proto__和temp_F.__proto__都是一个对象，所以它们的显示声明都是undefined。 构造函数因为都是Function()的实例，因此构造体的隐式声明也就都指向Function.prototype。 变量 使用方法 结果 Object Object.__proto__ [Function] Boolean Boolean.__proto__ [Function] Number Number.__proto__ [Function] String String.__proto__ [Function] Array Array.__proto__ [Function] Date Date.__proto__ [Function] Function Function.__proto__ [Function] Object Object.__proto__.prototype undefined Boolean Boolean.__proto__.prototype undefined Number Number.__proto__.prototype undefined String String.__proto__.prototype undefined Array Array.__proto__.prototype undefined Date Date.__proto__.prototype undefined Function Function.__proto__.prototype undefined temp_O temp_O.__proto__.prototype undefined temp_B temp_B.__proto__.prototype undefined temp_N temp_N.__proto__.prototype undefined temp_S temp_S.__proto__.prototype undefined temp_A temp_A.__proto__.prototype undefined temp_D temp_D.__proto__.prototype undefined temp_F temp_F.__proto__.prototype undefined 4 new12var Person = function()&#123;&#125;;var p = new Person(); new的过程拆分成以下三步： var p={}; 也就是说，初始化一个空对象p。 p.__proto__ = Person.prototype; 将临时对象的隐式声明指向构造体的显式声明上。 Person.call(p); 也就是说构造p，也可以称之为初始化p。 关键在于第二步，我们来证明一下： 123var Person = function()&#123;&#125;;var p = new Person();console.log(p.__proto__ === Person.prototype);//true 5 instanceof5.1 定义在 JavaScript 中，判断一个变量的类型常常会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 object。ECMAScript 引入了 Java 中的运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。 instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。请注意这个是检测的是原型链，不是单纯的只检测对象的隐式声明一次，是不断的在对象的隐式声明中去找构造体的显式声明，注意如果传入的第一个参数如果不是对象，会直接返回false。 5.2 用法通常来讲，使用 instanceof 就是判断一个实例是否属于某种类型。 1234// 判断 foo 是否是 Foo 类的实例function Foo()&#123;&#125;var foo = new Foo();console.log(foo instanceof Foo)//true 另外，更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型。 12345678// 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例function Aoo()&#123;&#125;function Foo()&#123;&#125;Foo.prototype = new Aoo();//JavaScript 原型继承var foo = new Foo();console.log(foo instanceof Foo)//trueconsole.log(foo instanceof Aoo)//true 上面的代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。 5.3 语言规范ECMAScript-262 edition 3 中 关于 instanceof 运算符的定义 123456789101112131415161718192021222324252627282930313233343511.8.6 The instanceof operator The production RelationalExpression: RelationalExpression instanceof ShiftExpression is evaluated as follows: 1. Evaluate RelationalExpression. 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2) 3. Evaluate ShiftExpression. 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4) 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object， //抛出异常 /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */ 6. If Result(4) does not have a [[HasInstance]] method, throw a TypeError exception. // 相当于这样调用：Result(4).[[HasInstance]](Result(2)) 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2). 8. Return Result(7). // 相关的 HasInstance 方法定义 15.3.5.3 [[HasInstance]] (V) Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2) When the [[HasInstance]] method of F is called with value V, the following steps are taken: 1. If V is not an object, return false.// 如果 V 不是 object，直接返回 false 2. Call the [[Get]] method of F with property name &quot;prototype&quot;.// 用 [[Get]] 方法取 // F 的 prototype 属性 3. Let O be Result(2).//O = F.[[Get]](&quot;prototype&quot;) 4. If O is not an object, throw a TypeError exception. 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]] 6. If V is null, return false. // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 true；否则，到 Step 8 返回 Step 5 继续循环 7. If O and V refer to the same object or if they refer to objects joined to each other (section 13.1.2), return true. 8. Go to step 5. 上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单， 12345678910111213141516171819202122// object instanceof constructor//instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。//模拟instanceof 功能function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式 var O = R.prototype;// 取 R 的显示原型 L = L.__proto__;// 取 L 的隐式原型 //请注意这个判断条件，目的是无限循环，不断在L的隐式声明链中找R的显式说明，只有完全找不到的时候，才会返回false， //请注意undefined，null没有属性的，没有隐式声明的。 while (true) &#123; if (L === null)&#123; return false; &#125; if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true &#123; return true; &#125; L = L.__proto__;//L.__proto__.__proto__.__proto__.__proto__.__proto__.......... &#125;&#125; 6 参考网站 JavaScript instanceof 运算符深入剖析","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"prototype","slug":"prototype","permalink":"https://mowatermelon.github.io/tags/prototype/"},{"name":"__proto__","slug":"proto","permalink":"https://mowatermelon.github.io/tags/proto/"},{"name":"new","slug":"new","permalink":"https://mowatermelon.github.io/tags/new/"}]},{"title":"西瓜有话说之Js学习疑惑篇","date":"2017-10-31T16:00:00.000Z","path":"2017/11/01/js-Thinking-confusion/","text":"1 js类型强制转化1.1 Date强转为何Date强转之后构造体成了String？ 主要原因 ：JS中Date除了是一个构造器外，同时也是一个函数，没有new的时候，相当于调用了Date函数，然后把返回值(一个字符串类型的日期)赋值给doArr,并没有产生新的Date实例，所以变量和Date构造器没有什么关系，继承的都是String这个构造器的方法和属性。 123456789101112131415161718192021222324//默认String和Date没什么关系var oDate = new Date();console.log(oDate instanceof String);//falseconsole.log(String instanceof Date);//falseconsole.log(Date instanceof String);//false//----------------------------------------但是请注意console.log(String().constructor);//[Function: String]console.log(Date().constructor);//[Function: String]console.log(String().constructor===Date().constructor);//trueconsole.log(String().__proto__);//[String: '']console.log(Date().__proto__);//[String: '']console.log(String().__proto__===Date().__proto__);//true//----------------------------------------举个实际的例子var oArr = new Array(68);var noArr = Number(oArr);var doArr = Date(oArr);console.log(doArr.constructor);//[Function: String] 为何啊console.log(doArr.__proto__); //[String: ''] 为何啊 明明这两个数据类型没什么关联//其他类型强转之后，实例的构造体都是正常修改为强转的对象类名console.log(noArr.constructor);//[Function:Number]console.log(noArr.__proto__); //[Number: 0] 2 正则匹配2.1 search2.1.1 正则与undefined特殊字面量明明都可以正常转成正则对象，那为何检测undefined的时候，所有案例变量都匹配成功了？ 主要原因 ：undefined会转成/(?:)/然后进行检测，正则中(?:pattern) 的意思是匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用，因为/(?:)/的pattern值为空，所以上面正则的意思是匹配所有。 123456789101112131415161718192021222324252627282930313233343536var a = 4;var b = 8;var strString = \"hello watermelon\";var oo = new Object();var oString = new String(\"hello world\");var oBool = new Boolean(true);var oNum = new Number(68);var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date();var oString_1 = 'A \\uD87E\\uDC04 Z';var tString_1 =`hello Template`;var tString_2 =`hello line 1 hello line 2`;//`string text $&#123;expression&#125; string text` 在模版字符串中使用表达式var tString_3 =`Fifteen is $&#123;a + b&#125; and\\nnot $&#123;2 * a + b&#125;.`;console.log(strString.search(undefined));//0console.log(oString.search(undefined));//0console.log(oString_1.search(undefined));//0console.log(tString_1.search(undefined));//0console.log(tString_2.search(undefined));//0console.log(tString_3.search(undefined));//0console.log(oString.search(true));//-1console.log(oString.search(false));//-1console.log(oString.search(null));//-1console.log(oString.search(NaN));//-1console.log(new RegExp(true));// /true/console.log(new RegExp(false));// /false/console.log(new RegExp(undefined));// /(?:)/console.log(new RegExp(null));// /null/console.log(new RegExp(NaN));// /NaN/ 2.1.2 正则与Objectoo是一个空对象，它的字面量是{}，但是为什么可以和案例变量都进行匹配。 主要原因 ：oo传入search方法中是[object Object]，在正则中中括号的意思是匹配包含在括号中的任意字符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var a = 4;var b = 8;var strString = \"hello watermelon\";var oo = new Object();var oString = new String(\"hello world\");var oBool = new Boolean(true);var oNum = new Number(68);var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date();var oString_1 = 'A \\uD87E\\uDC04 Z';var tString_1 =`hello Template`;var tString_2 =`hello line 1 hello line 2`;//`string text $&#123;expression&#125; string text` 在模版字符串中使用表达式var tString_3 =`Fifteen is $&#123;a + b&#125; and\\nnot $&#123;2 * a + b&#125;.`;var tString_4 = \"大吉大利今晚吃西瓜!\";console.log(strString.search(oo));//1 位置对应的字母是 econsole.log(strString.charAt(1));//econsole.log(oString.search(oo));//1 位置对应的字母是 econsole.log(oString.charAt(1));//econsole.log(oString_1.search(oo));//1 位置对应的字母是 空格console.log(oString_1.charAt(1));//\\s 位置对应的字母是 空格console.log(tString_1.search(oo));//1 位置对应的字母是 econsole.log(tString_1.charAt(1));//econsole.log(tString_2.search(oo));//1 位置对应的字母是 econsole.log(tString_2.charAt(1));//econsole.log(tString_3.search(oo));//3 位置对应的字母是 tconsole.log(tString_3.charAt(3));//tconsole.log(tString_4.search(oo));//-1console.log(strString.search(oBool));//-1console.log(strString.search(oNum));//-1console.log(strString.search(oArray));//-1console.log(strString.search(oDate));//-1console.log(new RegExp(oo));// /[object Object]///中括号的意思是 匹配中括号的任意一个字符// 所以对应正则的意思是只要字符串中存在object这几个字母和空格都会被匹配console.log(new RegExp(oString));// /hello world/console.log(new RegExp(oBool));// /true/console.log(new RegExp(oNum));// /68/console.log(new RegExp(oArray));// /demo,melon,water/console.log(new RegExp(oDate));// /Thu Dec 21 2017 19:39:40 GMT+0800 (中国标准时间)/ 3 localeCompare3.1 localeCompare与正则参数就目前测试的相关数据结果表现，不管字符串中是什么内容，传入什么样的正则值，或者传入制表符，空格，和换行符等等特殊字符，localeCompare都会返回正值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var a = 4;var b = 8;var strString = \"hello watermelon\";var oo = new Object();var oString = new String(\"hello world\");var oBool = new Boolean(true);var oNum = new Number(68);var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date();var oString_1 = 'A \\uD87E\\uDC04 Z';var tString_1 =`hello Template`;var tString_2 =`hello line 1 hello line 2`;//`string text $&#123;expression&#125; string text` 在模版字符串中使用表达式var tString_3 =`Fifteen is $&#123;a + b&#125; and\\nnot $&#123;2 * a + b&#125;.`;var tString_4 = \"大吉大利今晚吃西瓜!\"console.log(\"-------------------测试/\\s/\");console.log(strString.localeCompare(/\\s/));//1console.log(oString.localeCompare(/\\s/));//1console.log(oString_1.localeCompare(/\\s/));//1console.log(tString_1.localeCompare(/\\s/));//1console.log(tString_2.localeCompare(/\\s/));//1console.log(tString_3.localeCompare(/\\s/));//1console.log(tString_4.localeCompare(/\\s/));//1console.log(\"-------------------测试/\\o/\");console.log(strString.localeCompare(/\\o/));//1console.log(oString.localeCompare(/\\o/));//1console.log(oString_1.localeCompare(/\\o/));//1console.log(tString_1.localeCompare(/\\o/));//1console.log(tString_2.localeCompare(/\\o/));//1console.log(tString_3.localeCompare(/\\o/));//1console.log(tString_4.localeCompare(/\\o/));//1console.log(\"-------------------测试/\\n/\");console.log(strString.localeCompare(/\\n/));//1console.log(oString.localeCompare(/\\n/));//1console.log(oString_1.localeCompare(/\\n/));//1console.log(tString_1.localeCompare(/\\n/));//1console.log(tString_2.localeCompare(/\\n/));//1console.log(tString_3.localeCompare(/\\n/));//1console.log(tString_4.localeCompare(/\\n/));//1console.log(tString_4.localeCompare(/\\o/));//1console.log(\"-------------------测试/helllo world/\");console.log(strString.localeCompare(/helllo world/));//1console.log(oString.localeCompare(/helllo world/));//1console.log(oString_1.localeCompare(/helllo world/));//1console.log(tString_1.localeCompare(/helllo world/));//1console.log(tString_2.localeCompare(/helllo world/));//1console.log(tString_3.localeCompare(/helllo world/));//1console.log(tString_4.localeCompare(/helllo world/));//1console.log(tString_4.localeCompare(/helllo world/));//1console.log(\"-------------------测试/大吉大利/\");console.log(/大吉大利/);console.log(strString.localeCompare(/大吉大利/ig));//1console.log(oString.localeCompare(/大吉大利/ig));//1console.log(oString_1.localeCompare(/大吉大利/ig));//1console.log(tString_1.localeCompare(/大吉大利/ig));//1console.log(tString_2.localeCompare(/大吉大利/ig));//1console.log(tString_3.localeCompare(/大吉大利/ig));//1console.log(tString_4.localeCompare(/大吉大利/ig));//1console.log(tString_2);//hello line 1\\n\\t\\t\\t\\thello line 2console.log(tString_2.localeCompare(\" \"));//1console.log(tString_2.localeCompare(\" \"));//1console.log(tString_2.localeCompare(\" \"));//1console.log(tString_2.localeCompare(\" \"));//1console.log(tString_2.localeCompare(\" \"));//1 3.2 localeCompare判断目前看来不管传入的子字符串和原始字符串是否存在包含关系，结果都不一定是正值,在测试数据结果中不发现是单纯的通过两个字符串首字母进行对比。 3.2.1 两个字符串的首字母相同首字母相同，但是得到的结果却不一定是正值，会根据子字符串的长度还有包含的字母不同，返回不同的值，但是这个具体处理逻辑我不太懂。 1234567891011121314151617181920212223242526272829303132console.log(strString);//hello watermelonconsole.log(strString.localeCompare(\"h\"));//1console.log(strString.localeCompare(\"H\"));//1console.log(strString.localeCompare(\"hello watermelon1\"));//-1 修改了原有字符串的长度，返回 -1 这个我可以理解//不是递归对比每一个字母在字母表中的位置，返回总的对比结果吗，//还是递归对比每一个字母在ACSII码表中的值进行排序对比，返回总的对比结果// a 不是比原有的 l在字母表中的位置高很多吗？// z 不是比原有的 l在字母表中的位置低很多吗？// 而且我子字符串长度的值比原始字符串长度还要多一位，为何还是会存在返回正值的情况console.log(strString.localeCompare(\"healo watermelon1\"));//1 修改了原有字符串的一个字母为 a 作为子字符串，返回 1console.log(strString.localeCompare(\"hezlo watermelon1\"));//-1 修改了原有字符串的一个字母为 z 作为子字符串，返回 -1，console.log(oString_1);//A 你 Zconsole.log(oString_1.localeCompare(\"a\"));//1console.log(oString_1.localeCompare(\"A\"));//1console.log(oString_1.localeCompare(\"A 你 Z。\"));//-1console.log(tString_3);//Fifteen is 12 and\\nnot 16.console.log(tString_3.localeCompare(\"fifteen\"));//1console.log(tString_3.localeCompare(\"Fifteen\"));//1console.log(tString_3.localeCompare(\"Fifteen is 12 and\\nnot 16.。\"));//1console.log(tString_3.localeCompare(\"Fiftaen\"));//1 修改了原有字符串的一个字母为 a 作为子字符串，返回 1console.log(tString_3.localeCompare(\"Fiftzen\"));//-1 修改了原有字符串的一个字母为 z 作为子字符串，返回 -1console.log(\"-------------------测试num\");console.log(oString.localeCompare(1));//1console.log(oString.localeCompare(1.1));//1console.log(oString.localeCompare(1.5));//1console.log(oString.localeCompare(1.8));//1console.log(oString.localeCompare(-1));//1 3.2.2 原始字符串包含子字符串传入的子字符串是完全被包含于原始字符串的，但是结果不一定都是返回正值，子字符串长度不是一个参考值？ 12345678910111213141516171819202122console.log(strString);//hello watermelonconsole.log(strString.localeCompare(\"h\"));//1console.log(strString.localeCompare(\"llo\"));//-1console.log(oString_1);//A 你 Zconsole.log(oString_1.localeCompare(\"A\"));//1console.log(oString_1.localeCompare(\"\\uD87E\\uDC04\"));//-1console.log(oString_1.localeCompare(\"你\"));//-1console.log(oString_1.normalize().localeCompare(\"你\"));//-1console.log(oString_1.localeCompare(\"你\"));//-1console.log(tString_2);//hello line 1\\n\\t\\t\\t\\thello line 2console.log(tString_2.localeCompare(\"line\"));//-1console.log(tString_3);//Fifteen is 12 and\\nnot 16.console.log(tString_3.localeCompare(\"Fifteen\"));//1console.log(tString_4);//大吉大利今晚吃西瓜!console.log(tString_4.localeCompare(\"吃西瓜\"));//1console.log(tString_4.localeCompare(\"大吉大利今晚吃西瓜\"));//1console.log(tString_4.localeCompare(\"大吉大利今晚吃西瓜 \"));//1console.log(tString_4.localeCompare(\"大吉大利今晚吃西瓜.\"));//-1 3.2.3 localeCompare与特殊值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364console.log(\"-------------------测试undefined\");//除了undefined本身，所有字符串与undefined做对比，都返回了-1 ，undefined不应该是一个比较小的值吗console.log(\"true\".localeCompare(undefined));//-1console.log(\"false\".localeCompare(undefined));//-1console.log(\"null\".localeCompare(undefined));//-1console.log(\"undefined\".localeCompare(undefined));//0console.log(\"NaN\".localeCompare(undefined));//-1console.log(strString.localeCompare(undefined));//-1console.log(oString.localeCompare(undefined));//-1console.log(oString_1.localeCompare(undefined));//-1console.log(tString_1.localeCompare(undefined));//-1console.log(tString_2.localeCompare(undefined));//-1console.log(tString_3.localeCompare(undefined));//-1console.log(tString_4.localeCompare(undefined));//-1console.log(\"-------------------测试true\");//除了true本身和完全是中文字符构成的字符串，所有字符串与true做对比，都返回了-1 ，这又是为何？console.log(strString.localeCompare(true));//-1console.log(oString.localeCompare(true));//-1console.log(oString_1.localeCompare(true));//-1console.log(tString_1.localeCompare(true));//-1console.log(tString_2.localeCompare(true));//-1console.log(tString_3.localeCompare(true));//-1console.log(tString_4.localeCompare(true));//1console.log(\"-------------------测试false\");console.log(strString.localeCompare(false));//1console.log(oString.localeCompare(false));//1console.log(oString_1.localeCompare(false));//-1 不懂为何结果是 -1console.log(tString_1.localeCompare(false));//1console.log(tString_2.localeCompare(false));//1console.log(tString_3.localeCompare(false));//1console.log(tString_4.localeCompare(false));//1console.log(\"-------------------测试null\");//除了null本身和完全是中文字符构成的字符串，所有字符串与null做对比，都返回了-1 ，null不应该是一个比较小的值吗console.log(strString.localeCompare(null));//-1console.log(oString.localeCompare(null));//-1console.log(oString_1.localeCompare(null));//-1console.log(tString_1.localeCompare(null));//-1console.log(tString_2.localeCompare(null));//-1console.log(tString_3.localeCompare(null));//-1console.log(tString_4.localeCompare(null));//1console.log(\"-------------------测试NaN\");//除了NaN本身和完全是中文字符构成的字符串，所有字符串与NaN做对比，都返回了-1 ，NaN不应该是一个比较小的值吗console.log(strString.localeCompare(NaN));//-1console.log(oString.localeCompare(NaN));//-1console.log(oString_1.localeCompare(NaN));//-1console.log(tString_1.localeCompare(NaN));//-1console.log(tString_2.localeCompare(NaN));//-1console.log(tString_3.localeCompare(NaN));//-1console.log(tString_4.localeCompare(NaN));//1console.log(\"-------------------测试oo\");console.log(strString.localeCompare(oo));//1console.log(oString.localeCompare(oo));//1console.log(oString_1.localeCompare(oo));//1console.log(tString_1.localeCompare(oo));//1console.log(tString_2.localeCompare(oo));//1console.log(tString_3.localeCompare(oo));//1console.log(tString_4.localeCompare(oo));//1 4 数据类型学习常用的有六大数据类型，一般实例化对象的时候，都是new关键词加上数据类型加上括号，今天突然想到如果不加括号怎样，然后发现两种情况下实例化的变量的值从表面上看几乎是一模一样的的，但是在做等式匹配的时候，不管是用全等还是用普通等式，都是返回的false. 主要原因 ：基本类型是通过值来比较，而对象（Object，Boolean，Number，String，Array，Date，Function）及普通对象通过指针指向的内存中的地址来做比较。 123456789101112131415161718192021222324252627282930313233343536373839var temp_O = new Object;var temp_B = new Boolean;var temp_N = new Number;var temp_S = new String;var temp_A = new Array;var temp_D = new Date;var temp_F = new Function;console.log(temp_O);//&#123;&#125;console.log(temp_B);//[Boolean: false]console.log(temp_N);//[Number: 0]console.log(temp_S);//[String: '']console.log(temp_A);//[]console.log(temp_D);//2018-01-07T09:11:45.720Zconsole.log(temp_F);//[Function: anonymous]console.log(new Object());//&#123;&#125;console.log(new Boolean());//[Boolean: false]console.log(new Number());//[Number: 0]console.log(new String());//[String: '']console.log(new Array());//[]console.log(new Date());//2018-01-07T09:26:55.136Zconsole.log(new Function());//[Function: anonymous]console.log((new Object())===temp_O);//falseconsole.log((new Boolean())===temp_B);//falseconsole.log((new Number())===temp_N);//falseconsole.log((new String())===temp_S);//falseconsole.log((new Array())===temp_A);//falseconsole.log((new Date())===temp_D);//falseconsole.log((new Function())===temp_F);//falseconsole.log((new Object())===(new Object()));//falseconsole.log((new Boolean())===(new Boolean()));//falseconsole.log((new Number())===(new Number()));//falseconsole.log((new String())===(new String()));//falseconsole.log((new Array())===(new Array()));//falseconsole.log((new Date())===(new Date()));//falseconsole.log((new Function())===(new Function()));//false","tags":[{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"},{"name":"confusion","slug":"confusion","permalink":"https://mowatermelon.github.io/tags/confusion/"}]},{"title":"西瓜有话说之Js对象学习string篇","date":"2017-10-30T16:00:00.000Z","path":"2017/10/31/js-Thinking-object-string/","text":"1. 定义1.1 基本字符串字符串字面量 (通过单引号或双引号定义) 和 直接调用 String方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。基本字符串是没有相关扩展方法，只有将基本字符串可转化为字符串对象之后才可以使用字符串对象的方法，当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候，JavaScript会自动将基本字符串转换为字符串对象，并且调用相应的方法或者执行查询。 1.2 字符串对象一个用于字符串或一个字符序列的构造函数。字符串对于可以保存以文本形式表示的数据非常有用。 一些常用的字符串操作有：查询字符串长度，使用 + 和 += 运算符来构建和连接字符串，使用 indexOf 方法检查某一子字符串在父字符串中的位置，又或是使用substring方法提取从父字符串中提取子字符串。 1.3 模板字符串模板字面量/Template literals 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为模板字符串/template strings。 模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法(${expression})的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\\）。 1`\\`` === \"`\" // --&gt; true 2. 名词字典 本文中出现变量名词的解释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var a = 4;var b = 8;var strString = \"hello watermelon\";var oo = new Object();var oString = new String(\"hello world\");var oBool = new Boolean(true);var oNum = new Number(68);var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date();//D800-DBFF UTF-16的高半区 High-half zone of UTF-16//DC00-DFFF UTF-16的低半区 Low-half zone of UTF-16var oString_1 = 'A \\uD87E\\uDC04 Z';var tString_1 =`hello Template`;var tString_2 =`hello line 1 hello line 2`;//`string text $&#123;expression&#125; string text` 在模版字符串中使用表达式var tString_3 =`Fifteen is $&#123;a + b&#125; and\\nnot $&#123;2 * a + b&#125;.`;function tag(strings, ...values) &#123; //String存储的是非expression的字符串 //values存储的是expression计算之后的值 console.log(strings[0]); // \"Hello \" 在第一个expression前的值 console.log(strings[1]); // \" world \" 在第二个expression前的值 console.log(strings[2]); // \"hahaha\" 在第三个expression前的值 console.log(strings[3]); // \"\" 在第三个expression后的值 console.log(values[0]); // 12 第一个expression的值 console.log(values[1]); // 32 第二个expression的值 console.log(values[2]); // 0.5 第三个expression的值 return \"大吉大利今晚吃西瓜!\";&#125;console.log(strString);//hello watermelonconsole.log(oString);//[String: 'hello world']console.log(oString_1);//A 你 Z 中间不在BMP中的字符，会显示乱码console.log(tString_1);//hello Template//打印出来会保留原格式 比如原有的换行和缩进console.log(tString_2);//hello Template line 1 \\n \\t hello Template line 2// tag(tString_1);//h e l l undefined undefined undefined// tag(tString_2);//h e l l undefined undefined undefined// tag(tString_3);//F i f t undefined undefined undefinedconsole.log(tString_3);//Fifteen is 12 and \\n not 16.//tag `string text $&#123;expression&#125; string text` 在模版字符串中使用tag方法//在没有调用console之前，不会打印 大吉大利今晚吃西瓜!//tString_4的值其实就是tag函数的返回值 大吉大利今晚吃西瓜!var tString_4 = tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;hahaha $&#123; a / b&#125;`; 变量名 含义 举例 objectName 相关对象类型名称 就像上面js代码中String varName 相关对象类型实例化后的变量名 就像上面js代码中strString,oString,tString_1 varName_val 相关对象类型实例化后的实际内容 就像上面js代码中hello watermelon functionName 函数名称 就像上文的tag BMP 基本多文种平面（Basic Multilingual Plane），或称第0平面或0号平面（Plane 0），是Unicode中的一个编码区段。编码从U+0000至U+FFFF。现版本为修订10.0.0版，2017年6月20日出版。 无举例 ES5 ECMAScript第五版，发布为ECMAScript 2015，最初发布第一版时间为2009年12月发布，后来在发布时间2015年6月进行了大量修改 无举例 ES6 ECMAScript第六版（发布为ECMAScript 2016），发布时间2016年 无举例 ES7 ECMAScript第七版（发布为ECMAScript 2017），发布时间2017年 无举例 letter 字母 letter(8) 代表八个子母，一个字母长度为一 char 汉字 char(8) 代表八个汉字，一个汉字长度为一 num 数字 num(8) 代表八个数字，一个数字长度为一 sign 符号 sign(8) 代表八个符号，一个符号长度为一 \\s 空格符 \\s(8) 代表八个空格符，一个空格符长度为一 \\t 缩进符 \\t(8) 代表八个缩进符，一个缩进符长度为四 \\n 换行符 \\n(8) 代表八个换行符，一个换行符长度为一 \\u 换行符 \\u(8) 代表八个非BMP字符，一个非BMP字符长度为二 param1,param2,param3,…,paramN 函数中需要传入第一个到第N个的参数值 就像上面js代码中hello world 柔和方法 不会改变字符串原始值 就是执行某个方法之后，varName原本所包含的内容不会变化 强硬方法 会改变字符串原始值 就是执行某个方法之后，varName原本所包含的内容会变化 父字符串 原始的对象内容 就像上面js代码中strString,oString,tString_1 子字符串 传入需要检索或者替换的参数值 就像上面js代码中hello watermelon 接受负值参 函数接受负值的参数，并且可以正常处理返回对应的值 如果方法的描述中出现这五个字，则代表这个方法接受负值参数，如果没有出现，则代表不接受，请注意 不推荐使用 该特性是非标准的，请尽量不要在生产环境中使用它。 如果下面属性和方法的描述中出现这五个字，意思最好不要使用这个属性或者这个方法。 已废弃 目前现行的几大主流浏览器都不支持了 如果下面属性和方法的描述中出现这三个字，意思你使用了这个一般会报错，或者直接返回undefined。 测试中 此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 如果下面属性和方法的描述中出现这三个字，意思你使用了这个不一定被所有浏览器都兼容，最好不要使用这个属性或者这个方法。 3. 字符串的属性3.1 继承对象的属性 属性名 描述 使用方法 constructor 对创建对象的函数的引用（指针）。 varName.constructor __proto__ 对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型。 varName.__proto__ length 字符串的长度。 varName.length __count__ 已废弃，用来存放对象的可枚举的属性的个数 varName.__count__ __noSuchMethod__ 已废弃，属性曾经是指当调用某个对象里不存在的方法时即将被执行的函数，在__noSuchMethod__属性被移除之后，ECMAScript 2015 (ES6) 规范转而采用 Proxy 对象。 varName.__noSuchMethod__ = fun(id, args){} @param1 id 调用的不存在的方法名 @param2 args 传递给该方法的参数数组 __parent__ 已废弃，指向一个对象的上下文，对于最顶层对象来说,这个属性的值就是全局对象window。 varName.__parent__ 3.2 继承funciton的属性 属性名 描述 使用方法 arguments 不推荐使用，属性代表传入函数的实参，它是一个类数组对象。已经被废弃很多年了，现在推荐的做法是使用函数内部可用的 arguments 对象来访问函数的实参。在函数递归调用的时候（在某一刻同一个函数运行了多次，也就是有多套实参），那么 arguments 属性的值是最近一次该函数调用时传入的实参。如果函数不在执行期间，那么该函数的 arguments 属性的值是 null。 objectName.arguments or functionName.arguments arity 已废弃，返回一个函数的形参数量，是一个古老的已经没有浏览器支持的属性,你应该使用length属性来代替.。 objectName.arity or functionName.arity caller 不推荐使用，如果一个函数functionName是在全局作用域内被调用的,则functionName.caller为null,相反,如果一个函数是在另外一个函数作用域内被调用的,则functionName.caller指向调用它的那个函数，该属性的常用形式arguments.callee.caller替代了被废弃的arguments.caller。 objectName.caller or functionName.caller displayName 不推荐使用，获取函数的显示名称。 objectName.displayName or functionName.displayName length 指明函数的形参个数，length 是函数对象的一个属性值，指该函数有多少个必须要传入的参数，即形参的个数。形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数。与之对比的是，arguments.length 是函数被调用时实际传参的个数。 objectName.length or functionName.length name 返回一个函数声明的名称，使用new Function(...)语法创建的函数或只是 Function(...) create Function对象及其名称为anonymous。 objectName.name or functionName.name prototype 函数对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型。 objectName.prototype or functionName.prototype 3.3 字符串的常用属性值3.3.1 constructor 变量名 调取方式 属性值 strString strString.constructor [Function: String] oString oString.constructor [Function: String] oString_1 oString_1.constructor [Function: String] tString_1 tString_1.constructor [Function: String] tString_2 tString_2.constructor [Function: String] tString_3 tString_3.constructor [Function: String] tString_4 tString_4.constructor [Function: String] 3.3.2 proto 变量名 调取方式 属性值 strString strString.__proto__ [String: ‘’] oString oString.__proto__ [String: ‘’] oString_1 oString_1.__proto__ [String: ‘’] tString_1 tString_1.__proto__ [String: ‘’] tString_2 tString_2.__proto__ [String: ‘’] tString_3 tString_3.__proto__ [String: ‘’] tString_4 tString_4.__proto__ [String: ‘’] 3.3.3 length 变量名 调取方式 属性值 解释 strString strString.length 16 letter(15)+\\s(1) oString oString.length 11 letter(10)+\\s(1) oString_1 oString_1.length 6 letter(2)+\\s(2)+\\u(1) tString_1 tString_1.length 14 letter(13)+\\s(1) tString_2 tString_2.length 41 letter(18)+num(2)+\\s(4)+\\t(4)+\\n(1) tString_3 tString_3.length 25 letter(15)+num(4)+\\s(4)+sign(1)+\\n(1) tString_4 tString_4.length 10 char(9)+sign(1) 3.4 注意事项 特性名称 是否可修改 writable false enumerable false configurable false 提示 所有 String 的实例都继承自 String.prototype. 任何String.prototype上的改变都会影响到所有的 String 实例。 但是请注意由于每个varName的构造方法不同，所以在instanceof时候的结果不同，instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 123456//使用方法object instanceof constructoror object instanceof(constructor)// @param1 object 要检测的对象.// @param2 constructor 某个构造函数//instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 变量名 调取方式 属性值 strString strString instanceof(String) false oString oString instanceof(String) true tString_1 tString_1 instanceof(String) false tString_2 tString_2 instanceof(String) false tString_3 tString_3 instanceof(String) false tString_4 tString_4 instanceof(String) false 4. 字符串对象的柔和方法4.1. HTML相关方法4.1.1 概述 方法名 描述 参数 big() 不推荐使用，把字符串显示为大号字体，只在页面中才会有大两个字体号效果。 无 small() 不推荐使用， 把字符串显示为小号字体，只在页面中才会有小两个字体号效果。 无 blink() 不推荐使用， 把字符串显示闪动的字符串，目前没有看到有浏览器支持 无 bold() 不推荐使用， 把字符串显示粗体的字符串，只在页面中才会有粗体效果，IE不兼容。 无 italics() 不推荐使用，把字符串显示为斜体，只在页面中才会有效果。 无 strike() 不推荐使用， 把字符串显示为加了删除线的字符串，只在页面中才会有效果。 无 fixed() 不推荐使用， 把字符串显示为打字机文本显示的字符串，只在页面中才会有效果。 无 sub() 不推荐使用，把字符串显示为下标，只在页面中才会有效果。 无 sup() 不推荐使用， 把字符串显示为上标，只在页面中才会有效果。 无 anchor(anchorname) 不推荐使用，创建 HTML 锚。将字符串输出为有唯一标识的纯粹a标签，只在页面中才会有效果。 @param anchorname 必需，为锚定义名称。如果没有传入参数，则会输出一个name属性为undefined的a标签。 link(url) 不推荐使用， 把字符串显示为链接，只在页面中才会有效果。如果没有传入参数，则会输出一个href属性为undefined的a标签。 @param url必需，规定要链接的 URL。 fontcolor(color) 不推荐使用，返回指定的颜色的字符串。只在页面中才会有效果如果没有传入参数，则会输出一个color属性为undefined的font标签。 @param color必需。为字符串规定 font-color。该值必须是颜色名(red)、RGB 值(rgb(255,0,0))或者十六进制数(#FF0000)。 fontsize(size) 不推荐使用， 返回指定的字体大小的字符串。只在页面中才会有效果。如果没有传入参数，则会输出一个size属性为undefined的font标签。 @param size 参数必须是从 1 至 7 的数字，数字越大字体越大。 4.1.2 详细1) big() 使用方法 结果 varName.big() &lt;big&gt;varName_val&lt;/big&gt; 2) small() 使用方法 结果 varName.small() &lt;small&gt;varName_val&lt;/small&gt; 3) blink() 使用方法 结果 varName.blink() &lt;blink&gt;varName_val&lt;/blink&gt; 4) bold() 使用方法 结果 varName.bold() &lt;b&gt;varName_val&lt;/b&gt; 5) italics() 使用方法 结果 varName.italics() &lt;i&gt;varName_val&lt;/i&gt; 6) strike() 使用方法 结果 varName.strike() &lt;strike&gt;varName_val&lt;/strike&gt; 7) fixed() 使用方法 结果 varName.fixed() &lt;tt&gt;varName_val&lt;/tt&gt; 8) sub() 使用方法 结果 varName.sub() &lt;sub&gt;varName_val&lt;/sub&gt; 9) sup() 使用方法 结果 varName.sup() &lt;sup&gt;varName_val&lt;/sup&gt; 10) anchor(anchorname) 使用方法 结果 varName.anchor(param1) &lt;a name=&quot;param1&quot;&gt;varName_val&lt;/a&gt; 11) link(url) 使用方法 结果 varName.link(param1) &lt;a href=&quot;param1&quot;&gt;varName_val&lt;/a&gt; 12) fontcolor(color) 使用方法 结果 varName.fontcolor(param1) &lt;font color=&quot;param1&quot;&gt;varName_val&lt;/font&gt; 13) fontsize(size) 使用方法 结果 varName.fontsize(param1) &lt;font size=&quot;param1&quot;&gt;varName_val&lt;/font&gt; 4.2. 编码4.2.1 概述 方法名 描述 参数 charAt(index) 返回特定位置的字符，不提供参数就返回第一个字符的字符，提供游标值，就返回指定游标的字符 @param index 非必需，一个介于0 和字符串长度减1之间的正整数。 (0~varName.length-1)，如果不是一个数值，则默认为 0。 charCodeAt(index) 返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。 @param index 一个大于等于 0，小于字符串长度的整数。(0~varName.length-1)，如果不是一个数值，则默认为 0。 codePointAt(pos) 测试中， 返回使用UTF-16编码的给定位置的值的非负整数。 @param pos 这个字符串中需要转码的元素的位置。 normalize([form]) 测试中， 返回调用字符串值的Unicode标准化形式。 @param form 四种 Unicode 正规形式 “NFC”, “NFD”, “NFKC”, 以及 “NFKD” 其中的一个, 默认值为 “NFC”. fromCharCode(num1, …, numN) 返回一个字符串，而不是一个 String 对象。由于 fromCharCode 是 String 的静态方法，所以应该像这样使用：String.fromCharCode()，而不是作为你创建的 String 对象的方法。 @param num1, …, numN 一组序列数字，表示 Unicode 值。 fromCodePoint(num1, …, numN) 不推荐使用， 返回使用 Unicode 编码创建的字符串，如果传入无效的 Unicode 编码，将会抛出一个RangeError (例如： “RangeError: NaN is not a valid code point”)。 @param num1, …, numN 一组序列数字，表示 Unicode 值。 4.2.2 详细1) charAt(index)字符串中的字符从左向右索引，第一个字符的索引值为0，最后一个字符（假设该字符位于字符串 varName 中）的索引值为varName.length - 1。 如果指定的index值超出了该范围，则返回一个空字符串。而且本方法不管你传入多少参数，这边只会处理传入的第一个参数值，如果传进来为小数，这个方法是向上取整，举个栗子，你传入的值是1.2,这边就认为你传入的是2。 但是请注意，这个方法只能检测打印包含基本多文种平面（BMP）中的字符，如果字符串中包含的内容不在BMP中，打印的结果就会乱码。 使用方法 结果 oString.charAt() h oString.charAt(oString.length-1) d 错误示例 使用方法 结果 oString.charAt(1.2) e oString.charAt(1,2,3) h oString.charAt(-2) 空字符串 oString.charAt(oString) h oString.charAt(true) e oString.charAt(false) h oString.charAt(null) h oString.charAt(undefined) h oString.charAt(NaN) h oString.charAt(oo) h oString.charAt(oNum) 空字符串 oString.charAt(oArray) h oString.charAt(oDate) 空字符串 oString.charAt(oString.length) 空字符串 2) charCodeAt()Unicode 编码单元（code points）的范围从 0 到 1,114,111（0x10FFFF）。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样。关于 Unicode 的更多信息，可查看 JavaScript Guide。 注意，charCodeAt 总是返回一个小于 65,536 的值。这是因为高位编码单元（higher code point）使用一对（低位编码（lower valued））代理伪字符（”surrogate” pseudo-characters）来表示，从而构成一个真正的字符。因此，为了查看或复制（reproduce）65536 及以上编码字符的完整字符，需要在获取 charCodeAt(i) 的值的同时获取 charCodeAt(i+1) 的值（如同查看/reproducing 拥有两个字符的字符串一样），或者改为获取 codePointAt(i) 的值。 如果指定的 index 小于 0 或不小于字符串的长度，则 charCodeAt 返回 NaN。而且本方法不管你传入多少参数，这边只会处理传入的第一个参数值，如果传进来为小数，这个方法是向上取整，举个栗子，你传入的值是1.2,这边就认为你传入的是2。 返回值是一表示给定索引处（varName中index索引处）字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。如果你想要整个代码点的值，使用 codePointAt()。 向后兼容：在历史版本中（如 JavaScript 1.2），charCodeAt 返回一个数字，表示给定 index 处字符的 ISO-Latin-1 编码值。ISO-Latin-1编码集范围从 0 到 255。开头的 0 到 127 直接匹配 ASCII 字符集。 使用方法 结果 oString.charCodeAt() 104 oString.charCodeAt(oString.length-1) 100 错误示例 使用方法 结果 oString.charCodeAt(1.2) 101 oString.charCodeAt(1,2,3) 104 oString.charCodeAt(-2) NaN oString.charCodeAt(oString) 104 oString.charCodeAt(true) 101 oString.charCodeAt(false) 104 oString.charCodeAt(null) 104 oString.charCodeAt(undefined) 104 oString.charCodeAt(NaN) 104 oString.charCodeAt(oo) 104 oString.charCodeAt(oNum) NaN oString.charCodeAt(oArray) 104 oString.charCodeAt(oDate) NaN oString.charCodeAt(oString.length) NaN 常用的编码表 字符 对应的unicode值 \\t(水平制表符) 9 \\n(换行符) 10 \\s(空格) 32 !(感叹号) 33 “ 34 # 35 $ 36 % 37 &amp; 38 ‘ 39 ( 40 ) 41 * 42 + 43 , 44 - 45 .(英文句号) 46 / 47 0 48 1 49 2 50 3 51 4 52 5 53 6 54 7 55 8 56 9 57 : 58 ; 59 &lt; 60 = 61 &gt; 62 ? 63 @ 64 A 65 Z 90 [ 91 \\ 92 ] 93 ^ 94 _ 95 ` 96 a 97 z 122 { 123 (中竖线) 124 } 125 ~ 126 3) codePointAt(pos)返回值是在字符串中的给定索引的编码单元体现的数字，如果指定的 index 小于 0 或不小于字符串的长度则返回 undefined 。如果，则 codePointAt 返回 undefined。而且本方法不管你传入多少参数，这边只会处理传入的第一个参数值，如果传进来为小数，这个方法是向上取整，举个栗子，你传入的值是1.2,这边就认为你传入的是2。 如果在索引处开始没有UTF-16 代理对，将直接返回在那个索引处的编码单元。可以将codePointAt()看成更完整版本的charCodeAt()，因为对于BMP中的所有字符，这俩方法执行结果相同，只有传递非BMP的码位作用参数时，二者执行结果才有可能不同。 codePointAt()对于非BMP会返回完整的码位，即使这个码位包含多个编码单元，但是charCodeAt()仅仅返回位置pos处的第一个编码单元。 Surrogate Pair是UTF-16中用于扩展字符而使用的编码方式，是一种采用四个字节(两个UTF-16编码)来表示一个字符，称作代理对。 但是请注意，由于codePointAt()是ES5开始提出来的，所以在Safari浏览器不支持，其他浏览器比较新的版本才支持。 使用方法 结果 oString.codePointAt() 104 oString.codePointAt(oString.length-1) 100 错误示例 使用方法 结果 oString.codePointAt(1.2) 101 oString.codePointAt(1,2,3) 104 oString.codePointAt(-2) undefined oString.codePointAt(oString) 104 oString.codePointAt(true) 101 oString.codePointAt(false) 104 oString.codePointAt(null) 104 oString.codePointAt(undefined) 104 oString.codePointAt(NaN) 104 oString.codePointAt(oo) 104 oString.codePointAt(oNum) undefined oString.codePointAt(oArray) 104 oString.codePointAt(oDate) undefined oString.codePointAt(oString.length) undefined 4) normalize([form]) 参数缩写 参数全称 参数中文含义 NFC Normalization Form Canonical Composition 规范化形式规范组合 NFD Normalization Form Canonical Decomposition 规范化形式规范分解 NFKC Normalization Form Compatibility Composition 规范化形式兼容性组合 NFKD Normalization Form Compatibility Decomposition 规范化形式兼容性分解 警告 如果给 form 传入了非法的参数值, 则会直接抛出 RangeError 异常，RangeError: The normalization form should be one of NFC, NFD, NFKC, NFKD，不会自行处理，是一个很高冷的方法哦！ 而且这个和DOM方法中的normalize()没有任何关联哦，不要弄混了。 如果你字符串中没有什么非BMP的内容，那么你使用这个方法其实没有什么效果，返回的就是varName的varName_val没有做什么改变的。目前我主要测试的样例使用这个方法之后，没有什么直观的感受，如果之后遇见了不同的效果，我再来补充。 使用方法 结果 varName.normalize() varName_val varName.normalize(“NFC”) varName_val varName.normalize(“NFD”) varName_val varName.normalize(“NFKC”) varName_val varName.normalize(“NFKD”) varName_val 5) fromCharCode(num1, …, numN)尽管绝大部分常用的 Unicode 值可以用一个 16-bit 数字表示（正如 JavaScript 标准化过程早期），并且对于绝大部分值 fromCharCode() 返回一个字符（即对于绝大部分字符 UCS-2 值是 UTF-16 的子集），但是为了处理所有的 Unicode 值（至 21 bits），只用 fromCharCode() 是不足的。由于高位编码字符是用两个低位编码（lower value）表示形成的一个字符，因此String.fromCodePoint() （ES6 草案的一部分）被用来返回这样一对低位编码，从而可以完全表示这些高位编码字符。 如果传进来参数为小数，这个方法是向上取整，举个栗子，你传入的值是1.2,这边就认为你传入的是2，不传参数的时候或者传一些不能识别的参数会方法返回空字符串。 使用方法 结果 objectName.fromCharCode(65) A 错误示例 使用方法 结果 objectName.fromCharCode() 空字符串 objectName.fromCharCode(65.2) A objectName.fromCharCode(65.8,66,67) ABC objectName.fromCharCode(-2) 空字符串 objectName.fromCharCode(oString) 空字符串 objectName.fromCharCode(true) 乱码 objectName.fromCharCodet(false) 空字符串 objectName.fromCharCode(null) 空字符串 objectName.fromCharCode(undefined) 空字符串 objectName.fromCharCode(NaN) 空字符串 objectName.fromCharCode(oo) 空字符串 objectName.fromCharCode(oNum) D objectName.fromCharCode(oArray) 空字符串 objectName.fromCharCode(oDate) 乱码 6) fromCodePoint(num1, …, numN)因为fromCodePoint()是String的一个静态方法，所以只能通过 String.fromCodePoint()这样的方式来使用，不能在你创建的String对象实例上直接调用。 相当是fromCharCode()升级版，在处理非BMP内容功能包容性更强些，但是对传入的参数要求更严格一些。 警告 如果传入无效的 Unicode 编码，将会抛出一个RangeError (例如： RangeError: NaN is not a valid code point)。比如像小数，科学计数，undefined，负数，字符串，数组，时间戳等等，如果传入这些值，方法体会直接报错，不会再执行下面的，不会自行处理，是一个很高冷的方法哦！ 使用方法 结果 objectName.fromCodePoint(65) A objectName.fromCodePoint() 空字符串 objectName.fromCodePoint(oNum) D objectName.fromCodePoint(true) 乱码 objectName.fromCodePoint(false) 乱码 objectName.fromCodePoint(null) 乱码 错误示例 使用方法 结果 objectName.fromCodePoint(65.2) RangeError objectName.fromCodePoint(65.8,66,67) RangeError objectName.fromCodePoint(-2) RangeError objectName.fromCodePoint(oString) RangeError objectName.fromCodePoint(undefined) RangeError objectName.fromCodePoint(NaN) RangeError objectName.fromCodePoint(oo) RangeError objectName.fromCodePoint(oArray) RangeError objectName.fromCodePoint(oDate) RangeError 4.3. 检索4.3.1 概述 方法名 描述 参数 indexOf(searchValue[, fromIndex]) 从字符串对象中返回首个被发现的给定值的索引值开始在 fromIndex进行搜索。如果未找到该值，则返回-1。 @param searchValue 一个字符串表示被查找的值。@param fromIndex 可选 表示调用该方法的字符串中开始查找的位置。可以是任意整数。默认值为 0。如果 fromIndex &lt; 0 则查找整个字符串（如同传进了 0）。如果 fromIndex &gt;= varName.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 varName.length。 lastIndexOf(searchValue[, fromIndex]) 返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。 @param searchValue 一个字符串，表示被查找的值。@param fromIndex 从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。 includes(searchString[, position]) 不推荐使用，判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。 @param searchString 要在此字符串中搜索的字符串。@param position 可选。从当前字符串的哪个索引位置开始搜寻子字符串；默认值为0。 startsWith(searchString [, position]) 不推荐使用，判断字符串的起始位置是否匹配其他字符串中的字符。 @param searchString 要搜索的子字符串。@param position 在 varName 中搜索 searchString 的开始位置，默认值为 0，也就是真正的字符串开头处。 endsWith(searchString [, position]) 不推荐使用， 判断一个字符串的结尾是否包含其他字符串中的字符。 @param searchString 要搜索的子字符串。@param position 在 varName 中搜索 searchString 的结束位置，默认值为 varName.length，也就是真正的字符串结尾处。 search(regexp) 对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标。如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。 @param regexp 一个正则表达式（regular expression）对象。如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。 match(regexp) 将字符串与正则表达式匹配，并返回一个包含该搜索结果的数组。返回值array，一个包含了整个匹配结果以及任何括号捕获的匹配结果的 Array ；如果没有匹配项，则返回 null 。 @param regexp 一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你未提供任何参数，直接使用 match() ，那么你会得到一个包含空字符串的 Array ：[“”] 。 4.3.2 详细1) indexOf(searchValue[, fromIndex]) 指定值的第一次出现的索引; 如果没有找到 -1。 对于字符串中原本包含空格，tab缩进，tab键和空格键产生的空白占位格是不同的，indexOf方法会进行严格的匹配。 对于字符串中原本包含字母，indexOf方法会进行严格的大小写匹配。 对于字符串中包含的BMP字符，会严格匹配编码格式。 使用方法 结果 oString.indexOf(“ “) 5 oString.indexOf(“hell”) 0 oString.indexOf(“helLo”) -1 oString.indexOf(“hell”,3) -1 oString_1.indexOf(“\\uD87E\\uDC04”) 2 oString_1.indexOf(“你”) -1 oString_1.normalize(“NFC”).indexOf(“你”) 1 tString_2.indexOf(“ “)//空格键产生的空白占位格 -1 tString_2.indexOf(“ “)//tab键产生的空白占位格 13 oString_1.indexOf(“sss”) -1 第一个参数错误示例 进行匹配的时候，只要原始值是定义好的，加没加双引号都可以被正常检测出来。 布尔值字符串可以判断是否包含布尔值对象。 自己判断是否完全包含自己是可以正常检测的。 传入空字符串的时候，indexOf方法会直接返回0。 使用方法 结果 “true”.indexOf(true) 0 “true”.indexOf(“true”) 0 “true”.indexOf(oBool) 0 “false”.indexOf(false) 0 “false”.indexOf(“false”) 0 “false”.indexOf(oBool) -1 “null”.indexOf(null) 0 “null”.indexOf(“null”) 0 “undefined”.indexOf(undefined) 0 “undefined”.indexOf(“undefined”) 0 “NaN”.indexOf(NaN) 0 “NaN”.indexOf(“NaN”) 0 oString.indexOf(“”) 0 oString.indexOf(oString) 0 oString.indexOf(true) -1 oString.indexOf(false) -1 oString.indexOf(null) -1 oString.indexOf(undefined) -1 oString.indexOf(NaN) -1 第二个参数错误示例 索引值的范围是0~varName.length-1。 传入的数字是向下取整的，只取数字的整数部分，举个栗子，比如传入0.1-0.9，indexOf方法是当作0进行处理。 对于传入的负值整数，indexOf方法是当作0进行处理。 对于传入的String，Object和Array类型的值，indexOf方法是当作0进行处理。 对于Boolean类型的值，indexOf方法会将true转化成1，false转化成0，进行处理。 对于传入的Date类型的值，indexOf方法会自动转成对应的时间戳数值，进行检索匹配。 对于Number.NaN，Number.MIN_VALUE和Number.NEGATIVE_INFINITY，indexOf方法是当作0进行处理。 对于Number.MAX_VALUE和Number.POSITIVE_INFINITY，indexOf方法是当作超出varName.length进行处理。 使用方法 结果 oString.indexOf(“hell”,0.1) 0 oString.indexOf(“hell”,0.5) 0 oString.indexOf(“hell”,0.8) 0 oString.indexOf(“hell”,1) 0 oString.indexOf(“hell”,1.1) 0 oString.indexOf(“hell”,1.5) 0 oString.indexOf(“hell”,1.8) 0 oString.indexOf(“hell”,oString.length) -1 oString.indexOf(“hell”,-2) 0 oString.indexOf(“hell”,-3) 0 oString.indexOf(“hell”,true) -1 oString.indexOf(“hell”,false) 0 oString.indexOf(“hell”,”true”) 0 oString.indexOf(“hell”,”false”) 0 oString.indexOf(“hell”,oo) 0 oString.indexOf(“hell”,oBool) -1 oString.indexOf(“hell”,oArray) 0 oString.indexOf(“hell”,oDate) -1 oString.indexOf(“hell”,Number.NaN) 0 oString.indexOf(“hell”,Number.MAX_VALUE) -1 oString.indexOf(“hell”,Number.MIN_VALUE) 0 oString.indexOf(“hell”,Number.NEGATIVE_INFINITY) 0 oString.indexOf(“hell”,Number.POSITIVE_INFINITY) -1 2) lastIndexOf(searchValue[, fromIndex]) 对于字符串中原本包含空格，tab缩进，tab键和空格键产生的空白占位格是不同的，lastIndexOf方法会进行严格的匹配。 对于字符串中原本包含字母，lastIndexOf方法会进行严格的大小写匹配。 对于字符串中包含的BMP字符，会严格匹配编码格式。 与indexOf方法相比，lastIndexOf方法有更好的容错性，会对第二个参数做更多的处理。 使用方法 结果 oString.lastIndexOf(“ “) 5 oString.lastIndexOf(“hell”) 0 oString.lastIndexOf(“helLo”) -1 oString.lastIndexOf(“hell”,3) -1 oString_1.lastIndexOf(“\\uD87E\\uDC04”) 2 oString_1.lastIndexOf(“你”) -1 oString_1.normalize(“NFC”).lastIndexOf(“你”) 1 tString_2.lastIndexOf(“ “)//空格键产生的空白占位格 -1 tString_2.lastIndexOf(“ “)//tab键产生的空白占位格 13 oString_1.lastIndexOf(“sss”) -1 第一个参数错误示例 进行匹配的时候，只要原始值是定义好的，加没加双引号都可以被正常检测出来。 布尔值字符串可以判断是否包含布尔值对象。 自己判断是否完全包含自己是可以正常检测的。 传入空字符串的时候，lastIndexOf方法会直接返回varName.length。 使用方法 结果 “true”.lastIndexOf(true) 0 “true”.lastIndexOf(“true”) 0 “true”.lastIndexOf(oBool) 0 “false”.lastIndexOf(false) 0 “false”.lastIndexOf(“false”) 0 “false”.lastIndexOf(oBool) -1 “null”.lastIndexOf(null) 0 “null”.lastIndexOf(“null”) 0 “undefined”.lastIndexOf(undefined) 0 “undefined”.lastIndexOf(“undefined”) 0 “NaN”.lastIndexOf(NaN) 0 “NaN”.lastIndexOf(“NaN”) 0 oString.lastIndexOf(“”) 11 oString.lastIndexOf(oString) 0 oString.lastIndexOf(true) -1 oString.lastIndexOf(false) -1 oString.lastIndexOf(null) -1 oString.lastIndexOf(undefined) -1 oString.lastIndexOf(NaN) -1 第二个参数错误示例 索引值的范围是1~varName.length。 传入的大于0的数字是向下取整的，只取数字的整数部分，举个栗子，比如传入1.1-1.9，lastIndexOf方法是当作1进行处理。 对于传入的0和负值整数，lastIndexOf方法是当作1进行处理。 对于传入的String，Object和Array类型的值，lastIndexOf方法是当作1进行处理。 对于Boolean类型的值，indexOf方法会将true转化成1，false转化成0，进行处理。 对于传入的Date类型的值，lastIndexOf方法会自动转成对应的时间戳数值，进行检索匹配。 对于Number.NaN，Number.MIN_VALUE和Number.NEGATIVE_INFINITY，indexOf方法是当作1进行处理。 对于Number.MAX_VALUE和Number.POSITIVE_INFINITY，indexOf方法是当作varName.length进行处理。 使用方法 结果 oString.lastIndexOf(“hell”,0.1) 0 oString.lastIndexOf(“hell”,0.5) 0 oString.lastIndexOf(“hell”,0.8) 0 oString.lastIndexOf(“hell”,1) 0 oString.lastIndexOf(“hell”,1.1) 0 oString.lastIndexOf(“hell”,1.5) 0 oString.lastIndexOf(“hell”,1.8) 0 oString.lastIndexOf(“hell”,oString.length) 0 oString.lastIndexOf(“hell”,-2) 0 oString.lastIndexOf(“hell”,-3) 0 oString.lastIndexOf(“hell”,true) 0 oString.lastIndexOf(“hell”,false) 0 oString.lastIndexOf(“hell”,”true”) 0 oString.lastIndexOf(“hell”,”false”) 0 oString.lastIndexOf(“hell”,oo) 0 oString.lastIndexOf(“hell”,oBool) 0 oString.lastIndexOf(“hell”,oArray) 0 oString.lastIndexOf(“hell”,oDate) 0 oString.lastIndexOf(“hell”,Number.NaN) 0 oString.lastIndexOf(“hell”,Number.MAX_VALUE) 0 oString.lastIndexOf(“hell”,Number.MIN_VALUE) 0 oString.lastIndexOf(“hell”,Number.NEGATIVE_INFINITY) 0 oString.lastIndexOf(“hell”,Number.POSITIVE_INFINITY) 0 3) includes(searchString[, position])这个方法已经被加入到 ECMAScript 6标准中，但未必在所有的JavaScript实现中都可以使用。 在进行内容匹配的时候，这个方法是区分大小写的。 在 Firefox 18 - 39中，这个方法的名称叫contains()。由于下面的理由，在bug 1102219中，它被重命名为includes() ： 据报道，在Firefox 17上，一些使用MooTools 1.2的网站会崩溃掉。这个版本的MooTools会检查函数String.prototype.contains()是否存在，如果不存在的话，MooTools就添加它自己的函数。 通过在Firefox 17中引入这个函数，检查更改的行为在一定程度上导致了基于MooTools的String.prototype.contains()函数的代码实现中断。结果是，当MooTools的拓展导致MooTools 1.2.6版本的发布，此实现在Firefox 17中不可用和String.prototype.contains()在随后一个版本Firefox 18上是可用的。 MooTools 1.3会强制使用它自己版本的函数String.prototype.contains()，因此，依赖它的网站不会崩溃掉。然而，你应该注意此方法在MooTools 1.3 签名和ECMAScript 6 签名中的不同（在第二个参数）。后来，为了与ES6标准一致在MooTools 1.5版本及以上更改了签名。 对于字符串中原本包含空格，tab缩进，tab键和空格键产生的空白占位格是不同的，includes方法会进行严格的匹配。 对于字符串中原本包含字母，includes方法会进行严格的大小写匹配。 对于字符串中包含的BMP字符，会严格匹配编码格式。 使用方法 结果 oString.includes(“ “) true oString.includes(“llo”) true oString.includes(“lLo”) false oString.includes(“llo”,3) false oString_1.includes(“\\uD87E\\uDC04”) true oString_1.includes(“你”) false oString_1.normalize(“NFC”).includes(“你”) true tString_2.includes(“ “)//空格键产生的空白占位格 false tString_2.includes(“ “)//tab键产生的空白占位格 true oString_1.includes(“sss”) false 第一个参数错误示例 进行匹配的时候，只要原始值是定义好的，加没加双引号都可以被正常检测出来。 布尔值字符串可以判断是否包含布尔值对象。 自己判断是否完全包含自己是可以正常检测的。 contains()已经废弃。 传入空字符串的时候，includes方法会直接返回true。 使用方法 结果 “true”.includes(true) true “true”.includes(“true”) true “true”.includes(oBool) true “false”.includes(false) true “false”.includes(“false”) true “false”.includes(oBool) false “null”.includes(null) true “null”.includes(“null”) true “undefined”.includes(undefined) true “undefined”.includes(“undefined”) true “NaN”.includes(NaN) true “NaN”.includes(“NaN”) true oString.includes(“”) true oString.includes(oString) true varName.contains() 直接报错 第二个参数错误示例 索引值的范围是0~varName.length-1。 传入的数字是向下取整的，只取数字的整数部分，举个栗子，比如传入2.1-2.9，includes方法是当作2进行处理。 对于传入的负值整数，includes方法是当作0进行处理。 对于传入的String，Object，Array和Boolean类型的值，includes方法是当作0进行处理。 对于传入的Date类型的值，includes方法会自动转成对应的时间戳数值，进行检索匹配。 对于Number.NaN，Number.MIN_VALUE和Number.NEGATIVE_INFINITY，includes方法是当作0进行处理。 对于Number.MAX_VALUE和Number.POSITIVE_INFINITY，includes方法是当作超出varName.length进行处理。 使用方法 结果 oString.includes(“llo”,2.1) true oString.includes(“llo”,2.5) true oString.includes(“llo”,2.8) true oString.includes(“llo”,3) false oString.includes(“llo”,3.1) false oString.includes(“llo”,3.5) false oString.includes(“llo”,3.8) false oString.includes(“llo”,oString.length) false oString.includes(“llo”,-2) true oString.includes(“llo”,-3) true oString.includes(“llo”,true) true oString.includes(“llo”,false) true oString.includes(“llo”,”true”) true oString.includes(“llo”,”false”) true oString.includes(“llo”,oo) true oString.includes(“llo”,oBool) true oString.includes(“llo”,oArray) true oString.includes(“llo”,oDate) false oString.includes(“llo”,Number.NaN) true oString.includes(“llo”,Number.MAX_VALUE) false oString.includes(“llo”,Number.MIN_VALUE) true oString.includes(“llo”,Number.NEGATIVE_INFINITY) true oString.includes(“llo”,Number.POSITIVE_INFINITY) false 4) startsWith(searchString [, position]) 使用方法 结果 oString.startsWith(“hell”) true oString.startsWith(“ell”) false oString.startsWith(“ell”,1) true 第一个参数错误示例 进行匹配的时候，只要原始值是定义好的，加没加双引号都可以被正常检测出来。 布尔值字符串可以判断是否包含布尔值对象。 自己判断是否完全包含自己是可以正常检测的。 传入空字符串的时候，startsWith方法会直接返回true。 对于特殊的字面量，true，false，null，undefined和NaN，startsWith方法会当作普通字符串进行完全匹配 使用方法 结果 “true”.startsWith(true) true “true”.startsWith(“true”) true “true”.startsWith(oBool) true “false”.startsWith(false) true “false”.startsWith(“false”) true “false”.startsWith(oBool) false “null”.startsWith(null) true “null”.startsWith(“null”) true “undefined”.startsWith(undefined) true “undefined”.startsWith(“undefined”) true “NaN”.startsWith(NaN) true “NaN”.startsWith(“NaN”) true oString.startsWith(“”) true oString.startsWith(oString) true oString.startsWith(true) false oString.startsWith(false) false oString.startsWith(null) false oString.startsWith(undefined) false oString.startsWith(NaN) false 第二个参数错误示例 索引值的范围是0~varName.length-1。 传入的数字是向下取整的，只取数字的整数部分，举个栗子，比如传入0.1-0.9，startsWith方法是当作0进行处理。 对于传入的负值整数，startsWith方法是当作0进行处理，startsWith方法是当作0进行处理，相当于就是从字符串的索引值为0的到索引值为varName.length-1中间的字符串，检索开头是不是对应的传入的字符串。 对于传入的String，Object，Array和Boolean类型的值，startsWith方法是当作0进行处理，相当于就是从字符串的索引值为0的到索引值为varName.length-1中间的字符串，检索开头是不是对应的传入的字符串。 对于传入的Date类型的值，startsWith方法会自动转成对应的时间戳数值，相当于就是从字符串的索引值为varName.length的到索引值为varName.length中间的字符串，检索开头是不是对应的传入的字符串。 对于Number.NaN，Number.MIN_VALUE和Number.NEGATIVE_INFINITY，startsWith方法是当作0进行处理，相当于就是从字符串的索引值为0的到索引值为varName.length-1中间的字符串，检索开头是不是对应的传入的字符串。 对于Number.MAX_VALUE和Number.POSITIVE_INFINITY，startsWith方法是当作超出varName.length进行处理，相当于就是从字符串的索引值为varName.length的到索引值为varName.length中间的字符串，检索开头是不是对应的传入的字符串。 使用方法 结果 oString.startsWith(“hell”,10.1) false oString.startsWith(“hell”,10.5) false oString.startsWith(“hell”,10.8) false oString.startsWith(“hell”,11) true oString.startsWith(“hell”,11.1) true oString.startsWith(“hell”,11.5) true oString.startsWith(“hell”,11.8) true oString.startsWith(“hell”,-10) false oString.startsWith(“hell”,-11) false oString.startsWith(“hell”,true) false oString.startsWith(“hell”,false) false oString.startsWith(“hell”,”true”) false oString.startsWith(“hell”,”false”) false oString.startsWith(“hell”,oo) false oString.startsWith(“hell”,oBool) false oString.startsWith(“hell”,oArray) false oString.startsWith(“hell”,oDate) true oString.startsWith(“hell”,Number.NaN) false oString.startsWith(“hell”,Number.MAX_VALUE) true oString.startsWith(“hell”,Number.MIN_VALUE) false oString.startsWith(“hell”,Number.NEGATIVE_INFINITY) false oString.startsWith(“hell”,Number.POSITIVE_INFINITY) true 5) endsWith(searchString [, position]) 使用方法 结果 oString.endsWith(“world”) true oString.endsWith(“worl”) false oString.endsWith(“worl”,oString.length-1) true 第一个参数错误示例 进行匹配的时候，只要原始值是定义好的，加没加双引号都可以被正常检测出来。 布尔值字符串可以判断是否包含布尔值对象。 自己判断是否完全包含自己是可以正常检测的。 传入空字符串的时候，endsWith方法会直接返回true。 对于特殊的字面量，true，false，null，undefined和NaN，endsWith方法会当作普通字符串进行完全匹配 使用方法 结果 “true”.endsWith(true) true “true”.endsWith(“true”) true “true”.endsWith(oBool) true “false”.endsWith(false) true “false”.endsWith(“false”) true “false”.endsWith(oBool) false “null”.endsWith(null) true “null”.endsWith(“null”) true “undefined”.endsWith(undefined) true “undefined”.endsWith(“undefined”) true “NaN”.endsWith(NaN) true “NaN”.endsWith(“NaN”) true oString.endsWith(“”) true oString.endsWith(oString) true oString.endsWith(true) false oString.endsWith(false) false oString.endsWith(null) false oString.endsWith(undefined) false oString.endsWith(NaN) false 第二个参数错误示例 索引值的范围是1~varName.length。 传入的数字是向下取整的，只取数字的整数部分，举个栗子，比如传入10.1-10.9，endsWith方法是当作10进行处理。 对于传入的负值整数，endsWith方法是当作1进行处理，endsWith方法是当作1进行处理，相当于就是从字符串的索引值为1的到索引值为1中间的字符串，检索结尾是不是对应的传入的字符串。 对于传入的String，Object，Array和Boolean类型的值，endsWith方法是当作1进行处理，相当于就是从字符串的索引值为1的到索引值为1中间的字符串，检索结尾是不是对应的传入的字符串。 对于传入的Date类型的值，endsWith方法会自动转成对应的时间戳数值，相当于就是从字符串的索引值为varName.length的到索引值为1中间的字符串，检索结尾是不是对应的传入的字符串。 对于Number.NaN，Number.MIN_VALUE和Number.NEGATIVE_INFINITY，endsWith方法是当作1进行处理，相当于就是从字符串的索引值为1的到索引值为1中间的字符串检索内容。 对于Number.MAX_VALUE和Number.POSITIVE_INFINITY，endsWith方法是当作超出varName.length进行处理，相当于就是从字符串的索引值为varName.length的到索引值为1中间的字符串，检索结尾是不是对应的传入的字符串。 使用方法 结果 oString.endsWith(“world”,10.1) false oString.endsWith(“world”,10.5) false oString.endsWith(“world”,10.8) false oString.endsWith(“world”,11) true oString.endsWith(“world”,11.1) true oString.endsWith(“world”,11.5) true oString.endsWith(“world”,11.8) true oString.endsWith(“world”,-10) false oString.endsWith(“world”,-11) false oString.endsWith(“world”,true) false oString.endsWith(“world”,false) false oString.endsWith(“world”,”true”) false oString.endsWith(“world”,”false”) false oString.endsWith(“world”,oo) false oString.endsWith(“world”,oBool) false oString.endsWith(“world”,oArray) false oString.endsWith(“world”,oDate) true oString.endsWith(“world”,Number.NaN) false oString.endsWith(“world”,Number.MAX_VALUE) true oString.endsWith(“world”,Number.MIN_VALUE) false oString.endsWith(“world”,Number.NEGATIVE_INFINITY) false oString.endsWith(“world”,Number.POSITIVE_INFINITY) true 6) search(regexp)当你想要知道字符串中是否存在某个模式pattern时可使用 search，类似于正则表达式的 test 方法。当要了解更多匹配信息时，可使用 match会更慢，该方法类似于正则表达式的 exec 方法。 regexp该参数可以是需要在varName中检索的子串，也可以是需要检索的RegExp对象。 要执行忽略大小写的检索，请追加标志i。 返回值varName中第一个与regexp相匹配的子串的起始位置。 如果没有找到任何匹配的子串，则返回-1。 search() 方法不执行全局匹配，它将忽略标志g。 regexp 一个正则表达式（regular expression）对象。如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。 对于字符串中包含的BMP字符，会严格匹配编码格式。 使用方法 结果 tString_2.search(“ “)//两个空格 -1 tString_2.search(/\\s/) 5 tString_2.search(“line”) 6 tString_2.search(“ “)//四个空格 -1 tString_2.search(“ “)//五个空格 -1 tString_2.search(“ “)//一个tab缩进 13 tString_2.search(“ “)//两个tab缩进 13 tString_2.search(/\\t/)//一个tab缩进 13 tString_2.search(/\\n/)//一个tab缩进 12 tString_2.search(/\\n/)//一个tab缩进 12 oString_1.search(“\\uD87E\\uDC04”)) 2 oString_1.search(“你”)) -1 oString_1.normalize().search(“你”)) 2 错误示例 进行匹配的时候，只要原始值是定义好的，没加双引号都可以被正常检测出来 所有字符串检测是否包含空字符串，都会返回0 所有字符串检测是否包含自己，都会返回0 对于特殊的字面量，true，false，null和NaN，search方法会当作普通字符串 所有字符串检测是否包含undefined，都会返回0 而且本方法不管你传入多少参数，这边只会处理传入的第一个参数值 对于object这个对象，search方法会转化成[object Object] 对于其他除了object之外引用类型对象，search方法会按照对象的字面量进行检索 使用方法 结果 “true”.search(true) 0 “true”.search(“true”) 0 “true”.search(oBool) 0 “false”.search(false) 0 “false”.search(“false”) 0 “false”.search(oBool) -1 “null”.search(null) 0 “null”.search(“null”) 0 “undefined”.search(undefined) 0 “undefined”.search(“undefined”) 0 “NaN”.search(NaN) 0 “NaN”.search(“NaN”) 0 oString.search(“”) 0 oString.search(oString) 0 oString.search(true) -1 oString.search(false) -1 oString.search(null) -1 oString.search(undefined) 0 oString.search(NaN) -1 oString.search(“llo”,10.1) 2 oString.search(“llo”,10.1,10.5,10.8) 2 strString.search(oo) 1 oString.search(oo) 1 tString_1.search(oo) 1 tString_2.search(oo) 1 tString_3.search(oo) 3 tString_4.search(oo) -1 oString.search(oBool) -1 oString.search(oArray) -1 oString.search(oDate) -1 oString.search(Number.NaN) -1 oString.search(Number.MAX_VALUE) -1 oString.search(Number.MIN_VALUE) -1 oString.search(Number.NEGATIVE_INFINITY) -1 oString.search(Number.POSITIVE_INFINITY) -1 7) match(regexp) regexp该参数可以是需要在varName中检索的子串，也可以是需要检索的RegExp对象。 regexp 一个正则表达式（regular expression）对象。如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。 要执行忽略大小写的检索，请追加标志i。 如果match()方法没有找到匹配，将返回 null。如果找到匹配，则match()方法返回一个数组，并将更新全局 RegExp 对象的属性以反映匹配结果。 如果传入空格，制表符和垂直制表符等等，match() 方法的第一个参数会返回经过正则对象转化之后的值。举个栗子，如果传入” “（一个tab缩进），match()方法返回的数组第一个值是\\t。 如果字符串中本身包含空格，制表符和垂直制表符等等，match() 方法的第三个参数的值中会将这些符号转成对应正则值。举个栗子，tString_2中包含换行和制表符，match()方法返回的数组第三个值是hello line 1\\n\\t\\t\\t\\thello line 2。 如果没有设置全局标志 (g)，数组元素0包含整个匹配，而元素1到n包含任何一个子匹配。此行为与未设置全局标志时exec方法（正则表达式）(JavaScript) 的行为相同。 如果未设置全局标志，则 match() 方法返回的数组有两个特性：input 和 index。 input属性包含整个被搜索的字符串。 index 属性包含了在整个被搜索字符串中匹配的子字符串的位置。 如果设置了全局标志，则元素0到元素n包含所有出现的匹配，可以用来统计某个内容在字符串中出现的次数。 对于字符串中包含的BMP字符，会严格匹配编码格式。 使用方法 结果 tString_2.match(“ “)//两个空格 null tString_2.match(/\\s/) [ ‘ ‘, index: 5, input: ‘hello line 1\\n\\t\\t\\t\\thello line 2’ ] tString_2.match(“line”) [ ‘line’, index: 6, input: ‘hello line 1\\n\\t\\t\\t\\thello line 2’ ] tString_2.match(“ “)//四个空格 null tString_2.match(“ “)//五个空格 null tString_2.match(“ “)//一个tab缩进 [ ‘\\t’, index: 13, input: ‘hello line 1\\n\\t\\t\\t\\thello line 2’ ] tString_2.match(“ “)//两个tab缩进 [ ‘\\t\\t’,index: 13,input: ‘hello line 1\\n\\t\\t\\t\\thello line 2’ ] tString_2.match(/\\t/)//一个tab缩进 [ ‘\\t’, index: 13, input: ‘hello line 1\\n\\t\\t\\t\\thello line 2’ ] tString_2.match(/\\n/)//一个tab缩进 [ ‘\\n’, index: 12, input: ‘hello line 1\\n\\t\\t\\t\\thello line 2’ ] oString.match() [ ‘’, index: 0, input: ‘hello world’ ] oString.match(/o/) [ ‘o’, index: 4, input: ‘hello world’ ] oString.match(/o/g) [ ‘o’, ‘o’ ] oString_1.match(“\\uD87E\\uDC04”)) [ ‘你’, index: 2, input: ‘A 你 Z’ ] oString_1.match(“你”)) null oString_1.normalize().match(“你”)) [ ‘你’, index: 2, input: ‘A 你 Z’ ] 错误示例 进行匹配的时候，只要原始值是定义好的，没加双引号都可以被正常检测出来。 所有字符串检测是否包含空字符串，会当作匹配所有，返回的数组中的第一个值都是&#39;&#39;，第二个值都是index:0。 所有字符串检测是否包含自己，都会正常返回。 对于特殊的字面量，true，false，null和NaN，match方法会当作普通字符串。 除了字符串本身值包含undefined这个值，其他字符串使用match方法检测是否包含undefined，返回的数组中的第一个值都是&#39;&#39;，第二个值都是index:0。 对于本身包含undefined这个值的字符串，返回的数组中第一个值是&#39;undefined&#39;。 而且本方法不管你传入多少参数，这边只会处理传入的第一个参数值。 对于object这个对象，match方法会转化成[object Object]，再进行匹配处理。 对于其他除了object之外引用类型对象，match方法会按照对象的字面量进行检索。 使用方法 结果 “true”.match(true) [ ‘true’, index: 0, input: ‘true’ ] “true”.match(“true”) [ ‘true’, index: 0, input: ‘true’ ] “true”.match(oBool) [ ‘true’, index: 0, input: ‘true’ ] “false”.match(false) [ ‘false’, index: 0, input: ‘false’ ] “false”.match(“false”) [ ‘false’, index: 0, input: ‘false’ ] “false”.match(oBool) null “null”.match(null) [ ‘null’, index: 0, input: ‘null’ ] “null”.match(“null”) [ ‘null’, index: 0, input: ‘null’ ] “undefined”.match(undefined) [ ‘undefined’, index: 0, input: ‘undefined’ ] “undefined”.match(“undefined”) [ ‘undefined’, index: 0, input: ‘undefined’ ] “NaN”.match(NaN) [ ‘NaN’, index: 0, input: ‘NaN’ ] “NaN”.match(“NaN”) [ ‘NaN’, index: 0, input: ‘NaN’ ] oString.match(“”) [ ‘’, index: 0, input: ‘hello world’ ] oString.match(oString) [ ‘hello world’, index: 0, input: ‘hello world’ ] oString.match(true) null oString.match(false) null oString.match(null) null oString.match(undefined) [ ‘’, index: 0, input: ‘hello world’ ] oString.match(NaN) null oString.match(“llo”,10.1) [ ‘llo’, index: 2, input: ‘hello watermelon’ ] oString.match(“llo”,10.1,10.5,10.8) [ ‘llo’, index: 2, input: ‘hello watermelon’ ] strString.match(oo) [ ‘e’, index: 1, input: ‘hello watermelon’ ] oString.match(oo) [ ‘e’, index: 1, input: ‘hello world’ ] tString_1.match(oo) [ ‘e’, index: 1, input: ‘hello Template’ ] tString_2.match(oo) [ ‘e’, index: 1, input: ‘hello line 1\\n\\t\\t\\t\\thello line 2’ ] tString_3.match(oo) [ ‘t’, index: 3, input: ‘Fifteen is 12 and\\nnot 16.’ ] tString_4.match(oo) null oString.match(oBool) null oString.match(oArray) null oString.match(oDate) null oString.match(Number.NaN) null oString.match(Number.MAX_VALUE) null oString.match(Number.MIN_VALUE) null oString.match(Number.NEGATIVE_INFINITY) null oString.match(Number.POSITIVE_INFINITY) null 4.4. 比较4.4.1 概述 方法名 描述 参数 localeCompare(stringExp[, locales][, options]) 返回一个数字，表示是否引用字符串在排序中位于比较字符串的前面，后面，或者二者相同。新的 locales 、 options 参数能让应用程序定制函数的行为即指定用来排序的语言。 locales 和 options 参数是依赖于具体实现的，在旧的实现中这两个参数是完全被忽略的。 @param stringExp 必需。用于比较的字符串。@param locales 可选。包含一种或多种语言或区域设置标记的区域设置字符串数组。如果包含多个区域设置字符串，请以降序优先级对它们进行排列，确保首个条目为首选区域位置。如果省略此参数，则使用 JavaScript 运行时的默认区域设置。此参数必须符合 BCP 47 标准；请参见 Intl.Collator 对象了解详细信息。@param options 可选。包含指定比较选项的一个或多个特性的对象。请参见 Intl.Collator 对象了解详细信息。 4.4.2 详细1) localeCompare(stringExp[, locales][, options]) 除了Safari之外，Internet Explorer 11（只有ie11这个版本） ，Chrome，Firefox (Gecko)和Opera都支持localeCompare 在内部使用 Intl.Collator 对象进行比较，添加对 locales 和 options 参数的支持。 所有浏览器都支持localeCompare的基础功能。 返回一个数字表示是否 引用字符串 在排序中位于 比较字符串 的前面，后面，或者二者相同。 当 引用字符串 在 比较字符串 前面时返回 -1。 当 引用字符串 在 比较字符串 后面时返回 1。 相同位置时返回 0。 切勿依赖于 -1 或 1 这样特定的返回值。不同浏览器之间（以及不同浏览器版本之间） 返回的正负数的值各有不同，因为W3C规范中只要求返回值是正值和负值，而没有规定具体的值。一些浏览器可能返回-2或2或其他一些负的、正的值。 把 &lt; 和 &gt; 运算符应用到字符串时，它们只用字符的 Unicode 编码比较字符串，而不考虑当地的排序规则。 以这种方法生成的顺序不一定是正确的。 ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用底层操作系统提供的排序规则。 可以用于有多个字符串的数组进行排序 使用方法 结果 strString.localeCompare(“llo”) -1 oString_1.localeCompare(“A”) 1 tString_1.localeCompare(“Tem”) -1 strString.localeCompare(“llo”) -1 oString_3.localeCompare(“Fifteen”) 1 tString_1.localeCompare(“Tem”) -1 第一个参数错误示例 如果不传入任何参数，localeCompare会直接返回负值。 就目前测试的相关数据结果表现，不管字符串中是什么内容，传入什么样的正则值，或者传入制表符，空格，和换行符等等特殊字符，localeCompare都会返回正值。 如果以字符串本身传入localeCompare，会直接返回0。 进行匹配的时候，只要原始值是定义好的，没加双引号都可以被正常检测出来。 使用方法 结果 strString.localeCompare() -1 oString.localeCompare(/\\s/) 1 oString_1.localeCompare(/\\s/) 1 tString_1.localeCompare(/\\s/) 1 tString_2.localeCompare(/\\s/) 1 tString_3.localeCompare(/\\s/) 1 tString_4.localeCompare(/\\s/) 1 strString.localeCompare(/\\n/) 1 strString.localeCompare(/\\t/) 1 strString.localeCompare(/hello world/) 1 strString.localeCompare(/大吉大利/) 1 tString_2.localeCompare(“ “) 1 tString_2.localeCompare(“ “) 1 tString_2.localeCompare(“ “) 1 tString_2.localeCompare(“ “) 1 tString_2.localeCompare(“ “) 1 strString.localeCompare(strString) 0 “true”.localeCompare(true) 0 “true”.localeCompare(“true”) 0 “true”.localeCompare(oBool) 0 “false”.localeCompare(false) 0 “false”.localeCompare(“false”) 0 “false”.localeCompare(oBool) -1 “null”.localeCompare(null) 0 “null”.localeCompare(“null”) 0 “undefined”.localeCompare(undefined) 0 “undefined”.localeCompare(“undefined”) 0 “NaN”.localeCompare(NaN) 0 “NaN”.localeCompare(“NaN”) 0 2) Intl.Collator([locales[, options]])是用于语言敏感字符串比较的collators构造函数。 locales 可选.locales 参数必须是一个 BCP 47 语言标记的字符串，或者是一个包括多个语言标记的数组。如果 locales 参数未提供或者是 undefined，便会使用运行时默认的 locale。 一个 BCP 47 语言标记代表了一种语言或者区域（两者没有很大的区别）。在其最常见的格式中，它以这样的顺序囊括了这些内容：语言代码，脚本代码，和国家代码，全部由连字符分隔开。 “hi”：印地语 “de-AT”：在奥地利使用的德语 “zh-Hans-CN”：在中国使用的中文简体 在 BCP 47 中表示语言，脚本，国家（区域）和变体（少用）的语言子标记含义可以在 IANA语言 子标记注册中找到。 BCP 47 也支持扩展，其中一个和 JavaScript 国际化方法相关的是：u（Unicode）扩展。它可以用于请求一个自定义区域特定行为的 Collator，NumberFormat，或者 DateTimeFormat 对象。 “de-DE-u-co-phonebk”：使用德语的电话簿排序变体，这会把元音变音扩展成字符对：ä → ae, ö → oe, ü → ue。 “th-TH-u-nu-thai”：在数字格式中使用泰语的数值表示（๐, ๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙） “ja-JP-u-ca-japanese”：在日期和时间格式化中使用日本的日历表示方式，所以 2013 会表示为平成 25。 语言区域判定 locales 参数，在除去所有的 Unicode 扩展之后，会被转化成来自应用的优先请求。运行时拿它和可用的语言区域做对比然后选择出最合适的一个。有两种匹配算法：查找 匹配遵循 BCP 47 中指定的查找算法。 最佳命中匹配器会让运行时至少提供一个语言区域，但合适请求的结果可能会比查找算法的要多。如果应用没有提供一个 locales 参数，或者运行时没有一个匹配请求的语言区域，那么会使用运行时默认的语言区域。 如果选中的语言标记有一个 Unicode 扩展子字符串，这个扩展会用于自定义构造对象或者方法的行为。每一个构造函数或者方法仅支持 Unicode 扩展定义的 key 的一个子集，和依赖于语言标记的支持的值。例如，co 这个 key（collation）只在 Collator 中支持，它的值 phonebk 只在德语中支持。 关于参数 locales 的一般形式和解释请参见Intl page. 下面的这些 Unicode 扩展键也是被允许的: co 某些区域设置的变体归类。 可能的值包括：big5han，dict，direct，ducet，gb2312，phonebk，phonetic，pinyin，reformed，searchjl，stroke ，unihan。值standard 和 search 被忽略。 kn 是否应使用数字对照，使得 1&lt;2&lt;10。 可能的值为 true 和 false。 此选项可以通过 options 属性或通过 Unicode 扩展 key 设置; 如果两者都提供，options 属性优先。 kf 首先排序大写或者小写。可能的值为 upper，lower 或 false（使用区域设置的默认值）。 此选项可以通过 options 属性或通过 Unicode 扩展 key 设置; 如果两者都提供，options 属性优先。 options options 参数必须是一个对象，其属性值在不同的构造函数和方法中会有所变化。如果 options 参数未提供或者为 undefined，所有的属性值则使用默认的。 所有语言敏感的构造函数和方法都支持的一个属性是：localeMatcher 属性，它的值必须是字符串 lookup 或者 best fit，用于选择上边描述的语言区域匹配算法。包含一些或所有的下面属性的对象: localeMatcher 使用的 local 的匹配算法. 可能的值有lookup 和 best fit，默认值是 best fit. 有关此选项的信息。 usage 比较是用于排序还是用于搜索匹配的字符串。 可能的值为 sort 和 search; 默认为 sort。 sensitivity 字符串中的哪些差异应导致结果值为非零(non-zero)。 可能的值有： base: 只有字母不同的字母比较不相等。例子: a ≠ b, a = á, a = A。accent: 只有不同的基本字母或重音符号和其他变音符号的字符串比较为不相等。 例如: a ≠ b, a ≠ á, a = A。case: 只有不同的基本字母或大小写的字符串比较不相等。 Examples: a ≠ b, a = á, a ≠ A。variant: 字符串的字母，口音和其他变音符号、或不同大小写比较不相等。 也可以考虑其他差异。例如： a ≠ b, a ≠ á, a ≠ A.默认值使用 sort; 它的 locale 依赖于使用 search. ignorePunctuation 是否应忽略标点。 可能的值为 true 和 false; 默认值为 false。 numeric 是否应使用数字对照，使得 1&lt;2&lt;10。 可能的值为 true 和 false。默认值为 false 。 此选项可以通过 options 属性或通过 Unicode 扩展 key 设置。如果两者都提供，options 属性优先。 caseFirst 首先排序大写或者小写。可能的值为 upper，lower 或 false（使用区域设置的默认值）。 此选项可以通过 options 属性或通过 Unicode 扩展 key 设置。 如果两者都提供，options 属性优先。 基础用法 使用方法 结果 new Intl.Collator().compare(‘a’, ‘c’) -1 new Intl.Collator().compare(‘c’, ‘a’) 1 new Intl.Collator().compare(‘a’, ‘a’) 0 numeric参数用法 使用方法 结果 “1”.localeCompare(“2”) -1 “1”.localeCompare(“2”,”kn”,{numeric:”true”}) -1 “1”.localeCompare(“2”,”language-region-u-kn-true”,{numeric:”true”}) -1 “1”.localeCompare(“16”) -1 “1”.localeCompare(“16”,”kn”,{numeric:”true”}) -1 “1”.localeCompare(“16”,”language-region-u-kn-true”,{numeric:”true”}) -1 “2”.localeCompare(“16”) 1 “2”.localeCompare(“16”,”kn”,{numeric:”true”}) -1 “2”.localeCompare(“16”,”language-region-u-kn-true”,{numeric:”true”}) -1 sensitivity参数用法 使用方法 结果 “a”.localeCompare(“b”) -1 “a”.localeCompare(“b”,”language-region-u-search”,{sensitivity:”base”}) -1 “a”.localeCompare(“b”,”language-region-u-search”,{sensitivity:”accent”}) -1 “a”.localeCompare(“b”,”language-region-u-search”,{sensitivity:”case”}) -1 “a”.localeCompare(“b”,”language-region-u-search”,{sensitivity:”variant”}) -1 “a”.localeCompare(“á”) -1 “a”.localeCompare(“á”,”language-region-u-search”,{sensitivity:”base”}) 0 “a”.localeCompare(“á”,”language-region-u-search”,{sensitivity:”accent”}) -1 “a”.localeCompare(“á”,”language-region-u-search”,{sensitivity:”case”}) 0 “a”.localeCompare(“á”,”language-region-u-search”,{sensitivity:”variant”}) -1 “a”.localeCompare(“A”) -1 “a”.localeCompare(“A”,”language-region-u-search”,{sensitivity:”base”}) 0 “a”.localeCompare(“A”,”language-region-u-search”,{sensitivity:”accent”}) 0 “a”.localeCompare(“A”,”language-region-u-search”,{sensitivity:”case”}) -1 “a”.localeCompare(“A”,”language-region-u-search”,{sensitivity:”variant”}) -1 caseFirst参数用法 使用方法 结果 “a”.localeCompare(“A”) -1 “a”.localeCompare(“A”,”kf”,{caseFirst:”upper”}) -1 “a”.localeCompare(“A”,”language-region-u-kf-upper”,{caseFirst:”upper”}) 1 “a”.localeCompare(“A”,”language-region-u-kf-lower”,{caseFirst:”upper”}) 1 “a”.localeCompare(“A”,”language-region-u-kf-false”,{caseFirst:”upper”}) 1 “a”.localeCompare(“A”,”kf”,{caseFirst:”lower”}) -1 “a”.localeCompare(“A”,”language-region-u-kf-upper”,{caseFirst:”lower”}) -1 “a”.localeCompare(“A”,”language-region-u-kf-lower”,{caseFirst:”lower”}) -1 “a”.localeCompare(“A”,”language-region-u-kf-false”,{caseFirst:”lower”}) -1 “a”.localeCompare(“A”,”kf”,{caseFirst:”false”}) -1 “a”.localeCompare(“A”,”language-region-u-kf-upper”,{caseFirst:”false”}) -1 “a”.localeCompare(“A”,”language-region-u-kf-lower”,{caseFirst:”false”}) -1 “a”.localeCompare(“A”,”language-region-u-kf-false”,{caseFirst:”false”}) -1 4.5. 拼接4.5.1 概述 方法名 描述 参数 concat(string2, string3[, …, stringN]) 连接两个字符串文本，并返回一个新的字符串。 @param string2…stringN 和原字符串连接的多个字符串 padEnd(targetLength [, padString]) 不推荐使用， 从给定字符串的末端填充当前字符串，以从给定长度创建新字符串。 @param targetLength 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 @param padString (可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 “ “（U+0020）。返回值，在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。 padStart() 不推荐使用， 从一个给定字符串开始填充当前字符串，从给定长度创建一个新字符串。 无 repeat() 不推荐使用，返回指定重复次数的由元素组成的字符串对象。 无 quote() 已废弃，用双引号（``）包装字符串。 无 4.5.2 详细1) concat(string2, string3[, …, stringN])concat 方法的结果等同于：result = string1 + string2 + string3 + stringN，即将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。concat 方法并不影响原字符串，原字符串中或结果字符串中的值的变化都不会影响另一个字符串中的值。如果有不是字符串的参数，则它们在连接到 varName 之前将首先被转换为字符串。 性能 强烈建议使用 赋值操作符（+, +=）代替 concat 方法，+运算速度是concat的二十倍左右，是join的两百七十倍左右。参看 性能测试（perfomance test），下图是三个函数在0.1秒左右的执行次数，其中join执行时长是最长的，接近0.2秒。 正确用法 使用方法 结果 oString.concat() hello world oString.concat(“”) hello world oString.concat(“hell”,1)) hello worldhell1 oString.concat(“hell”,0.1)) hello worldhell0.1 oString.concat(“hell”,0.5)) hello worldhell0.5 oString.concat(“hell”,0.8)) hello worldhell0.8 错误用法和特殊字符 不传参数和传空字符串都是会正常返回字符串原值。 对于特殊字符都可以正常拼接，如果传入的不是字符串类型，会先转成字符串类型，然后再做处理。 对于数字0，会去掉小数位和正负号 使用方法 结果 oString.concat() hello world oString.concat(“”) hello world oString.concat(true) hello worldtrue oString.concat(“true”) hello worldtrue oString.concat(oBool) hello worldtrue oString.concat(false) hello worldfalse oString.concat(“false”) hello worldfalse oString.concat(null) hello worldnull oString.concat(“null”) hello worldnull oString.concat(undefined) hello worldundefined oString.concat(“undefined”) hello worldundefined oString.concat(NaN) hello worldNaN oString.concat(“NaN”) hello worldNaN oString.concat(Number.NaN) hello worldNaN oString.concat(oo) hello worldhell[object Object] oString.concat(oArray) hello worldhelldemo,melon,water oString.concat(oDate) hello worldhellThu Jan 11 2018 21:39:49 GMT+0800 (中国标准时间) oString.concat(Number.MAX_VALUE) hello worldhell1.7976931348623157e+308 oString.concat(Number.MIN_VALUE) hello worldhell5e-324 oString.concat(Number.NEGATIVE_INFINITY) hello worldhell-Infinity oString.concat(Number.POSITIVE_INFINITY) hello worldhellInfinity oString.concat(“hell”,0.0)) hello worldhell0 oString.concat(“hell”,-0)) hello worldhell0 2) padEnd() 使用方法 结果 varName.padEnd() 3) padStart() 使用方法 结果 varName.padStart() 4) repeat() 使用方法 结果 varName.repeat() 5) quote() 使用方法 结果 varName.quote() 4.6. 大小写转换4.6.1 概述 方法名 描述 参数 toLowerCase() 将字符串转换成小写并返回。 无 toLocaleLowerCase() 根据当前区域设置，将符串中的字符转换成小写。对于大多数语言来说，toLowerCase的返回值是一致的。 无 toUpperCase() 将字符串转换成大写并返回。 无 toLocaleUpperCase() 根据当前区域设置，将字符串中的字符转换成大写，对于大多数语言来说，toUpperCase的返回值是一致的。 无 4.6.2 详细1) toLowerCase() 使用方法 结果 varName.toLowerCase() 2) toLocaleLowerCase() 使用方法 结果 varName.toLocaleLowerCase() 3) toUpperCase() 使用方法 结果 varName.toUpperCase() 4) toLocaleUpperCase() 使用方法 结果 varName.toLocaleUpperCase() 5. 字符串对象的强硬方法5.1. 强制类型转化 方法名 描述 使用方法 String 强制类型转化，将其他类型的变量转化成String类型 String(varName) 参数值 举例 转换结果 负数 -1 -1 空 null null 未定义 undefined undefined 非数值 NaN NaN 对象 new Object() [object Object] 12345678910111213141516171819202122//在大部分情况下String()和toString()效果相同//但是 对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误// 而null 和 undefined 值强制使用toString()，却会引发错误console.log(String(-0))//0console.log(String(-1))//-1console.log(String(null))//nullconsole.log(String(undefined))//undefinedconsole.log(String(NaN))//NaN//将其他对象类型化成string类型的时候，其实传入String的值是每个对象原始的默认值//object对象的默认值是object//Boolean对象的默认值是false//Number对象的默认值是0//String对象的默认值是''//Array对象的默认值是[]//日期的默认值是当前日期console.log(String(new Object()))//[object Object]console.log(String(new Boolean()))//falseconsole.log(String(new Number()))//0console.log(String(new String()))//\"\"console.log(String(new Array()))//\"\"console.log(String(new Date()))//Sat Nov 18 2017 15:45:07 GMT+0800 (CST) 5.2. 替换5.2.1 概述 方法名 描述 参数 replace() 被用来在正则表达式和字符串直接比较，然后用新的子串来替换被匹配的子串。 无 5.2.2 详细1) replace() 使用方法 结果 varName.replace() 5.3. 分割5.3.1 概述 方法名 描述 参数 slice() 摘取一个字符串区域，返回一个新的字符串。 无 split() 通过分离字符串成字串，将字符串对象分割成字符串数组。 无 substr() 通过指定字符数返回在指定位置开始的字符串中的字符。 无 substring() 返回在字符串中指定两个下标之间的字符。 无 5.3.2 详细1) slice() 使用方法 结果 varName.slice() 2) split() 使用方法 结果 varName.split() 3) substr() 使用方法 结果 varName.substr() 4) substring() 使用方法 结果 varName.substring() 5.4. 格式转化5.4.1 概述 方法名 描述 参数 trim() 不推荐使用，从字符串的开始和结尾去除空格。参照部分 ECMAScript 5 标准。 无 trimLeft() 不推荐使用， 从字符串的左侧去除空格。 无 trimRight() 不推荐使用， 从字符串的右侧去除空格。 无 5.4.2 详细1) trim() 使用方法 结果 varName.trim() 2) trimLeft() 使用方法 结果 varName.trimLeft() 3) trimRight() 使用方法 结果 varName.trimRight() 5.5. 对象通用方法5.5.1 概述 方法名 描述 参数 toString() 不推荐使用，返回用字符串表示的特定对象。重写 Object.prototype.toString 方法。 无 toLocaleString() 不推荐使用，返回用字符串表示的特定对象。 无 valueOf() 不推荐使用， 返回特定对象的原始值。重写 Object.prototype.valueOf 方法。 无 toSource() 测试中，返回一个对象文字代表着特定的对象。你可以使用这个返回值来创建新的对象。重写 Object.prototype.toSource 方法。 无 [@@iterator]() 不推荐使用，返回一个新的迭代器对象遍历一个字符串值的代码，每个代码点返回一个字符串值。 无 __defineGetter__() 不推荐使用 无 __defineSetter__() 不推荐使用 无 __lookupGetter__() 不推荐使用 无 __lookupSetter__() 不推荐使用 无 hasOwnProperty() 不推荐使用 无 isPrototypeOf() 不推荐使用 无 setPrototypeOf() 不推荐使用 无 unwatch() 不推荐使用 无 watch() 不推荐使用 无 propertyIsEnumerable() 不推荐使用 无 5.5.2 详细1) toString() 使用方法 结果 varName.toString() 2) toLocaleString() 使用方法 结果 varName.toLocaleString() 3) valueOf() 使用方法 结果 varName.valueOf() 4) [@@iterator]() 使用方法 结果 varName[0] 5) toSource() 使用方法 结果 varName.toSource() 6) __defineGetter__() 使用方法 结果 varName.toString() 7) __defineSetter__() 使用方法 结果 varName.valueOf() 8) __lookupGetter__() 使用方法 结果 varName[0] 9) __lookupSetter__() 使用方法 结果 varName.toSource() 10) hasOwnProperty() 使用方法 结果 varName.toString() 11) isPrototypeOf() 使用方法 结果 varName.valueOf() 12) setPrototypeOf() 使用方法 结果 varName[0] 13) unwatch() 使用方法 结果 varName.toSource() 14) watch() 使用方法 结果 varName[0] 15) propertyIsEnumerable() 使用方法 结果 varName.toSource() 6. 字符串字面量的原型方法6.1 概述 方法名 描述 参数 raw() 一个模板字符串的标签函数，它的作用类似于 Python 中的字符串前缀 r 和 C# 中的字符串前缀 @，是用来获取一个模板字符串的原始字面量值的。 @param1 callSite 一个模板字符串的调用点对象。@param2 …substitutions 任意个可选的参数，表示任意个内插表达式对应的值。 6.2 详细1) raw()如果第一个参数没有传入一个格式良好的调用点对象，则会抛出 TypeError 异常。 使用方法 结果 objectName.raw(callSite, …substitutions) 7 总结7.1 返回值为字符串的方法 方法名 描述 参数 big() 不推荐使用，把字符串显示为大号字体，只在页面中才会有大两个字体号效果。 无 small() 不推荐使用， 把字符串显示为小号字体，只在页面中才会有小两个字体号效果。 无 blink() 不推荐使用， 把字符串显示闪动的字符串，目前没有看到有浏览器支持 无 bold() 不推荐使用， 把字符串显示粗体的字符串，只在页面中才会有粗体效果，IE不兼容。 无 italics() 不推荐使用，把字符串显示为斜体，只在页面中才会有效果。 无 strike() 不推荐使用， 把字符串显示为加了删除线的字符串，只在页面中才会有效果。 无 fixed() 不推荐使用， 把字符串显示为打字机文本显示的字符串，只在页面中才会有效果。 无 sub() 不推荐使用，把字符串显示为下标，只在页面中才会有效果。 无 sup() 不推荐使用， 把字符串显示为上标，只在页面中才会有效果。 无 anchor(anchorname) 不推荐使用，创建 HTML 锚。将字符串输出为有唯一标识的纯粹a标签，只在页面中才会有效果。 @param anchorname 必需，为锚定义名称。如果没有传入参数，则会输出一个name属性为undefined的a标签。 link(url) 不推荐使用， 把字符串显示为链接，只在页面中才会有效果。如果没有传入参数，则会输出一个href属性为undefined的a标签。 @param url必需，规定要链接的 URL。 fontcolor(color) 不推荐使用，返回指定的颜色的字符串。只在页面中才会有效果如果没有传入参数，则会输出一个color属性为undefined的font标签。 @param color必需。为字符串规定 font-color。该值必须是颜色名(red)、RGB 值(rgb(255,0,0))或者十六进制数(#FF0000)。 fontsize(size) 不推荐使用， 返回指定的字体大小的字符串。只在页面中才会有效果。如果没有传入参数，则会输出一个size属性为undefined的font标签。 @param size 参数必须是从 1 至 7 的数字，数字越大字体越大。 charAt(index) 返回特定位置的字符，不提供参数就返回第一个字符的字符，提供游标值，就返回指定游标的字符 @param index 非必需，一个介于0 和字符串长度减1之间的正整数。 (0~varName.length-1)。 normalize([form]) 测试中， 返回调用字符串值的Unicode标准化形式。 @param form 四种 Unicode 正规形式 “NFC”, “NFD”, “NFKC”, 以及 “NFKD” 其中的一个, 默认值为 “NFC”. fromCharCode(num1, …, numN) 返回一个字符串，而不是一个 String 对象。由于 fromCharCode 是 String 的静态方法，所以应该像这样使用：String.fromCharCode()，而不是作为你创建的 String 对象的方法。 @param num1, …, numN 一组序列数字，表示 Unicode 值。 fromCodePoint(num1, …, numN) 不推荐使用， 返回使用 Unicode 编码创建的字符串，如果传入无效的 Unicode 编码，将会抛出一个RangeError (例如： “RangeError: NaN is not a valid code point”)。 @param num1, …, numN 一组序列数字，表示 Unicode 值。 concat(string2, string3[, …, stringN]) 连接两个字符串文本，并返回一个新的字符串。 @param string2…stringN 和原字符串连接的多个字符串 padEnd(targetLength [, padString]) 不推荐使用， 从给定字符串的末端填充当前字符串，以从给定长度创建新字符串。 @param targetLength 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 @param padString (可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 “ “（U+0020）。返回值，在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。 7.2 返回值为数值的方法 方法名 描述 参数 charCodeAt(index) 返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。 @param index 一个大于等于 0，小于字符串长度的整数。(0~varName.length-1)，如果不是一个数值，则默认为 0。 codePointAt(pos) 不推荐使用， 返回使用UTF-16编码的给定位置的值的非负整数。 @param pos 这个字符串中需要转码的元素的位置。 indexOf(searchValue[, fromIndex]) 从字符串对象中返回首个被发现的给定值的索引值开始在 fromIndex进行搜索。如果未找到该值，则返回-1。 @param searchValue 一个字符串表示被查找的值。@param fromIndex 可选 表示调用该方法的字符串中开始查找的位置。可以是任意整数。默认值为 0。如果 fromIndex &lt; 0 则查找整个字符串（如同传进了 0）。如果 fromIndex &gt;= varName.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 varName.length。 lastIndexOf(searchValue[, fromIndex]) 返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。 @param searchValue 一个字符串，表示被查找的值。@param fromIndex 从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。 search(regexp) 对正则表达式和指定字符串进行匹配搜索，返回第一个出现的匹配项的下标。如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。 @param regexp 一个正则表达式（regular expression）对象。如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。 localeCompare(stringExp[, locales][, options]) 返回一个数字，表示是否引用字符串在排序中位于比较字符串的前面，后面，或者二者相同。新的 locales 、 options 参数能让应用程序定制函数的行为即指定用来排序的语言。 locales 和 options 参数是依赖于具体实现的，在旧的实现中这两个参数是完全被忽略的。 @param stringExp 必需。用于比较的字符串。@param locales 可选。包含一种或多种语言或区域设置标记的区域设置字符串数组。如果包含多个区域设置字符串，请以降序优先级对它们进行排列，确保首个条目为首选区域位置。如果省略此参数，则使用 JavaScript 运行时的默认区域设置。此参数必须符合 BCP 47 标准；@param options 可选。包含指定比较选项的一个或多个特性的对象。请参见 [Intl.Collator]https://msdn.microsoft.com/zh-cn/library/dn342821(v=vs.94).aspx 对象了解详细信息。 7.3 返回值为布尔值的方法 方法名 描述 参数 includes(searchString[, position]) 不推荐使用，判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。 @param searchString 要在此字符串中搜索的字符串。@param position 可选。从当前字符串的哪个索引位置开始搜寻子字符串；默认值为0。 startsWith(searchString [, position]) 不推荐使用，判断字符串的起始位置是否匹配其他字符串中的字符。 @param searchString 要搜索的子字符串。@param position 在 varName 中搜索 searchString 的开始位置，默认值为 0，也就是真正的字符串开头处。 endsWith(searchString [, position]) 不推荐使用， 判断一个字符串的结尾是否包含其他字符串中的字符。 @param searchString 要搜索的子字符串。@param position 在 varName 中搜索 searchString 的结束位置，默认值为 varName.length，也就是真正的字符串结尾处。 7.3 返回值为数组的方法 方法名 描述 参数 match(regexp) 将字符串与正则表达式匹配，并返回一个包含该搜索结果的数组。返回值array，一个包含了整个匹配结果以及任何括号捕获的匹配结果的 Array ；如果没有匹配项，则返回 null 。 @param regexp 一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你未提供任何参数，直接使用 match() ，那么你会得到一个包含空字符串的 Array ：[“”] 。 8 参考网站 MDN-String MDN-模板字符串 MDN-String-prototype Unicode字符平面映射 ASCII码查询 [微软官方技术学习文档-String]https://msdn.microsoft.com/zh-cn/library/ecczf11c(v=vs.94).aspx","tags":[{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"},{"name":"string","slug":"string","permalink":"https://mowatermelon.github.io/tags/string/"}]},{"title":"西瓜有话说之Js对象学习regexp对象篇","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/js-Thinking-object-regexp/","text":"1 修饰词 i 忽略大小写 g 全局匹配 m 把\\n识别为多行 2 元字符 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符”n”。”\\n”匹配一个换行符。串行”\\“匹配”\\”而”(“则匹配”(“ [abc] 中括号的任意一个字符，有点像更大范围的逻辑或。 [^abc] 除了中括号中的任意一个字符 (abc) 必须完全包含abc，这三个字符，有点像更大范围的逻辑与。 | 逻辑或，x|y 匹配x或y。例如，“z|food”能匹配”z”或”food”。”(z|f)ood”则匹配”zood”或”food”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括”\\n”在内的任何字符，请使用像”(.|\\n)”的模式。 \\w 任意一个字母、数字或下划线 \\W 任意一个非字母、数字和下划线 \\d 任意一个数字 \\D 任意一个非数字 \\s 任意一个空格 \\S 任意一个非空格 \\b 单词边界 \\B 非单词边界 \\n 代表换行符 \\t tab缩进 12345678910//举个栗子//linux或php单词//可实现向后引用$1(replace替换时)var str1 =\"linux\";var str2 =\"dddd（sdfsdfs）dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;）\";var pattern1 = /(linux)|(php)/;console.log(str1.match(pattern1));//[\"linux\", \"linux\", undefined, index: 0, input: \"linux\"]console.log(str2.match(pattern1));//null 3 量词 + 1个或多个 * 任意多个 ? 1个或0个 {3} 3个 {3,5} 3个到5个 {3,} 3个以上 ^ 行首，匹配输入字符串的开始位置，如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或”\\r”之后的位置。 $ 行尾，匹配输入字符串的结束位置，如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或”\\r”之前的位置。 ?=a 后面紧挨a的 ?!a 后面不紧挨a的 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//举个栗子//linux或php单词//可实现向后引用$1(replace替换时)var str3 =\"Windows2000\";var str4 = \"Windows3.1\";var str5 =\"2000Windows\";var str6 = \"3.1Windows\";//以下都是 获取匹配 的 案例，也就是说，该匹配需要获取供以后使用-------------案例一var pattern1 = /Windows(95|98|NT|2000)/;console.log(str3.match(pattern1));//[\"Windows2000\", \"2000\", index: 0, input: \"Windows2000\"]console.log(str4.match(pattern1));//nullconsole.log(str5.match(pattern1));//nullconsole.log(str6.match(pattern1));//null//以下都是 非获取匹配 的 案例，也就是说，该匹配不需要获取供以后使用-------------案例二var pattern2 = /Windows(?=95|98|NT|2000)/;console.log(str3.match(pattern2));//[\"Windows\", index: 0, input: \"Windows2000\"]console.log(str4.match(pattern2));//nullconsole.log(str5.match(pattern2));//nullconsole.log(str6.match(pattern2));//nullvar pattern3 = /Windows(?!95|98|NT|2000)/;console.log(str3.match(pattern3));//nullconsole.log(str4.match(pattern3));//[\"Windows\", index: 0, input: \"Windows3.1\"]console.log(str5.match(pattern3));//[\"Windows\", index: 4, input: \"2000Windows\"]console.log(str6.match(pattern3));//[\"Windows\", index: 3, input: \"3.1Windows\"]var pattern4 = /Windows(?&lt;=95|98|NT|2000)/;console.log(str3.match(pattern4));//nullconsole.log(str4.match(pattern4));//nullconsole.log(str5.match(pattern4));//nullconsole.log(str6.match(pattern4));//nullvar pattern5 = /Windows(?&lt;!95|98|NT|2000)/;console.log(str3.match(pattern5));//[\"Windows\", index: 0, input: \"Windows2000\"]console.log(str4.match(pattern5));//[\"Windows\", index: 0, input: \"Windows3.1\"]console.log(str5.match(pattern5));//[\"Windows\", index: 4, input: \"2000Windows\"]console.log(str6.match(pattern5));//[\"Windows\", index: 3, input: \"3.1Windows\"]var pattern6 = /(?&lt;=95|98|NT|2000)Windows/;console.log(str3.match(pattern6));//nullconsole.log(str4.match(pattern6));//nullconsole.log(str5.match(pattern6));//[\"Windows\", index: 4, input: \"2000Windows\"]console.log(str6.match(pattern6));//nullvar pattern7 = /(?&lt;!95|98|NT|2000)Windows/;console.log(str3.match(pattern7));//[\"Windows\", index: 0, input: \"Windows2000\"]console.log(str4.match(pattern7));//[\"Windows\", index: 0, input: \"Windows3.1\"]console.log(str5.match(pattern7));//nullconsole.log(str6.match(pattern7));//[\"Windows\", index: 3, input: \"3.1Windows\"] 小提示：获取匹配和非获取匹配的区别 获取匹配的意思是，如果字符串匹配到正则规范，则会返回正则中的所有内容，如上面案例中的案例一。非获取匹配的意思是，如果字符串匹配到正则规范，则会返回正则中的非括号内的内容，如上面案例中的案例二。 4 相关方法js中使用正则的字符对象的方法 search(regexp); match(regexp); replace(regexp,str); split(regexp); 5 正则实例5.1 匹配139开头的电话号码1234567891011var phone1='13998675896';var phone2='13498675896';var phone3='1399867a896';var phone4='1399867589';var pattern=/^139\\d&#123;8&#125;$/i;console.log(phone1.match(pattern));//[\"13998675896\", index: 0, input: \"13998675896\"]console.log(phone2.match(pattern));//null 因为开头不是139，所以返回nullconsole.log(phone3.match(pattern));//null 因为139之后的八位数中包含了字母，不是纯数字，所以返回nullconsole.log(phone4.match(pattern));//null 因为139之后的只有七个数字，所以返回null 5.2 匹配邮箱格式12345678910111213141516// \\w 任意一个字母、数字或下划线// + 1个或多个var mail1='skdd@qq.com';var mail2='skdd@163.com';var mail3='skdd@gmail.com';var mail4='skddqq.com';var mail5='skdd@qq.22.com';var mail6='-skdd@qq.22.com';var pattern=/^\\w+@\\w+\\.\\w+$/i;console.log(mail1.match(pattern));//[ 'skdd@qq.com', index: 0, input: 'skdd@qq.com' ]console.log(mail2.match(pattern));//[ 'skdd@163.com', index: 0, input: 'skdd@163.com' ]console.log(mail3.match(pattern));//[ 'skdd@gmail.com', index: 0, input: 'skdd@gmail.com' ]console.log(mail4.match(pattern));//null 因为没有@符号，所以返回nullconsole.log(mail5.match(pattern));//null 因为@后面是qq.22.com分了三段，所以返回null 5.3 替换日期格式将以\\分割的日期转化成以-分割的日期格式 12345678910111213141516var date1='2017/11/21';var date2='2017/11/21 13:11:15';var date3='2017/11/21 13/11/15';var date4='2017/11/21 13/11';var date5='2017-11-21';var date6='2017#11#21';var pattern=/(\\d+)\\/(\\d+)\\/(\\d+)/g;//$1-$2-$3是向后引用console.log(date1.replace(pattern,'$1-$2-$3'));//2017-11-21console.log(date2.replace(pattern,'$1-$2-$3'));//2017-11-21 13:11:15console.log(date3.replace(pattern,'$1-$2-$3'));//2017-11-21 13-11-15console.log(date4.replace(pattern,'$1-$2-$3'));//2017-11-21 13/11console.log(date5.replace(pattern,'$1-$2-$3'));//2017-11-21console.log(date6.replace(pattern,'$1-$2-$3'));//2017#11#21 5.4 检测一百以内数检测0到100两位小数的正则不包含0包含100（包含三位小数） 1234567891011121314151617var num1 =\"11\";var num2 =\"11.123\";var num3 =\"11.1547\";var num4 =\"99.5\";var num5 =\"100\";var num6 =\"100.0000\";var num7 =\"100.01\";var pattern=/^([1-9]\\d&#123;0,1&#125;(\\.\\d&#123;0,3&#125;)?|100)$/;console.log(num1.match(pattern));//[\"11\", \"11\", undefined, index: 0, input: \"11\"]console.log(num2.match(pattern));//[\"11.123\", \"11.123\", \".123\", index: 0, input: \"11.123\"]console.log(num3.match(pattern));//nullconsole.log(num4.match(pattern));//[\"99.5\", \"99.5\", \".5\", index: 0, input: \"99.5\"]console.log(num5.match(pattern));//[\"100\", \"100\", undefined, index: 0, input: \"100\"]console.log(num6.match(pattern));//nullconsole.log(num7.match(pattern));//null 5.5 返回字符串中括号内文字12345678910111213141516171819202122var str1 =\"dddd（sdfsdfs）\";var str2 = \"dddd（sdfsdfs）dddd（sdfsdfs）dddd（sdfsdfs）\";var str3 =\"dddd（sdfsdfs）dddd（sdfsdfs）dd dd（sdfsdfs）dd dd（sdfsdfs）ddsdd（sdfsdfs）dddd（sdfs dfs）ddd d（sd fsdfs）\";var str4 =\"dddd（sdfsdfs）dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd（&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;）dd dd（sdfsdfs）ddsdd（sdfsdfs）dddd（sdfs dfs）ddd d（sd fsdfs）\";var str5 =\"dddd（sdfsdfs）dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd（&lt;sdfsdfssdfsdfs）dd dd（sdfsdfs）ddsdd（sdfsdfs）dddd（sdfs dfs）ddd d（sd fsdfs）\";var str6 =\"dddd（sdfsdfs）dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd（sdfsdfssdfsdfs&gt;）dd dd（sdfsdfs）ddsdd（sdfsdfs）dddd（sdfs dfs）ddd d（sd fsdfs）\";var str7 =\"dddd（sdfsdfs）dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd（\\sdfsdfssdfsdfs）dd dd（sdfsdfs）ddsdd（sdfsdfs）dddd（sdfs dfs）ddd d（sd fsdfs）\";var str8 =\"dddd（sdfsdfs）dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd（sdfsdfs）dd dd（sdfsdfs）ddsdd（sdfsdfs）dddd（sdfs dfs）ddd d（sd fsdfs）\";// var pattern = /(?=.*\\w)+\\（+(\\w+)\\）+/g;//匹配所有中文括号中包含字母的内容// var pattern = /\\（+(\\w+|\\s)*s\\）+/g;//匹配所有中文括号中包含字母或者空格的内容// var pattern = /\\（+(\\w+|\\s+\\&lt;+|\\&gt;+|\\\\)*s\\）+/g;var pattern = /\\（+(\\w+|\\s+|\\&lt;+|\\&gt;+|\\\\)*\\）+/g;//匹配所有中文括号中包含字母或者空格或者左尖角括号或者右尖角括号或者反斜线的内容console.log(str1.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;console.log(str2.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;console.log(str3.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;dd dd&lt;sdfsdfs&gt;dd dd&lt;sdfsdfs&gt;ddsdd&lt;sdfsdfs&gt;dddd&lt;dfs&gt;ddd d&lt;fsdfs&gt;console.log(str4.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd（&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;）dd dd&lt;sdfsdfs&gt;ddsdd&lt;sdfsdfs&gt;dddd&lt;dfs&gt;ddd d&lt;fsdfs&gt;console.log(str5.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd&lt;sdfsdfssdfsdfs&gt;dd dd&lt;sdfsdfs&gt;ddsdd&lt;sdfsdfs&gt;dddd&lt;dfs&gt;ddd d&lt;fsdfs&gt;console.log(str6.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd&lt;&gt;&gt;dd dd&lt;sdfsdfs&gt;ddsdd&lt;sdfsdfs&gt;dddd&lt;dfs&gt;ddd d&lt;fsdfs&gt;console.log(str7.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd&lt;sdfsdfssdfsdfs&gt;dd dd&lt;sdfsdfs&gt;ddsdd&lt;sdfsdfs&gt;dddd&lt;dfs&gt;ddd d&lt;fsdfs&gt;console.log(str8.replace(pattern,'&lt;$1&gt;'));//dddd&lt;sdfsdfs&gt;dddd&lt;sdfsdfs&gt;&lt;/sdfsdfs&gt;dd dd&lt;sdfsdfs&gt;dd dd&lt;sdfsdfs&gt;ddsdd&lt;sdfsdfs&gt;dddd&lt;dfs&gt;ddd d&lt;fsdfs&gt; 5.6 检测上传文件名需要检测上传文件路径中，是否都是同一文件名不同格式的多个文件 12345678910111213141516171819202122232425262728function checkUnique(filePath)&#123; var isRight =false; //给数组去重 Array.prototype.unique = function () &#123; this.sort(); //先排序 var res = [this[0]]; for (var i = 1; i &lt; this.length; i++) &#123; if (this[i] !== res[res.length - 1]) &#123; res.push(this[i]); &#125; &#125; return res; &#125; var patt=/\\.+[\\w]&#123;3&#125;/g; //检测后缀名的正则 var ml = filePath.replace(patt,'');//去掉文件路径中的后缀名 ml = ml.split(\"，\").unique(); if(ml.length==1)&#123; isRight =true; &#125; // console.log(\"checkUnique\"); // console.log(isRight); return isRight;&#125;var filePath1 =\"polygon.cpg，polygon.dbf，polygon.prj，polygon.shp，polygon.shx\";var filePath2 =\"polygon.cpg，line.dbf，eee.prj\";console.log(checkUnique(filePath1));//trueconsole.log(checkUnique(filePath2));//false 5.7 检测上传文件格式需要检测上传文件路径中，是否包含了所有要求上传的文件格式 123456789101112131415161718192021222324252627function checkContainer(filePath)&#123; var isRight =true; var checkType = [\"dbf\", \"shp\", \"shx\"]; var patt=/[\\w]+\\./g; var ml = filePath.replace(patt,''); ml = ml.toLowerCase().split(\"，\"); var rightArray = []; for(var i = 0 ; i &lt;ml.length ; i++)&#123; var pattern = RegExp(ml[i]); if(pattern.test(checkType)&amp;&amp; ml[i]!==undefined&amp;&amp;!pattern.test(rightArray))&#123; rightArray.push(ml[i]); &#125; &#125; if(rightArray.length!=checkType.length)&#123; isRight = false; &#125; // console.log(\"checkContainer\"); // console.log(isRight); return isRight;&#125;var filePath1 =\"polygon.cpg，polygon.dbf，polygon.prj，polygon.shp，polygon.shx\";var filePath2 =\"polygon.cpg，line.dbf，eee.prj\";var filePath3 =\"polygon.shp，line.dbf，eee.shx\";console.log(checkContainer(filePath1));//trueconsole.log(checkContainer(filePath2));//falseconsole.log(checkContainer(filePath3));//true 6 完整速查表 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，n匹配字符n。\\n匹配一个换行符。串行\\\\匹配\\而\\(则匹配(。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配\\n或\\r之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配\\n或\\r之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配z以及zoo。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，zo+能匹配zo以及”zoo“，但不能匹配z。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，do(es)?可以匹配does或does中的do。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，o{2}不能匹配Bob中的o，但是能匹配food中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，o{2,}不能匹配Bob中的o，但能匹配foooood中的所有o。o{1,}等价于o+。o{0,}则等价于o*。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，o{1,3}将匹配fooooood中的前三个o。o{0,1}等价于o?。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串oooo，o+?将匹配单个o，而o+将匹配所有o。 . 匹配除\\n之外的任何单个字符。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用\\(或\\)。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，[abc]可以匹配plain中的a。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，[^abc]可以匹配plain中的p。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，[a-z]可以匹配a到z范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，[^a-z]可以匹配任何不在a到z范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，er\\b可以匹配never中的er，但不能匹配verb中的er。 \\B 匹配非单词边界。er\\B能匹配verb中的er，但不能匹配never中的er。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的c字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于[A-Za-z0-9_]。 \\W 匹配任何非单词字符。等价于[^A-Za-z0-9_]。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，\\x41匹配A。\\x041则等价于\\x04&amp;1。正则表达式中可以使用ASCII编码。 \\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，(.)\\1匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 \\nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 7 特殊值正则转换表1234567var strString = \"hello watermelon\";var oo = new Object();var oString = new String(\"hello world\");var oBool = new Boolean(true);var oNum = new Number(68);var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date();//Thu Dec 21 2017 19:39:40 GMT+0800 (中国标准时间) 原始值 使用方法 转化值 true new RegExp(true) /true/ false new RegExp(false) /false/ undefined new RegExp(undefined) /(?:)/ null new RegExp(null) /null/ NaN new RegExp(NaN) /NaN/ { name: ‘Wu Eva’ } new RegExp(oo) /[object Object]/ [String: ‘hello world’] new RegExp(oString) /hello world/ [Boolean: true] new RegExp(oBool) /true/ [Number: 68] new RegExp(oNum) /68/ oDate new RegExp(oDate) /Thu Dec 21 2017 19:39:40 GMT+0800 (中国标准时间)/ Number.MAX_VALUE new RegExp(Number.MAX_VALUE) /1.7976931348623157e+308/ Number.MIN_VALUE new RegExp(Number.MIN_VALUE) /5e-324/ Number.NaN new RegExp(Number.NaN) /NaN/ Number.NEGATIVE_INFINITY new RegExp(Number.NEGATIVE_INFINITY) /-Infinity/ Number.POSITIVE_INFINITY new RegExp(Number.POSITIVE_INFINITY) /Infinity/ 8 常用正则表达式 用户名 /^[a-z0-9_-]{3,16}$/ 密码 /^[a-z0-9_-]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/ /^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.{1,2}[a-z]+)+$/ URL /^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$/ IP 地址 /((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\\/\\1&gt;|\\s+\\/&gt;)$/ 删除代码\\注释 /(?&lt;!http:|\\S)//.*$/ Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/","tags":[{"name":"object","slug":"object","permalink":"https://mowatermelon.github.io/tags/object/"},{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"},{"name":"regexp","slug":"regexp","permalink":"https://mowatermelon.github.io/tags/regexp/"}]},{"title":"ArcGISJS学习之规范化json数据","date":"2017-10-28T16:00:00.000Z","path":"2017/10/29/arcgis-learning-json/","text":"1 GeoJson规范1.1 概要1.1.1 FeatureCollection 属性名 含义 数据类型 默认值 type 数据类型 string FeatureCollection metadata 页头信息 json 详细参考1.2 metadata features 数据集 array 默认为空 feature 数据集点 json 详细参考1.3 feature 123456//举个栗子var t_GeoJson=&#123; \"type\": \"FeatureCollection\", \"metadata\": &#123;&#125;, \"features\": [feature,feature,feature]&#125;; 1.1.2 GeometryCollection 属性名 含义 数据类型 默认值 type 数据类型 string GeometryCollection geometries 数据集 array 默认为空 geometry 数据集点 json 详细参考1.5 geometry 12345//举个栗子var t_GeoJson= &#123; \"type\" : \"GeometryCollection\", \"geometries\" : [geometry,geometry,geometry]&#125;; 1.2 metadata 属性名 含义 数据类型 默认值 generated 数据产生时间 date 新建时间的时间戳 url 文件路径 string 默认为空 title 产生数据的公司名 string 默认为空 status 获取文件返回状态值 number 默认为200 count 数据中features的长度 number 默认为0 12345678910//举个栗子var starttime =new Date();var t_metadata=&#123; \"generated\": Number(starttime), \"url\":'', \"title\": \"西瓜信息技术股份有限公司\", \"status\": 200, \"api\": '', \"count\": 0&#125;; 1.3 feature 属性名 含义 数据类型 默认值 type 数据类型 string Feature properties 功能属性 json 详细参考1.4 properties geometry 地理信息点集合 json 详细参考1.5 geometry id 唯一标识的属性值 string 默认为空 1234567//举个栗子var t_feature=&#123; type: 'Feature', properties: &#123;&#125;, geometry: &#123;&#125;, id:'Feature_1'&#125; 1.4 properties 属性参数值完全自定义，仅列出几个常用的 属性名 含义 数据类型 默认值 time 文件创建时间戳 date 默认为空 updated 文件更新时间戳 date 默认为空 net 区分不同feature的前缀 string 默认为空 code 区分不同feature的唯一标识后缀 string 默认为空 place 地点所属信息 string 默认为空 12345678//举个栗子var t_properties=&#123; time: 1513318909100, updated: 1513319134021, net: \"ci\", code: \"37830103\", place: \"9km NE of Aguanga, CA\"&#125; 1.5 geometry 属性名 含义 数据类型 默认值 type 数据类型 string [“Point”,”LineString”,”Polygon”,”MultiPoint”,”MultiLineString”,”MultiPolygon”] coordinates 坐标点 array 默认为空 12345678//举个栗子var t_geometry=&#123; type: \"Point\", coordinates: [ -116.7933333, 33.4948333 ] &#125; 2 ArcGISJson规范2.1 概要 属性名 含义 数据类型 默认值 geometry 数据点集合 json 详细参考2.2 geometry attributes 从数据库带出来的点数据属性 json 默认为空 12345//举个栗子var t_ArcGISJson=&#123; geometry: &#123;&#125;, attributes:&#123;&#125; &#125; 2.2 geometry 属性名 含义 数据类型 默认值 rings 数据点数据集合 array 默认为空 spatialReference 坐标系相关信息 json 详细参考2.3 spatialReference 12345//举个栗子var t_geometry=&#123; rings: [], spatialReference:&#123;&#125; &#125; 2.3 spatialReference 属性名 含义 数据类型 默认值 wkid 当前坐标系 number 默认为102100 latestWkid 上形状的一个坐标系 number 默认为3857 12345//举个栗子var t_spatialReference=&#123; \"wkid\": 2361, \"latestWkid\": 4358 &#125; 3 dataJson规范3.1 Point3.1.1 Point数据 xml 123456 &lt;?xml version=\"1.0\" encoding=\"gb2312\" ?&gt;&lt;GeoStar&gt; &lt;pts num=\"1\" type=\"point\"&gt; &lt;pt num=\"1\" x=\"39403538.6587504\" y=\"3074587.77015091\" /&gt; &lt;/pts&gt;&lt;/GeoStar&gt; GeoJson 1234&#123; \"type\": \"Point\", \"coordinates\": [0,0]&#125;; ArcGISJson 1234567&#123; \"x\":0, \"y\":0, \"spatialReference\":&#123; \"wkid\":4326 &#125;&#125; 3.1.2 MultiPoint数据 xml 123456789 &lt;?xml version=\"1.0\" encoding=\"gb2312\" ?&gt;&lt;GeoStar&gt; &lt;pts num=\"1\" type=\"point\"&gt; &lt;pt num=\"1\" x=\"39403538.6587504\" y=\"3074587.77015091\" /&gt; &lt;pt num=\"2\" x=\"39403543.4112997\" y=\"3074417.86005092\" /&gt; &lt;pt num=\"3\" x=\"39403540.6814504\" y=\"3074422.05055086\" /&gt; &lt;pt num=\"4\" x=\"39403533.3421502\" y=\"3074433.35985036\" /&gt; &lt;/pts&gt;&lt;/GeoStar&gt; GeoJson 123456789101112131415161718192021&#123; \"type\": \"MultiPoint\", \"coordinates\": [ [ 39403538.6587504, 3074587.77015091 ], [ 39403543.4112997, 3074417.86005092 ], [ 39403540.6814504, 3074422.05055086 ], [ 39403533.3421502, 3074433.35985036 ] ]&#125; ArcGISJson 1234567891011121314151617181920212223&#123; \"points\": [ [ 39403538.6587504, 3074587.77015091 ], [ 39403543.4112997, 3074417.86005092 ], [ 39403540.6814504, 3074422.05055086 ], [ 39403533.3421502, 3074433.35985036 ] ], \"spatialReference\": &#123; \"wkid\": 4326 &#125;&#125; 3.2 Polyline3.2.1 Polyline数据 xml 123456789 &lt;?xml version=\"1.0\" encoding=\"gb2312\" ?&gt;&lt;GeoStar&gt; &lt;pts num=\"1\" type=\"line\"&gt; &lt;pts num=\"1\" type=\"line\"&gt; &lt;pt num=\"1\" x=\"39402074.9148183\" y=\"3085203.38736518\" /&gt; &lt;pt num=\"2\" x=\"39402075.2866289\" y=\"3085201.19406264\" /&gt; &lt;/pts&gt; &lt;/pts&gt;&lt;/GeoStar&gt; GeoJson 12345678910111213&#123; \"type\": \"LineString\", \"coordinates\": [ [ 39402074.9148183, 3085203.38736518 ], [ 39402075.2866289, 3085201.19406264 ] ]&#125; ArcGISJson 1234567891011121314151617&#123; \"paths\": [ [ [ 39402074.9148183, 3085203.38736518 ], [ 39402075.2866289, 3085201.19406264 ] ] ], \"spatialReference\": &#123; \"wkid\": 4326 &#125;&#125; 3.2.2 MultiPolyline数据 xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"gb2312\" ?&gt; &lt;GeoStar&gt; &lt;pts num=\"1\" type=\"line\"&gt; &lt;pts num=\"1\" type=\"line\"&gt; &lt;pt num=\"1\" x=\"39402074.9148183\" y=\"3085203.38736518\" /&gt; &lt;pt num=\"2\" x=\"39402075.2866289\" y=\"3085201.19406264\" /&gt; &lt;/pts&gt; &lt;pts num=\"2\" type=\"line\"&gt; &lt;pt num=\"1\" x=\"39402088.7842049\" y=\"3085954.221558\" /&gt; &lt;pt num=\"2\" x=\"39402089.6243769\" y=\"3085957.43230666\" /&gt; &lt;/pts&gt; &lt;pts num=\"3\" type=\"line\"&gt; &lt;pt num=\"1\" x=\"39402089.6243769\" y=\"3085957.43230666\" /&gt; &lt;pt num=\"2\" x=\"39402099.5382456\" y=\"3085954.811617\" /&gt; &lt;/pts&gt; &lt;pts num=\"4\" type=\"line\"&gt; &lt;pt num=\"1\" x=\"39402099.5382456\" y=\"3085954.811617\" /&gt; &lt;pt num=\"2\" x=\"39402097.2217816\" y=\"3085946.92696906\" /&gt; &lt;/pts&gt; &lt;/pts&gt; &lt;/GeoStar&gt; GeoJson 123456789&#123; \"type\": \"MultiLineString\", \"coordinates\": [ [ [39402074.9148183,3085203.38736518],[39402075.2866289,3085201.19406264] ], [ [39402088.7842049,3085954.221558],[39402089.6243769,3085957.4323066] ], [ [39402089.6243769,3085957.43230666],[39402099.5382456,3085954.811617] ], [ [39402099.5382456,3085954.811617],[39402097.2217816,3085946.92696906] ] ]&#125; ArcGISJson 1234567891011&#123; \"paths\": [ [ [39402074.9148183,3085203.38736518],[39402075.2866289,3085201.19406264] ], [ [39402088.7842049,3085954.221558],[39402089.6243769,3085957.4323066] ], [ [39402089.6243769,3085957.43230666],[39402099.5382456,3085954.811617] ], [ [39402099.5382456,3085954.811617],[39402097.2217816,3085946.92696906] ] ], \"spatialReference\":&#123; \"wkid\":4326 &#125;&#125; 3.3 Polygon3.3.1 Polygon数据 xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"gb2312\" ?&gt; &lt;GeoStar&gt; &lt;pts num=\"1\" type=\"polygon\"&gt; &lt;pts num=\"1\" type=\"polygon\"&gt; &lt;pt num=\"1\" x=\"39403576.9029002\" y=\"3074528.48695056\" /&gt; &lt;pt num=\"2\" x=\"39403553.7662496\" y=\"3074513.69820033\" /&gt; &lt;pt num=\"3\" x=\"39403551.5182278\" y=\"3074517.19848639\" /&gt; &lt;pt num=\"4\" x=\"39403548.3623503\" y=\"3074522.11235071\" /&gt; &lt;pt num=\"5\" x=\"39403571.3602499\" y=\"3074537.01955018\" /&gt; &lt;pt num=\"6\" x=\"39403574.5269088\" y=\"3074532.1446557\" /&gt; &lt;pt num=\"7\" x=\"39403576.9029002\" y=\"3074528.48695056\" /&gt; &lt;/pts&gt; &lt;/pts&gt; &lt;/GeoStar&gt; GeoJson 1234567891011121314151617181920212223242526272829303132333435&#123; \"type\": \"Polygon\", \"coordinates\": [ [ [ 39403576.9029002, 3074528.48695056 ], [ 39403553.7662496, 3074513.69820033 ], [ 39403551.5182278, 3074517.19848639 ], [ 39403548.3623503, 3074522.11235071 ], [ 39403571.3602499, 3074537.01955018 ], [ 39403574.5269088, 3074532.1446557 ], [ 39403576.9029002, 3074528.48695056 ] ] ]&#125; ArcGISJson 12345678910111213141516171819202122232425262728293031323334353637&#123; \"rings\": [ [ [ 39403576.9029002, 3074528.48695056 ], [ 39403553.7662496, 3074513.69820033 ], [ 39403551.5182278, 3074517.19848639 ], [ 39403548.3623503, 3074522.11235071 ], [ 39403571.3602499, 3074537.01955018 ], [ 39403574.5269088, 3074532.1446557 ], [ 39403576.9029002, 3074528.48695056 ] ] ], \"spatialReference\": &#123; \"wkid\": 4326 &#125;&#125; 3.3.2 MultiPolygon数据 xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"gb2312\" ?&gt; &lt;GeoStar&gt; &lt;pts num=\"1\" type=\"polygon\"&gt; &lt;pts num=\"1\" type=\"polygon\"&gt; &lt;pt num=\"1\" x=\"39403576.9029002\" y=\"3074528.48695056\" /&gt; &lt;pt num=\"2\" x=\"39403553.7662496\" y=\"3074513.69820033\" /&gt; &lt;pt num=\"3\" x=\"39403551.5182278\" y=\"3074517.19848639\" /&gt; &lt;pt num=\"4\" x=\"39403548.3623503\" y=\"3074522.11235071\" /&gt; &lt;pt num=\"5\" x=\"39403571.3602499\" y=\"3074537.01955018\" /&gt; &lt;pt num=\"6\" x=\"39403574.5269088\" y=\"3074532.1446557\" /&gt; &lt;pt num=\"7\" x=\"39403576.9029002\" y=\"3074528.48695056\" /&gt; &lt;/pts&gt; &lt;pts num=\"2\" type=\"polygon\"&gt; &lt;pt num=\"1\" x=\"39403571.5510812\" y=\"3074204.91445576\" /&gt; &lt;pt num=\"2\" x=\"39403606.1226998\" y=\"3074150.2527506\" /&gt; &lt;pt num=\"3\" x=\"39403557.7287\" y=\"3074119.98975049\" /&gt; &lt;pt num=\"4\" x=\"39403502.7917\" y=\"3074207.79574996\" /&gt; &lt;pt num=\"5\" x=\"39403550.6100553\" y=\"3074238.02463336\" /&gt; &lt;pt num=\"6\" x=\"39403550.657939\" y=\"3074237.94859318\" /&gt; &lt;pt num=\"7\" x=\"39403571.5510812\" y=\"3074204.91445576\" /&gt; &lt;/pts&gt; &lt;pts num=\"3\" type=\"polygon\"&gt; &lt;pt num=\"1\" x=\"39403611.6048495\" y=\"3074470.44865039\" /&gt; &lt;pt num=\"2\" x=\"39403589.647\" y=\"3074456.46835047\" /&gt; &lt;pt num=\"3\" x=\"39403588.0641691\" y=\"3074459.0560815\" /&gt; &lt;pt num=\"4\" x=\"39403586.5204\" y=\"3074461.57995062\" /&gt; &lt;pt num=\"5\" x=\"39403583.09385\" y=\"3074466.70520084\" /&gt; &lt;pt num=\"6\" x=\"39403604.79485\" y=\"3074481.21385012\" /&gt; &lt;pt num=\"7\" x=\"39403608.22145\" y=\"3074476.0886009\" /&gt; &lt;pt num=\"8\" x=\"39403609.9761004\" y=\"3074473.0069\" /&gt; &lt;pt num=\"9\" x=\"39403611.6048495\" y=\"3074470.44865039\" /&gt; &lt;/pts&gt; &lt;pts num=\"4\" type=\"polygon\"&gt; &lt;pt num=\"1\" x=\"39403602.4861997\" y=\"3074075.92495068\" /&gt; &lt;pt num=\"2\" x=\"39403606.2165827\" y=\"3074069.99364024\" /&gt; &lt;pt num=\"3\" x=\"39403610.4104819\" y=\"3074063.32533933\" /&gt; &lt;pt num=\"4\" x=\"39403613.1025495\" y=\"3074059.04495028\" /&gt; &lt;pt num=\"5\" x=\"39403600.9451504\" y=\"3074051.29040028\" /&gt; &lt;pt num=\"6\" x=\"39403598.2374224\" y=\"3074055.56076534\" /&gt; &lt;pt num=\"7\" x=\"39403593.9818085\" y=\"3074062.27230567\" /&gt; &lt;pt num=\"8\" x=\"39403590.2175995\" y=\"3074068.20885092\" /&gt; &lt;pt num=\"9\" x=\"39403602.4861997\" y=\"3074075.92495068\" /&gt; &lt;/pts&gt; &lt;/pts&gt; &lt;/GeoStar&gt; GeoJson 1234567891011121314151617&#123; \"type\": \"MultiPolygon\", \"coordinates\": [ [ [39403576.9029002,3074528.48695056],[39403553.7662496,3074513.69820033],[39403551.5182278,3074517.19848639],[39403548.3623503,3074522.11235071],[39403571.3602499,3074537.01955018],[39403574.5269088,3074532.1446557],[39403576.9029002,3074528.48695056] ], [ [39403571.5510812,3074204.91445576],[39403606.1226998,3074150.2527506],[39403557.7287,3074119.98975049],[39403502.7917,3074207.79574996],[39403550.6100553,3074238.02463336],[39403550.657939,3074237.94859318],[39403571.5510812,3074204.91445576] ], [ [39403611.6048495,3074470.44865039],[39403589.647,3074456.46835047],[39403588.0641691,3074459.0560815],[39403586.5204,3074461.57995062],[39403583.09385,3074466.70520084],[39403604.79485,3074481.21385012],[39403608.22145,3074476.0886009],[39403609.9761004,3074473.0069],[39403611.6048495,3074470.44865039] ], [ [39403602.4861997,3074075.92495068],[39403606.2165827,3074069.99364024],[39403610.4104819,3074063.32533933],[39403613.1025495,3074059.04495028],[39403600.9451504,3074051.29040028],[39403598.2374224,3074055.56076534],[39403593.9818085,3074062.27230567],[39403590.2175995,3074068.20885092],[39403602.4861997,3074075.92495068] ], ]&#125;; ArcGISJson 12345678910111213141516171819&#123; \"rings\": [ [ [39403576.9029002,3074528.48695056],[39403553.7662496,3074513.69820033],[39403551.5182278,3074517.19848639],[39403548.3623503,3074522.11235071],[39403571.3602499,3074537.01955018],[39403574.5269088,3074532.1446557],[39403576.9029002,3074528.48695056] ], [ [39403571.5510812,3074204.91445576],[39403606.1226998,3074150.2527506],[39403557.7287,3074119.98975049],[39403502.7917,3074207.79574996],[39403550.6100553,3074238.02463336],[39403550.657939,3074237.94859318],[39403571.5510812,3074204.91445576] ], [ [39403611.6048495,3074470.44865039],[39403589.647,3074456.46835047],[39403588.0641691,3074459.0560815],[39403586.5204,3074461.57995062],[39403583.09385,3074466.70520084],[39403604.79485,3074481.21385012],[39403608.22145,3074476.0886009],[39403609.9761004,3074473.0069],[39403611.6048495,3074470.44865039] ], [ [39403602.4861997,3074075.92495068],[39403606.2165827,3074069.99364024],[39403610.4104819,3074063.32533933],[39403613.1025495,3074059.04495028],[39403600.9451504,3074051.29040028],[39403598.2374224,3074055.56076534],[39403593.9818085,3074062.27230567],[39403590.2175995,3074068.20885092],[39403602.4861997,3074075.92495068] ], ], \"spatialReference\":&#123; \"wkid\":4326 &#125;&#125; 混合数据 GeoJson 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; \"type\" : \"GeometryCollection\", \"geometries\" : [&#123; \"type\" : \"Polygon\", \"coordinates\" : [[[-95, 43], [-95, 50], [-90, 50], [-91, 42], [-95, 43]]] &#125;, &#123; \"type\" : \"LineString\", \"coordinates\" : [[-89, 42], [-89, 50], [-80, 50], [-80, 42]] &#125;, &#123; \"type\" : \"Point\", \"coordinates\" : [-94, 46] &#125;]&#125;&#123; \"type\": \"FeatureCollection\", \"features\": [&#123; \"type\": \"Feature\", \"geometry\": &#123; \"type\": \"Point\", \"coordinates\": [102.0, 0.5] &#125;, \"properties\": &#123; \"prop0\": \"value0\" &#125; &#125;, &#123; \"type\": \"Feature\", \"geometry\": &#123; \"type\": \"LineString\", \"coordinates\": [ [102.0, 0.0],[103.0, 1.0],[104.0, 0.0],[105.0, 1.0] ] &#125;, \"properties\": &#123; \"prop0\": \"value0\" &#125; &#125;, &#123; \"type\": \"Feature\", \"geometry\": &#123; \"type\": \"Polygon\", \"coordinates\": [ [ [100.0, 0.0],[101.0, 0.0],[101.0, 1.0],[100.0, 1.0],[100.0, 0.0] ] ] &#125;, \"properties\": &#123; \"prop0\": \"value0\" &#125; &#125;]&#125; ArcGISJson 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[&#123; \"rings\": [ [[-95, 43],[-95, 50],[-90, 50],[-91, 42],[-95, 43]] ], \"spatialReference\": &#123; \"wkid\": 4326 &#125;&#125;, &#123; \"paths\": [ [[-89, 42],[-89, 50],[-80, 50],[-80, 42]] ], \"spatialReference\": &#123; \"wkid\": 4326 &#125;&#125;, &#123; \"x\": -94, \"y\": 46, \"spatialReference\": &#123; \"wkid\": 4326 &#125;&#125;][&#123; \"geometry\": &#123; \"x\": 102, \"y\": 0.5, \"spatialReference\": &#123; \"wkid\": 4326 &#125; &#125;, \"attributes\": &#123; \"prop0\": \"value0\" &#125;&#125;, &#123; \"geometry\": &#123; \"paths\": [ [[102, 0],[103, 1],[104, 0],[105, 1]] ], \"spatialReference\": &#123; \"wkid\": 4326 &#125; &#125;, \"attributes\": &#123; \"prop0\": \"value0\" &#125;&#125;, &#123; \"geometry\": &#123; \"rings\": [ [ [100,0],[100,1],[101,1],[101,0],[100,0] ] ], \"spatialReference\": &#123; \"wkid\": 4326 &#125; &#125;, \"attributes\": &#123; \"prop0\": \"value0\" &#125;&#125;]","tags":[{"name":"GeoJson","slug":"GeoJson","permalink":"https://mowatermelon.github.io/tags/GeoJson/"},{"name":"ArcGIS Geometries","slug":"ArcGIS-Geometries","permalink":"https://mowatermelon.github.io/tags/ArcGIS-Geometries/"},{"name":"ArcGIS for JS","slug":"ArcGIS-for-JS","permalink":"https://mowatermelon.github.io/tags/ArcGIS-for-JS/"}]},{"title":"前端思考之接手新项目","date":"2017-10-27T16:00:00.000Z","path":"2017/10/28/thinking-in-the-front-end-knowledge-receive-new-project/","text":"最近接手了一个比较老的项目，整理一下我接手之后操作流程 1 阅读项目代码1.1 配置代码1.1.1 参数配置代码 &lt;serverInfor&gt;&lt;/serverInfor&gt;,&lt;map&gt;&lt;/map&gt; 1.1.1 组件配置代码 &lt;formInfo&gt;&lt;/formInfo&gt;,&lt;business&gt;&lt;/business&gt; 1.1.1 路由配置代码 &lt;widgetcontainer&gt;&lt;/widgetcontainer&gt; 1.2 使用到的前端库1.2.1 样式库 esri.dijit,esri.symbol,ligerUI 1.2.2 控制库 dojo,esri.map,esri.geometry 2 分析新增功能需求 2.1 添加对应功能按钮到主页面 2.2 绑定功能对应的面板功能 2.3 面板能够选择本地文件夹 2.4 上传文件到后台 2.5 后台分析文件内容 2.6 后台返回对应规范的结果集 2.7 前台获取到数据 2.8 对于获取到的数据信息进行分析 2.9 获取需要的参数 2.10 通过获取的参数，调用相关方法进行页面展示 3 确认技术实现逻辑3.1在&lt;widgetcontainer&gt;中添加一个新的widget，并寻找合适的功能按钮图片。 3.2在项目/javascript/Widget文件路径中，参考其他组件js模版，新建OverlayfileMsg.js。 3.3在页面拼接Template中添加input[type=file]的组件，并添加相关样式，优化显示效果。为了更好的提示效果，绑定一个span标签实时进行显示上传文件路径。 3.4先将上传文件的类型进行判断，是否为空和或者用户选择的上传类型是否匹配。 3.5将通过判断的数据，读取相关配置，通过dojo.io.iframe.send()方法传到对应的c#后台，后台通过HttpFileCollection files = context.Request.Files;HttpPostedFile fileObj = files[i];进行获取，先判断文件上传格式是否正确，如果都正确，则进行文件保存到服务器指定路径处理，并返回处理结果。 3.6 后台返回对应规范的结果集 文件上传失败！（初始值） 请选择文件。 目录名不正确。 上传文件大小超过限制。 上传文件扩展名是不允许的扩展名。 上传成功 3.7 前台获取到数据，获取后台实际返回值，判断后台处理状态，根据不同状态做对应处理。 3.7.1 上传成功获取需要的参数，调用相关方法进行页面展示 3.7.2 上传失败对于请求后台失败的情况下进行直接弹窗报错 4 开始写代码 通过对应代码编辑器，编写代码，如果遇见错误，通过相关开源社区，搜索相关案例，了解dojo实现机制，了解esri实现机制。 4.11&lt;widget label =\"叠加\" visible=\"true\" index=\"8\" config=\"Widget.OverlayfileMsg\" icon=\"images/img/sharp.png\"/&gt; 4.2123456789101112131415161718192021222324252627282930313233343536dojo.declare(\"Widget.OverlayfileMsg\", null, &#123; title: \"叠加外部数据\", divID: \"LoadDiv\", btnLoad: \"btnLoadFileByName\", formFile:\"fileForm\", ConfigTool: null, map: null, opened: false, graphicLayer: null, floatPanel: null, floatPanelHeight: 128, floatPanelWith: 288, qryTemplate: \"\", adjust: 12, highlightSymbol: null, EmptyGraphicLayer: null, //空白图层 handleMapOnClickHandle: null, constructor: function (param) &#123; &#125;, CreateQryTemplate: function () &#123; &#125;, startup: function () &#123; &#125;, adjustFloatPanelTitle: function (adjust) &#123; &#125;, setSubmit:function(fileType)&#123; &#125;, initalPanel: function () &#123; &#125;, show: function () &#123; &#125;, hide: function () &#123; &#125;, clear: function () &#123; &#125;&#125;); 4.31&lt;a class=\"l-button\" id=\"addfile\" style=\"position: relative;display:inline-block;margin:0 auto;line-height: 24px;text-align: center;\"&gt;&lt;span&gt;选择文件&lt;/span&gt;&lt;input type=\"file\" name=\"fileUp\" id =\"btnLoadFile\" style=\"position: absolute;right: 0;top: 0;opacity: 0;width: 100%;cursor: pointer;text-indent: -2em;\"/&gt;&lt;/a&gt; 12345678910111213/*------------------------------OverlayfileMsg.js*/dojo.connect(dojo.byId(this.btnFileLoad), \"onchange\", this, \"changeFile\");changeFile:function()&#123; // debugger; var fileObj = dojo.byId(this.btnFileLoad); var nameObj = dojo.byId(this.spanFileLoad); if(fileObj.value.length&gt;0)&#123; nameObj.innerHTML=fileObj.files[0].name; &#125;else&#123; nameObj.innerHTML=\"未选择任何文件\"; &#125;&#125;, 4.4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138var _this = this;var arrRadioItem = dojo.query(\"input[type='radio']\");dojo.forEach(arrRadioItem, function (item) &#123; dojo.connect(item, \"onclick\", item, _this.checkRadio);&#125;);checkRadio: function (obj) &#123; //保证单选按钮的唯一性 dojo.query(\".radio\" + obj.srcElement.name).parent().siblings().children().attr(\"checked\", false);&#125;,checkFileType: function () &#123; if (this.map &amp;&amp; this.opened) &#123; var fileType = \"\"; var TempText = \"\"; var dataHTML = this.dataTemplate(); var fileTypeL = dataHTML.length; if (fileTypeL == 0) &#123; fileType = \"SHARP\"; &#125; else if (fileTypeL == 1) &#123; fileType = dataHTML[0].ID; &#125; else if (fileTypeL &gt; 1) &#123; fileType = dojo.query(\"input[type='radio']::checked\").attr(\"value\"); &#125; if (fileType.length &gt; 0) &#123; fileType = fileType.toString(); var filePath =\"\"; var fileObj = dojo.byId(this.btnFileLoad); var fileLength =fileObj.files.length; if(fileType!=\"SHARP\")&#123; filePath = fileObj.files[0].name; &#125;else&#123; filePath = dojo.byId(this.spanFileLoad).innerHTML; &#125; // debugger; filePath = filePath.toString(); filePath = filePath.toLowerCase(); if (fileLength &gt; 0) &#123; // debugger; this.addFile(fileType, filePath,fileLength); &#125; else &#123; TempText = \"必须要选择一个文件\"; &#125; &#125; else &#123; TempText = \"必须要选择一个文件类型\"; &#125; if(TempText.length&gt;0)&#123; showMessage(TempText); &#125; &#125;&#125;,checkUnique:function(filePath)&#123; var isRight =false; //给数组去重 Array.prototype.unique = function () &#123; this.sort(); //先排序 var res = [this[0]]; for (var i = 1; i &lt; this.length; i++) &#123; if (this[i] !== res[res.length - 1]) &#123; res.push(this[i]); &#125; &#125; return res; &#125; var patt=/\\.+[\\w]&#123;3&#125;/g var ml = filePath.replace(patt,''); ml = ml.split(\"，\").unique(); if(ml.length==1)&#123; isRight =true; &#125; // console.log(\"checkUnique\"); // console.log(isRight); return isRight;&#125;,checkContainer:function(filePath)&#123; var isRight =true; var checkType = [\"dbf\", \"shp\", \"shx\"]; var patt=/[\\w]+\\./g; var ml = filePath.replace(patt,''); ml = ml.toLowerCase().split(\"，\"); var rightArray = []; for(var i = 0 ; i &lt;ml.length ; i++)&#123; var pattern = RegExp(ml[i]); if(pattern.test(checkType)&amp;&amp; ml[i]!==undefined&amp;&amp;!pattern.test(rightArray))&#123; rightArray.push(ml[i]); &#125; &#125; if(rightArray.length!=checkType.length)&#123; isRight = false; &#125; // console.log(\"checkContainer\"); // console.log(isRight); return isRight;&#125;,addFile: function (fileType, filePath,fileLength) &#123; //var filePath = dojo.byId(this.btnFileLoad).attr(\"value\"); var isRight = false; var TempText = \"\"; // debugger; switch (fileType) &#123; case \"SHARP\": // debugger; var TempTxt = \"请上传同一个Sharp文件，并且至少要选择后缀名为.shp、.dbf和.shx这三种格式，请重新选择！\"; if(fileLength&lt;3)&#123; TempText = TempTxt; &#125;else if(fileLength&gt;=3)&#123; if(this.checkUnique(filePath))&#123; if (!this.checkContainer(filePath)) &#123; TempText = TempTxt; &#125; &#125;else&#123; TempText = TempTxt; &#125; &#125; //判断Shape文件 break; case \"CAD\": if (filePath.indexOf(\".dwg\") == -1||fileLength!=1) &#123; TempText = \"请只上传一个文件，并且上传文件类型属于CAD文件！请重新选择\"; &#125;//判断CAD文件 break; case \"TXT\": if (filePath.indexOf(\".txt\") == -1||fileLength!=1) &#123; TempText = \"请只上传一个文件，并且上传文件类型属于TXT文件！请重新选择\"; &#125;//判断TXT文件 break; default: if (filePath.indexOf(\".txt\") == -1) &#123; TempText = \"请只上传一个文件，并且上传文件类型属于TXT文件！请重新选择\"; &#125;//判断TXT文件 break; &#125; if(TempText.length==0)&#123; this.setSubmit(fileType); &#125;else&#123; showMessage(TempText); &#125;&#125; 4.51234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*------------------------------layoutOther.js*///分析文件路径getFXWJLJQueryMethod: function () &#123; var result = null; var arrServer = this.getFileQueryServerInfo(); var strMethodID = \"分析文件路径\"; result = this.getMethod(arrServer, strMethodID); return result;&#125;,//获取文件分析服务信息getFileQueryServerInfo: function () &#123;&#125;/*------------------------------OverlayfileMsg.js*/setSubmit:function(fileType)&#123; var method = this.ConfigTool.getFXWJLJQueryMethod(); if (method) &#123; var uploadUrl = method.url; var uploadMethod = method.name; var _this =this; try &#123; dojo.io.iframe.send(&#123; form:_this.formFile, //某个form元素包含本地文件路径 method: \"GET\", handleAs: \"html\", //服务器将返回html页面 url: uploadUrl, content:&#123; dir:fileType, method:uploadMethod, global:_this &#125;, load: this.onSubmitted, //提交成功 error: this.onSubmitError //提交失败 &#125;); &#125; catch (e) &#123; showMessage(\"查找文件实际路径出错，错误原因是\" + e.message); &#125; &#125;else&#123; showMessage(\"读取配置失败，请检查配置\"); &#125;&#125;,onSubmitted:function(response, ioArgs)&#123; var res = response.childNodes[0].innerText; // debugger; var _this =this; if(!!res)&#123; res = JSON.parse(res); if(res.success!=\"false\")&#123; var fileType = _this.content.dir; _this.content.global.readFile(res.msg); &#125;else&#123; showMessage(res.msg); &#125; &#125;&#125;,onSubmitError:function(response, ioArgs)&#123; // debugger; showMessage(response);&#125; 4.6123456789101112131415private void showSuc(HttpContext context, string message)&#123; string res = &quot;&#123;\\&quot;success\\&quot;:\\&quot;true\\&quot;,\\&quot;msg\\&quot;:&quot; + message + &quot;&#125;&quot;; context.Response.AddHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); context.Response.Write(res); context.Response.End();&#125;private void showError(HttpContext context, string message)&#123; string res = &quot;&#123;\\&quot;success\\&quot;:\\&quot;false\\&quot;,\\&quot;msg\\&quot;:\\&quot;&quot; + message + &quot;\\&quot;&#125;&quot;; context.Response.AddHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); context.Response.Write(res); context.Response.End();&#125; 4.74.7.1 上传成功123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163onSubmitted:function(response, ioArgs)&#123; var res = response.childNodes[0].innerText; // debugger; var _this =this; if(!!res)&#123; res = JSON.parse(res); if(res.success!=\"false\")&#123; var fileType = _this.content.dir; _this.content.global.readFile(res.msg); &#125;else&#123; showMessage(res.msg); &#125; &#125;&#125;,initArcJson:function(data)&#123; var starttime =new Date(); var getAttr = data; getAttr.spatialReference= this.map.spatialReference; var demo =&#123; \"geometry\": &#123;&#125;, \"attributes\": &#123; \"generated\": Number(starttime), \"title\": \"西瓜信息技术股份有限公司\", \"status\": 200 &#125; &#125;; demo.geometry = getAttr; return demo;&#125;,readFile: function (data) &#123; // debugger; // var starttime =new Date(); // console.log(\"starttime\"+starttime); // console.log(data); this.EmptyGraphicLayer.clear(); for(var i=0;i&lt;data.length;i++)&#123; // debugger; var tempType = data[i].type; var tempData = this.initArcJson(data[i]); switch (tempType) &#123; case \"point\": this.loadPoint(tempData); //加载point信息 break; case \"line\": this.loadLine(tempData); //加载line信息 break; case \"polygon\": this.loadPolyon(tempData); //加载polygon信息 break; default: this.loadPoint(tempData); //加载point信息 break; &#125; &#125; // console.log(\"this.EmptyGraphicLayer\"+this.EmptyGraphicLayer); // console.log(\"took\", new Date - starttime, \"milliseconds\");&#125;,loadPoint: function (data) &#123; try &#123; // debugger; if(!!data)&#123; var markerSymbol = new esri.symbol.SimpleMarkerSymbol(); markerSymbol.setColor(new esri.Color([192, 64, 223,0.5])); var labelPoint = data.geometry.points; var labelSr =data.geometry.spatialReference; var labelAttr =data.attributes; // debugger; for(var item in labelPoint)&#123; var point = new esri.geometry.Point([Number(labelPoint[item][0]), Number(labelPoint[item][1])], labelSr); var wmpoint = esri.geometry.webMercatorUtils.geographicToWebMercator(point); var textSymbol = new esri.symbols.TextSymbol(\"item: \" + item ); if (!this.EmptyGraphicLayer)&#123; this.EmptyGraphicLayer = getEmptyGraphicLayer(); &#125; var grPp = new esri.Graphic(point, markerSymbol); var grPt = new esri.Graphic(point, textSymbol); if (grPp) &#123; grPp.visible = true; grPp.attributes = labelAttr; grPt.visible = true; grPt.attributes = labelAttr; this.EmptyGraphicLayer.add(grPp); // this.EmptyGraphicLayer.add(grPt); this.EmptyGraphicLayer.visible = true; &#125; if(item==labelPoint.length-1)&#123; // debugger; this.map.centerAndZoom(point,18); &#125; &#125; &#125;else&#123; showMessage(\"数据为空\"); &#125; &#125; catch (e) &#123; showMessage(\"加载点信息错误，错误原因是\" + e.message); &#125;&#125;,loadLine: function (data) &#123; try &#123; var LineSymbol = new esri.symbols.CartographicLineSymbol(); LineSymbol.setWidth(5); var labelAttr =data.attributes; if(!!data)&#123; data.visible = true; var t_graphic =new esri.Graphic(data); t_graphic.symbol=LineSymbol; t_graphic.attributes = labelAttr; if (!this.EmptyGraphicLayer)&#123; this.EmptyGraphicLayer = getEmptyGraphicLayer(); &#125; this.EmptyGraphicLayer.add(t_graphic); var centerPoint =t_graphic.geometry.getExtent().getCenter(); console.log(centerPoint); this.map.centerAndZoom(centerPoint,18); this.EmptyGraphicLayer.visible = true; this.EmptyGraphicLayer.opacity=0.75; &#125;else&#123; showMessage(\"数据为空\"); &#125; &#125; catch (e) &#123; showMessage(\"加载线信息错误，错误原因是\" + e.message); &#125;&#125;,loadPolyon: function (data) &#123; try &#123; var labelAttr =data.attributes; var fillSymbol = new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_NULL,new esri.symbol.SimpleLineSymbol(\"solid\", new esri.Color([82, 158, 229, 0.7]), 5),null); if (!!data) &#123; data.visible = true; var t_graphic =new esri.Graphic(data); t_graphic.symbol=fillSymbol; t_graphic.attributes = labelAttr; if (!this.EmptyGraphicLayer)&#123; this.EmptyGraphicLayer = getEmptyGraphicLayer(); &#125; this.EmptyGraphicLayer.add(t_graphic); var centerPoint =t_graphic.geometry.getExtent().getCenter(); // debugger; this.map.centerAndZoom(centerPoint,18); // var markerSymbol = new esri.symbol.SimpleMarkerSymbol(); // var textSymbol = new esri.symbols.TextSymbol(\"中心点\"); // var grPt = new esri.Graphic(centerPoint, textSymbol); // var grPm = new esri.Graphic(centerPoint, markerSymbol); // this.EmptyGraphicLayer.add(grPt); // this.EmptyGraphicLayer.add(grPm); this.EmptyGraphicLayer.visible = true; this.EmptyGraphicLayer.opacity=0.75; &#125;else&#123; showMessage(\"数据为空\"); &#125; &#125; catch (e) &#123; showMessage(\"加载面信息错误，错误原因是\" + e.message); &#125;&#125; 4.7.2 上传失败12345//提示错误原因onSubmitError:function(response, ioArgs)&#123; // debugger; showMessage(response);&#125; 5 测试代码运行效果 在本地部署项目，利用后台断点和前台debugger进行相关排错。 6 保证代码持续运行 上传文件格式错误，进行合理报错 上传文件过多，进行合理报错 上传文件中包含正确的文件，但是也包含不正确的文件，进行合理报错 解析图形文件是否正确绘制在页面，进行合理报错 三种类型文件上传解析是否都正确，进行合理报错 后续需要处理大文件上传的文件，前后台是否存在异步，进行合理报错 后续补充","tags":[{"name":"前端思考","slug":"前端思考","permalink":"https://mowatermelon.github.io/tags/前端思考/"},{"name":"接手新项目","slug":"接手新项目","permalink":"https://mowatermelon.github.io/tags/接手新项目/"}]},{"title":"西瓜有话说之Js学习object方法总结","date":"2017-10-26T16:00:00.000Z","path":"2017/10/27/js-Thinking-object-function/","text":"1 StringString引用类型方法速览表 1.1 柔和方法 方法分类 含义 方法名 编码 返回字符串内容中对应位置的值或者编码单元 - charAt(index) - charCodeAt(index) - codePointAt(pos) - normalize([form]) - fromCharCode(num1, …, numN) - fromCodePoint(num1, …, numN) 检索 将字符串中内容进行检索返回对应结果 - indexOf(searchValue[, fromIndex]) - lastIndexOf(searchValue[, fromIndex]) - search(regexp) - includes(searchString[, position]) - startsWith(searchString [, position]) - endsWith(searchString [, position]) - match(regexp) 对比 返回一个数字，表示是否引用字符串在排序中位于比较字符串的前面，后面，或者二者相同。 localeCompare(stringExp[, locales][, options]) 拼接 将字符串和其他内容进行拼接 - concat() - padEnd() - padStart() 大小写转换 将字符串中的字母进行大小写转换 - toLowerCase() - toLocaleLowerCase() - toUpperCase() - toLocaleUpperCase() HTML相关方法 将字符串转成对应的Dom内容 - big() - small() - blink() - bold() - italics() - strike() - fixed() - sub() - sup() - anchor(anchorname) - link(url) - fontcolor(color) - fontsize(size) 1.2 强硬方法 方法分类 含义 方法名 替换 相关对象类型名称 replace() 分割 相关对象类型名称 - slice() - split() - substr() - substring() 格式转化 相关对象类型名称 - trim() - trimLeft() - trimRight() 对象通用方法 相关对象类型名称 - valueOf() - hasOwnProperty() - isPrototypeOf() - setPrototypeOf() - unwatch() - watch() - propertyIsEnumerable() 1.3 相似函数1.3.1 编码 将BMP字符进行转码 charCodeAt(index) fromCharCode(num1, …, numN) 能够将非BMP字符也可以进行转码 codePointAt(pos) normalize([form]) fromCodePoint(num1, …, numN) 1.3.2 正则相关 search(regexp) match(regexp) replace(regexp,str) split(regexp) 1.3.3 检索包含 与正则无关的，可以指定检测位置的 indexOf(searchValue[, fromIndex])，返回值为int数字或者-1。 lastIndexOf(searchValue[, fromIndex])，返回值为int数字或者-1。 includes(searchString[, position])，返回值为true或者false。 只检测首尾匹配包含，不可以指定检测位置的 startsWith(searchString [, position])，返回值为true或者false。 endsWith(searchString [, position])，返回值为true或者false。 与正则有关的 search(regexp)，返回值为int数字或者-1。 match(regexp)，返回值为字符串或者null。 1.3.4 数据拼接 赋值操作符（+, +=），string1 += string2+ string2 + string3，运算速度是concat的二十倍左右，是join的两百七十倍左右。 str.concat(string2, string3[, …, stringN])，运算速度是join的十倍左右。 arr.join(separator)。 2 ArrayArray引用类型方法速览表 3 DateDate引用类型方法速览表 4 NumberNumber引用类型方法速览表 5 BooleanBoolean引用类型方法速览表","tags":[{"name":"object","slug":"object","permalink":"https://mowatermelon.github.io/tags/object/"},{"name":"function","slug":"function","permalink":"https://mowatermelon.github.io/tags/function/"},{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"}]},{"title":"知识储备之理解服务概念","date":"2017-10-25T16:00:00.000Z","path":"2017/10/26/knowledge-Service/","text":"1 无服务1.1 on-premises 本地部署 1.1.1 概念 应用(客户管理) 种子—–&gt;西瓜 安全&amp;整合(客户管理) 农药&amp;锄头 数据库(客户管理) 大棚 操作系统(客户管理) 菜地 虚拟化(客户管理) 藤蔓 服务器硬件(客户管理) 货车 存储(客户管理) 仓库 网络(客户管理) 菜市场 1.1.2 解释 你想吃西瓜，自己去买种子，买刀和买农药，买地，弄大棚，买锄头。 而且种子在还没有长成西瓜之前，你需要时刻去大棚关注种子的成长情况，农药，大棚，菜地和锄头可能由于某些原因出了问题，导致种子长不大，成不了一个西瓜。 而且一不小心种多了，你还要需要弄个仓库，还要自己开货车拿到菜市场卖，但是自己养的瓜，在自己吃的时候会更甜。 最后你自己选了一个长的不错的甜西瓜，自己切好，放到桌子上，你就可以吃了。 这一种就是完全自负盈亏，不需要外界提供什么帮助，完全独立的开发 2 云服务2.1 IaaSInfrastructure as a Service，基础设施即服务 2.1.1 概念 应用(客户管理) 种子—–&gt;西瓜 安全&amp;整合(客户管理) 农药&amp;锄头 数据库(客户管理) 大棚 操作系统(服务商管理) 菜地 虚拟化(服务商管理) 藤蔓 服务器硬件(服务商管理) 货车 存储(服务商管理) 仓库 网络(服务商管理) 菜市场 2.1.2 解释 你想吃西瓜，阿莫提供了一块地给你，并且告诉你西瓜成熟之后，她可以帮你用货车拉到菜市场卖。 你需要自己买种子，锄头和农药，在菜地上搭好你的大棚。 如果农药，锄头，种子或者大棚出问题了，你需要自己负责，但是如果是菜地什么的出问题了，你就可以找阿莫，让她赔偿。 最后你自己选了一个长的不错的甜西瓜，自己切好，放到桌子上，你就可以吃了。 这种就是借助了一些现有的基础设施，在项目没有成型之前，有个伙伴帮你承担一部分风险，但是还是参与了一定项目的开发 2.2 PaaSPlatform as a Service，平台即服务 2.2.1 概念 应用(客户管理) 种子—–&gt;西瓜 安全&amp;整合(服务商管理) 农药&amp;锄头 数据库(服务商管理) 大棚 操作系统(服务商管理) 菜地 虚拟化(服务商管理) 藤蔓 服务器硬件(服务商管理) 货车 存储(服务商管理) 仓库 网络(服务商管理) 菜市场 2.2.2 解释 你想吃西瓜， 阿莫直接给你推荐了一个地方，你把种子放进去就行了。 不用管西瓜怎么长大的，怎么运输到你面前的之类，但是由于没有参与种子成长过程，对于长成的西瓜，你需要经过多次品尝，才能知道最适合自己的甜西瓜是哪个。 需要考虑一些可能由于大棚，菜地和货车等等导致的问题，如果发现阿莫提供这个地方，长出来的都是坏西瓜，你可以找阿莫赔偿。 最后你自己找到了一个适合自己的甜西瓜，自己切好，放到桌子上，你就可以吃了。 找个现有平台帮你做大部分环节，需要自己负责的地方很少，但是由于不是自己开发的，需要和平台进行多次磨合，才能得出好项目 2.3 SaaSSoftware as a Service，软件即服务 2.3.1 概念 应用(服务商管理) 种子—–&gt;西瓜 安全&amp;整合(服务商管理) 农药&amp;锄头 数据库(服务商管理) 大棚 操作系统(服务商管理) 菜地 虚拟化(服务商管理) 藤蔓 服务器硬件(服务商管理) 货车 存储(服务商管理) 仓库 网络(服务商管理) 菜市场 2.3.1 解释 你想吃西瓜，阿莫直接帮你切好，放到桌子上，你直接吃就好，不用管瓜怎么长大，什么都不用管，一旦西瓜有问题你可以直接找阿莫咨询 3 总结","tags":[{"name":"IaaS","slug":"IaaS","permalink":"https://mowatermelon.github.io/tags/IaaS/"},{"name":"PaaS","slug":"PaaS","permalink":"https://mowatermelon.github.io/tags/PaaS/"},{"name":"SaaS","slug":"SaaS","permalink":"https://mowatermelon.github.io/tags/SaaS/"},{"name":"on-premises","slug":"on-premises","permalink":"https://mowatermelon.github.io/tags/on-premises/"},{"name":"知识储备","slug":"知识储备","permalink":"https://mowatermelon.github.io/tags/知识储备/"}]},{"title":"西瓜有话说之Meta学习整理常用篇","date":"2017-10-24T16:00:00.000Z","path":"2017/10/25/meta-Thinking-bak-most/","text":"1 概述meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他web服务。 —— W3School 1.1 必要属性 属性 值 描述 content some text 定义与http-equiv或name属性相关的元信息 1.2 可选属性 属性 值 描述 http-equiv content-type / expire / refresh / set-cookie 把content属性关联到HTTP头部。 name author / description / keywords / generator / revised / others 把 content 属性关联到一个名称。 content some text 定义用于翻译 content 属性值的格式。 2 详细解释2.1 页面编码一般html源代码和css文件编码要统一，如果不统一会导致CSS hack，页面乱码网页页面排版乱等兼容问题。这个元数据是必须要被声明的。 国内常用的流行的有utf-8、gb2312这两种。一般这两种类型就能满足国内网页编码需求。当然程序和数据库中也会用到这两种编码类型来处理网页和存储数据类型。 123456&lt;!-- html4中声明编码格式 --&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gb2312\"&gt;&lt;meta http-equiv=\"Content-Language\" Content=\"zh-CN\"&gt;&lt;!-- html5中声明编码格式 --&gt;&lt;meta charset='utf-8' /&gt; 2.2 浏览器默认渲染版本12345&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt;&lt;!-- 关于X-UA-Compatible --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=6\" &gt;&lt;!-- 使用IE6 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" &gt;&lt;!-- 使用IE7 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\" &gt;&lt;!-- 使用IE8 --&gt; 2.3 viewport能优化移动浏览器的显示，如果不是响应式网站，不要使用initial-scale或者禁用缩放。大部分4.7-5寸设备的viewport宽设为360px；5.5寸设备设为400px；iphone6设为375px；ipone6 plus设为414px。 123&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no\"/&gt;&lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边 --&gt; 属性 值 width 宽度（数值 / device-width），范围从200 到10,000，默认为980 像素 height 高度（数值 / device-height），范围从223 到10,000 initial-scale 初始的缩放比例，范围从&gt;0 到10 minimum-scale 允许用户缩放到的最小比例 maximum-scale 允许用户缩放到的最大比例 user-scalable 用户是否可以手动缩 (no,yes) minimal-ui 可以在页面加载时最小化上下状态栏。（已弃用） 注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果将initial-scale=1和user-scalable=no或maximum-scale=1一起设置，则用户将不能放大/缩小网页来看到全部的内容。 2.4 页面作者每个网页都应有一个不超过 150 个字符且能准确反映描述页面作者标签。 123&lt;meta name=\"author\" content=\"author name\" /&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"author\" content=\"WU EVA\"&gt; 2.5 页面关键词每个网页应具有描述该网页内容的一组唯一的关键字。 使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。 标记内容太短，则搜索引擎可能不会认为这些内容相关，但是另外标记不应超过 874 个字符。 123&lt;meta name=\"keywords\" content=\"your tags\" /&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"keywords\" content=\"WATERMELON,HOME,WELCOME\" /&gt; 2.6 页面描述每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。 123&lt;meta name=\"description\" content=\"150 words\" /&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"description\" content=\"THERE ARE WATERMELON HOME,WELCOME!\" /&gt; 2.7 页面创建时间指的是文件的创建时间，简单说就是指这个页面写第一行代码的时间。 123&lt;meta name=\"build\" content=\"2017-12-07\" /&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"build\" content=\"2017-12-07\" /&gt; 2.8 页面版权copyright用于定义网页版权，copyright出现在name属性中，使用content属性提供网页的版权 123&lt;meta name=\"copyright\" content=\"your copyright\"&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"copyright\" content=\"本页版权归watermelon所有。All Rights Reserved\"&gt; 2.9 页面生成工具指的是文件是用什么来生成的，简单说就是页面编辑器是什么。 123&lt;meta name=\"generator\" content=\"your editor\"&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"generator\" content=\"VSCODE\"&gt; 2.10 网络应用名称定义正运行在该网页上的网络应用名称 123&lt;meta name=\"application-name\" content=\"your application name\"&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"application-name\" content=\"WATERMELON-APP\"&gt; 2.11 页面创建者以自由格式定义文档创建者的名字。请注意，它可以是该机构的名称。如果不止一个，应该使用几个&lt;meta&gt;元素; 123&lt;meta name=\"creator\" content=\"your company\"&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"creator\" content=\"WATERMELON COMPANY\"&gt; 2.12 页面发布者发布者，以自由格式定义文档的发布者的名称。请注意，它可以是该机构的名称; 123&lt;meta name=\"publisher\" content=\"your company\"&gt;&lt;!-- 举个栗子 --&gt;&lt;meta name=\"publisher\" content=\"WATERMELON COMPANY\"&gt; 2.13 搜索引擎索引方式robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。 12345&lt;meta name=\"robots\" content=\"index,follow\" /&gt;&lt;meta name=\"google\" content=\"index,follow\" /&gt;&lt;!-- 谷歌机器人，这是机器人的代名词，谷歌的索引爬虫; --&gt;&lt;meta name=\"googlebot\" content=\"index,follow\" /&gt;&lt;!-- 谷歌机器人，这是机器人的代名词，谷歌的索引爬虫; --&gt;&lt;meta name=\"verify\" content=\"index,follow\" /&gt;&lt;meta name=\"slurp\" content=\"index,follow\" /&gt;&lt;!-- 跟踪搜索引擎抓取工具Slurp --&gt; Value Description Used by all 文件将被检索，且页面上的链接可以被查询 All index 文件将被检索 All noindex 文件将不被检索 All follow 页面上的链接可以被查询 All nofollow 页面上的链接不可以被查询 All noodp 防止使用“Open Directory Project”说明,如果有的话，作为搜索引擎结果页面中的描述 Google, Yahoo, Bing noarchive 防止搜索引擎缓存页面的内容 Google, Yahoo nosnippet 防止在搜索引擎结果页面中显示页面的任何描述 Google noimageindex 防止此页面显示为索引图像的引用页面 Google noydir 防止此页面显示为索引图像的引用页面 Yahoo nocache 防止搜索引擎缓存页面的内容 Bing 2.14 页面重定向和刷新content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。 123&lt;meta http-equiv=\"refresh\" content=\"0;url=\" /&gt;&lt;!-- 举个栗子 --&gt;&lt;meta http-equiv=\"refresh\" content=\"3;url=https://mowatermelon.github.io/\"&gt; 2.15 预定义的样式表content 属性的值必须匹配同一文档中的一个 link 元素上的 title 属性的值，或者必须匹配同一文档中的一个 style 元素上的 title 属性的值。 123&lt;meta http-equiv=\"default-style\" content=\"the document's preferred stylesheet\"&gt;&lt;!-- 举个栗子 --&gt;&lt;meta http-equiv=\"default-style\" content=\"theme-color-blue\"&gt; 2.16 禁用缓存禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; 2.17 转码申明用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta 1&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; 2.18 WebApp全屏模式伪装app，离线应用。 1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt; 2.19 隐藏状态栏/设置状态栏颜色只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。 1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; 2.20 添加到主屏后的标题1&lt;meta name=\"apple-mobile-web-app-title\" content=\"title\"&gt; 2.21 忽略数字自动识别为电话号码1&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; 2.22 忽略识别邮箱1&lt;meta content=\"email=no\" name=\"format-detection\" /&gt; 2.23 添加智能 App 广告条 Smart App Banner告诉浏览器这个网站对应的app，并在页面上显示下载banner。 1&lt;meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\"&gt; 2.24 屏幕控制相关123456789101112131415161718&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; 2.25 浏览器内核控制国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染 1&lt;meta name=\"renderer\" content=\"webkit|ie-comp|ie-stand\"&gt; 国内双核浏览器默认内核模式如下： 搜狗高速浏览器、QQ浏览器：IE内核（兼容模式） 360极速浏览器、遨游浏览器：Webkit内核（极速模式） 2.26 Windows 812&lt;meta name=\"msapplication-TileColor\" content=\"#000\"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt;&lt;meta name=\"msapplication-TileImage\" content=\"icon.png\"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt; 2.27 站点适配主要用于PC-手机页的对应关系。 123456&lt;meta name=\"mobile-agent\"content=\"format=[wml|xhtml|html5]; url=url\"&gt;&lt;!--[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；url=\"url\" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。--&gt; 2.28 revisit-after (重访)通知搜索引擎多少天访问一次 1&lt;meta name=\"revisit-after\" CONTENT=\"7 days\" &gt; 2.29 Window-target (显示窗口的设定)已经废弃，说明：强制页面在当前窗口以独立页面显示。 12&lt;meta http-equiv=\"Widow-target\" Content=\"_top\"/&gt; 注意：这个属性是用来防止别人在框架里调用你的页面。Content选项：_blank、_top、_self、_parent。 2.30 Pics-label (网页RSAC等级评定)已经废弃，说明：在IE的Internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过该参数来设置的。 12&lt;meta http-equiv=\"Pics-label\" Contect= \"(PICS－1.1'http://www.rsac.org/ratingsv01.html' I gen comment 'RSACi North America Sever' by 'inet@microsoft.com' for 'http://www.microsoft.com' on '1997.06.30T14:21－0500' r(n0 s0 v0 l0))\"&gt; 注意：不要将级别设置的太高。RSAC的评估系统提供了一种用来评价Web站点内容的标准。用户可以设置Microsoft Internet Explorer（IE3.0以上）来排除包含有色情和暴力内容的站点。上面这个例子中的HTML取自Microsoft的主页。代码中的（n 0 s 0 v 0 l 0）表示该站点不包含不健康内容。级别的评定是由RSAC，即美国娱乐委员会的评级机构评定的，如果你想进一步了解RSAC评估系统的等级内容，或者你需要评价自己的网站，可以访问RSAC的站点：http://www.rsac.org/。 2.31 Page-Enter、Page-Exit (进入与退出)已经废弃，说明：这个是页面被载入和调出时的一些特效。 123456&lt;meta http-equiv=\"Page-Enter\" Content=\"blendTrans(Duration=0.5)\"/&gt;&lt;meta http-equiv=\"Page-Exit\" Content=\"blendTrans(Duration=0.5)\"/&gt;&lt;!-- 注意：blendTrans是动态滤镜的一种，产生渐隐效果。另一种动态滤镜RevealTrans也可以用于页面进入与退出效果: --&gt;&lt;meta http-equiv=\"Page-Enter\" Content=\"revealTrans(duration=x, transition=y)\"/&gt;&lt;meta http-equiv=\"Page-Exit\" Content=\"revealTrans(duration=x, transition=y)\"/&gt; Duration 表示滤镜特效的持续时间(单位：秒)，Transition表示使用哪种特效，取值为0-23。 Transition 滤镜类型 0 矩形缩小 1 矩形扩大 2 圆形缩小 3 圆形扩大 4 下到上刷新 5 上到下刷新 6 左到右刷新 7 右到左刷新 8 竖百叶窗 9 横百叶窗 10 错位横百叶窗 11 错位竖百叶窗 12 点扩散 13 左右到中间刷新 14 中间到左右刷新 15 中间到上下 16 上下到中间 17 右下到左上 18 右上到左下 19 左上到右下 20 左下到右上 21 横条 22 竖条 23 以上22种随机选择一种 2.32 MSThemeCompatible (XP主题)已经废弃，说明：是否在IE中关闭 xp 的主题 1&lt;meta http-equiv=\"MSThemeCompatible\" Content=\"Yes\"&gt; 注意：关闭 xp 的蓝色立体按钮系统显示样式，从而和win2k 很象。 2.33 IE6 (页面生成器)已经废弃，说明：页面生成器generator，是ie6 1&lt;meta http-equiv=\"IE6\" Content=\"Generator\"&gt; 注意：用什么东西做的，类似商品出厂厂商。 2.34 Content-Script-Type (脚本相关)已经废弃，说明：这是近来W3C的规范，指明页面中脚本的类型。 1&lt;meta http-equiv=\"Content-Script-Type\" Content=\"text/javascript\"&gt; 3 常用备份1234567891011121314&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,Chrome=1\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, minimum-scale=1.0, maximum-scale=1, user-scalable=no\" /&gt;&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"/&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\"/&gt;&lt;meta http-equiv=\"Expires\" content=\"0\"/&gt;&lt;meta name=\"author\" content=\"WU EVA\" /&gt;&lt;meta name=\"keywords\" content=\"WATERMELON,HOME,WELCOME\" /&gt;&lt;meta name=\"description\" content=\"THERE ARE WATERMELON HOME,WELCOME!\" /&gt;&lt;meta name=\"build\" content=\"2017-12-07\" /&gt;&lt;meta name=\"copyright\" content=\"本页版权归watermelon所有。All Rights Reserved\"&gt;&lt;meta name=\"generator\" content=\"VSCODE\" /&gt;&lt;meta name=\"robots\" content=\"all\" /&gt;&lt;meta name=\"googlebot\" content=\"all\" /&gt;","tags":[{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"bak","slug":"bak","permalink":"https://mowatermelon.github.io/tags/bak/"},{"name":"js_meta","slug":"js-meta","permalink":"https://mowatermelon.github.io/tags/js-meta/"}]},{"title":"西瓜有话说之Js学习整理常用篇","date":"2017-10-23T16:00:00.000Z","path":"2017/10/24/js-Thinking-bak-most/","text":"1 array数组常用验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//给数组去重，对原数组的值不做修改，返回一个全新数组 ES4写法//适用于数组中重复元素相邻的情况 但是如果重复不相邻 检测力度就一般Array.prototype.unique = function () &#123; //this.sort会直接改变this的内容 //所以在调用sort之前用concat深度复制一下数组内容 //保证数组中首字符等等重复概率比较高的元素 在一块 var _a = this.concat().sort(); //先排序 var res = [_a[0]]; for (var i = 1; i &lt; _a.length; i++) &#123; if (_a[i] !== res[res.length - 1]) &#123; res.push(_a[i]); &#125; &#125; return res; &#125;//给数组去重，对原数组的值不做修改，返回一个全新数组 ES4写法//利用了正则对象 适用于数组中重复元素是否相邻都可以检测Array.prototype.unique = function () &#123; var _a = this, _b = [_a[0]]; _a.sort(function(a,b)&#123; var pattenR= new RegExp(b); if (!pattenR.test(_b)) &#123; _b.push(b); &#125; &#125;); return _b;&#125;//给数组去重，利用了concat协助 ES5写法Array.prototype.distinct = function()&#123; var _self = this.concat(); //请注意这里不能让_a直接指向_self的sort， //要不然下面使用splice的时候会使_self中重复数组不会被删除， // 只是会导致数组最后一个值会变成undefined，不会有去重效果 var _a = this.concat().sort(); _a.sort(function(a,b)&#123; if(a == b)&#123; var n = _self.lastIndexOf(a);//默认删除后面出现的重复元素 _self.splice(n,1); &#125; &#125;); return _self;&#125;;//给数组去重，对原数组的值不做修改，返回一个全新数组，没有使用concat协助 ES5写法Array.prototype.distinct = function()&#123; var _a = this, _b = [_a[0]]; _a.sort(function(a,b)&#123; if (_b.indexOf(b)===-1) &#123; _b.push(b); &#125; &#125;); return _b;&#125;;//计算数组之和function sum(list) &#123; return eval(list.join(\"+\"));&#125;//验证数组中是否包含重复数据function checkArrayUnique(arr) &#123; var isUnique = false; var initArrL = arr.length; if (arr.length &gt; 1) &#123; arr = arr.unique(); if (arr.length != initArrL) &#123; isUnique = true; &#125; &#125; return isUnique;&#125; 2 form表单常用验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236//验证数组中数据是否为空function checkArrayNull(str) &#123; var isNull= false; var emptyReg = /^\\s*$/g; //验证是否为空 isNull = emptyReg.test(str) || str == key_bjwb; return isNull;&#125;//验证数组中数据是否为正整数function checkArrayInteger(str) &#123; var intReg = /[1-9]\\d*/g; return intReg.test(str);&#125;//验证数组中数据是否为0到100的两位小数function checkArrayFloat(str) &#123; //var floatReg = /(?!^0\\.0?0$)^[0-9][0-9]?(\\.[0-9]&#123;1,2&#125;)?$/; var floatReg =/^([1-9]\\d&#123;0,1&#125;(\\.\\d&#123;1,2&#125;)?|100)$/; return floatReg.test(str);&#125;//-------------------------------------------------身份证验证-------start function CheckCardId(strCard) &#123; var IsCheck = true; //校验长度，类型 if (isCardNo(strCard) === false) &#123; IsCheck= false; &#125; //校验生日 if (checkBirthday(strCard) === false) &#123; IsCheck= false; &#125; //检验位的检测 if (checkParity(strCard) === false) &#123; IsCheck= false; &#125; return IsCheck; &#125; //检查号码是否符合规范，包括长度，类型 function isCardNo(card) &#123; //身份证号码为15位或者18位，15位时全为数字，18位前17位为数字，最后一位是校验位，可能为数字或字符X var reg = /(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|X)$)/; if (reg.test(card) === false) &#123; return false; &#125; return true; &#125;; //检查生日是否正确 function checkBirthday(card, birthID) &#123; var len = card.length; //身份证15位时，次序为省（3位）市（3位）年（2位）月（2位）日（2位）校验位（3位），皆为数字 if (len == '15') &#123; var re_fifteen = /^(\\d&#123;6&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)$/; var arr_data = card.match(re_fifteen); var year = arr_data[2]; var month = arr_data[3]; var day = arr_data[4]; var birthday = new Date('19' + year + '/' + month + '/' + day); if (Format(birthID) != \"\") &#123; $(\"#\" + birthID).val('19' + year + '/' + month + '/' + day); &#125; else &#123; return verifyBirthday('19' + year, month, day, birthday); &#125; &#125; //身份证18位时，次序为省（3位）市（3位）年（4位）月（2位）日（2位）校验位（4位），校验位末尾可能为X if (len == '18') &#123; var re_eighteen = /^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X)$/; var arr_data = card.match(re_eighteen); var year = arr_data[2]; var month = arr_data[3]; var day = arr_data[4]; var birthday = new Date(year + '-' + month + '-' + day); if (Format(birthID) != \"\") &#123; $(\"#\" + birthID).val(year + '-' + month + '-' + day); &#125; else &#123; return verifyBirthday(year, month, day, birthday); &#125; &#125; return false; &#125;; //检查生日是否合理 function verifyBirthday(year, month, day, birthday) &#123; var now = new Date(); var now_year = now.getFullYear(); //年月日是否合理 if (birthday.getFullYear() == year &amp;&amp; (birthday.getMonth() + 1) == month &amp;&amp; birthday.getDate() == day) &#123; //判断年份的范围（3岁到100岁之间) var time = now_year - year; if (time &gt;= 3 &amp;&amp; time &lt;= 100) &#123; return true; &#125; return false; &#125; return false; &#125; //校验位的检测 function checkParity(card) &#123; //15位转18位 card = changeFivteenToEighteen(card); var len = card.length; if (len == '18') &#123; var arrInt = new Array(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2); var arrCh = new Array('1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'); var cardTemp = 0, i, valnum; for (i = 0; i &lt; 17; i++) &#123; cardTemp += card.substr(i, 1) * arrInt[i]; &#125; valnum = arrCh[cardTemp % 11]; if (valnum == card.substr(17, 1)) &#123; return true; &#125; return false; &#125; return false; &#125;; //15位转18位身份证号 function changeFivteenToEighteen(card) &#123; if (card.length == '15') &#123; var arrInt = new Array(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2); var arrCh = new Array('1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'); var cardTemp = 0, i; card = card.substr(0, 6) + '19' + card.substr(6, card.length - 6); for (i = 0; i &lt; 17; i++) &#123; cardTemp += card.substr(i, 1) * arrInt[i]; &#125; card += arrCh[cardTemp % 11]; return card; &#125; return card; &#125;; //取身份证前两位,校验省份 function checkProvince(card,txtProvince) &#123; var province = card.substr(0, 2); if (vcity[province] == undefined) &#123; return false; &#125; else &#123; if (Format(txtProvince) != \"\") &#123; $(\"#\" + txtProvince).val(vcity[province]); &#125; &#125; return true; &#125;; //是否为日期格式 function checkDate(RQ) &#123; var date = RQ; var result = date.match(/^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/); if (result == null)&#123; return false; &#125; var d = new Date(result[1], result[3] - 1, result[4]); d =(d.getFullYear() == result[1] &amp;&amp; (d.getMonth() + 1) == result[3] &amp;&amp; d.getDate() == result[4]); return d; &#125; //备份 function CheckCardIdBF(e) &#123; var bDone = true; var Wi = new Array(7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2); var arrVerifyCode = new Array('1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'); var Checker = new Array('1', '9', '8', '7', '6', '5', '4', '3', '2', '1', '1'); if (e.length &lt; 15 || e.length == 16 || e.length == 17 || e.length &gt; 18) &#123; bDone = false; return false; &#125; var Ai = \"\"; if (e.length = 18) &#123; Ai = e.substr(1, 17) &#125; else if (e.length = 15) &#123; Ai = e; Ai = e.substr(0, 6) + '19' + e.substr(6, e.length - 6); &#125; if (isNaN(parseInt(Ai))) &#123; bDone = false; return false; &#125; var strYear, strMonth, strDay strYear = parseInt(Ai.substr(5, 4)); strMonth = parseInt(Ai.substr(9, 2)) strDay = parseInt(Ai.substr(11, 2)) BirthDay = $.trim(strYear) + \"-\" + $.trim(strMonth) + \"-\" + $.trim(strDay); if (checkDate(BirthDay)) &#123; // if (DateDiff(\"y\", new Date(), BirthDay) &lt; -140 || DateDiff(\"y\", BirthDay, new Date()) &lt; 0) &#123; // bDone = false; // return false; // &#125; if (strMonth &gt; 12 || strDay &gt; 31) &#123; bDone = false; return false; &#125; &#125; else &#123; bDone = false; return false; &#125; var TotalmulAiWi = 0; for (var i = 0; i &lt; 17; i++) &#123; var ss = Wi[i]; var dd = parseInt(Ai.substr(i, 1)); TotalmulAiWi += parseInt(Ai.substr(i, 1)) * Wi[i]; &#125; var modValue modValue = TotalmulAiWi % 11 var strVerifyCode strVerifyCode = arrVerifyCode[modValue] if (e.length = 18) &#123; if (e.substr(18, 1) == \"X\") &#123; e = e.substr(0, 17) + \"x\"; &#125; var dxssd = e.substr(17, 1); if (strVerifyCode != e.substr(17, 1)) &#123; bDone = false; return false; &#125; &#125; &#125;//-------------------------------------------------身份证验证-------end//防止sql注入function Format(val) &#123; if (val == null || typeof (val) == \"undefined\" || (val + \"\") == \"null\") &#123; return \"\"; &#125; else &#123; return val + \"\"; &#125;&#125; 3 浏览器判断12345678910111213141516171819function isIE() &#123; if(!!window.ActiveXObject || \"ActiveXObject\" in window)&#123; return true; &#125; else&#123; return false; &#125;&#125;function isIE11()&#123; // 之前的判断浏览器的方法据说已经失效了，原因是IE11使用了和之前版本不一样的User-agent // Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv 11.0) like Gecko // 而 IE10 是： // Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0) // 做法是通过正则判断 User-agent： var isIE11 = (/Trident\\/7\\./).test(navigator.userAgent); return isIE11;&#125;","tags":[{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"},{"name":"bak","slug":"bak","permalink":"https://mowatermelon.github.io/tags/bak/"}]},{"title":".NET学习之Dictionary学习","date":"2017-10-21T16:00:00.000Z","path":"2017/10/22/NET-learning-Dictionary/","text":"1 前言现在项目中用到数据字典配置，使用者可以直接配置字典设置页面上想要展示的内容，但是现在有个问题是，我们为了字典配置能够通用，所以ITEMVAL和ITEMNAME都是NVARCHAR2(256)，可是有个字典中，用户将ITEMVAL统一设置成了int数据，举个栗子，1、2、3等等，希望我们按照这个ITEMVAL升序显示在页面上，但是我在数据库中通过ORDER BY ITEMVAL，发现排出的顺序不是我想要的，正常来说应该是从值为个位数排到两位数，结果实际情况获取到的结果值是1,10,11,12,13,2,3,4,5.....，所以需要对取出来的值通过Dictionary的OrderBy方法进行排序，然后我顺带学习了一下这个用法，为了避免信息问题，我隐藏了数据连接的一些关键词。 2 解决代码2.1 方法体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System;using System.Collections.Generic;using System.Text;//注意一定要引用这个包，要不然会说Dictionary没有OrderBy这个方法using System.Linq;/// &lt;summary&gt;/// 获取字典名为DICNAME，ITEMVAL为具体数值的，将从数据库取出来的值，进行升序或降序排列，再进行返回/// &lt;/summary&gt;/// &lt;param name=&quot;sDICNAME&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;node&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;type&quot;&gt;ASC|DESC&lt;/param&gt;/// &lt;returns&gt;Dictionary&lt;int, string&gt;&lt;/returns&gt;public Dictionary&lt;int, string&gt; GetOrderDICITEM(string sDICNAME, XConnNode node,string type)&#123; Dictionary&lt;int, string&gt; dicReslut = new Dictionary&lt;int, string&gt;(); Dictionary&lt;int, string&gt; dicAsc = new Dictionary&lt;int, string&gt;(); string sSql = string.Format(&quot;SELECT A.ITEMVAL,A.ITEMNAME FROM XXXXX A WHERE A.DICNAME =&apos;&#123;0&#125;&apos;&quot;, sDICNAME); string strDBType = node.DBType[&quot;XXXX&quot;]; string strProviderName = node.ProviderName[&quot;XXXX&quot;]; string strConnString = node.ConnString[&quot;XXXX&quot;]; sSql = SqlHelper.ConvertSql(strDBType, sSql); try &#123; using (DbDataReader dr = DbHelper.ExecuteReader(strProviderName, strConnString, CommandType.Text, sSql.ToString())) &#123; if (dr.HasRows) &#123; while (dr.Read()) &#123; //先获取iITEMVAL的值 string sITEMVAL = dr[&quot;ITEMVAL&quot;] == DBNull.Value ? string.Empty : dr[&quot;ITEMVAL&quot;].ToString(); //然后将取出来的iITEMVAL进行格式强制转化 int iITEMVAL = Convert.ToInt32(sITEMVAL); //再获取ITEMNAME的值 string sITEMNAME = dr[&quot;ITEMNAME&quot;] == DBNull.Value ? string.Empty : dr[&quot;ITEMNAME&quot;].ToString(); //然后通过设置sITEMNAME为iITEMVAL下标赋值的方式，将对应的值存储到Dictionary中去 dicReslut[iITEMVAL] = sITEMNAME; &#125; &#125; &#125; if(type.Equals(&quot;ASC&quot;))&#123; //对于取出来的值进行升序，举个栗子，从1到10 dicAsc = dicReslut.OrderBy(o =&gt; o.Key).ToDictionary(o =&gt; o.Key, p =&gt; p.Value); &#125;else if(type.Equals(&quot;DESC&quot;))&#123; //对于取出来的值进行降序，举个栗子，从10到1 dicAsc = dicReslut.OrderByDescending(o =&gt; o.Key).ToDictionary(o =&gt; o.Key, p =&gt; p.Value); &#125; else&#123; //默认是进行升序展示，举个栗子，从1到10 dicAsc = dicReslut.OrderBy(o =&gt; o.Key).ToDictionary(o =&gt; o.Key, p =&gt; p.Value); &#125; &#125; catch (Exception ex) &#123; ILog log = new ErrorLog(); log.WriteLog(ex, &quot;GetDICITEM()&quot;, string.Format(&quot;获取XXX字典失败查询错误,查询显示流程SQL语句:&#123;0&#125;&quot;, sSql)); &#125; return dicAsc;&#125; 2.2 后台调用代码因为我是在一般处理文件(*.ashx.cs)中写的，然后在页面后台处理文件(*.aspx.cs)中，调用这个方法。 123456789101112131415161718192021222324252627282930313233343536373839//1-------------------------首先看一般处理文件(`*.ashx.cs`)的（class）//就是那个距离命名空间（namespace）最近的那个（class）名字//举个栗子，这个一般处理事件的（class）名就是（DEMO）namespace XX.XXX.XXXX&#123; /// &lt;summary&gt; /// DEMO 的摘要说明 /// &lt;/summary&gt; public class DEMO &#123; &#125;&#125;//2-------------------------然后在页面后台处理文件(`*.aspx.cs`)中，先new一个一般处理事件的实例，然后就可以愉快的调用了//就以上文一般处理事件的（class）名为（DEMO）的举个栗子public void insertXXXX() &#123; //先获取方法需要的参数， string strDICNAME = &quot;测试用例&quot;;//获取字典的名字 XConnNode node = XConnNode.CreateNode();//获取连接节点 //实例化一般处理事件对象，请注意一定要是上文方法体中对应的class名字 DEMO aDEMO = new DEMO(); Dictionary&lt;int, string&gt; dicCSYL = aDEMO.GetDICITEM(strDICNAME, node); string strVar = String.Empty; if (dicCSYL.Count &gt; 0) &#123; //请注意这个时候item的类一定要是KeyValuePair，其中尖角对中的数据类型一定要和一般处理事件方法体中`Dictionary`的尖角对中的数据类型保持一致 foreach (KeyValuePair&lt;int, string&gt; item in dicCSYL) &#123; strVar += &quot;HELLO &quot; + item.Value + &quot;,YOU ARE THE&quot; + item.Key + &quot;\\n&quot;; &#125; this.divXXX.InnerHtml = strVar; &#125;&#125;//然后页面上就可以愉快的显示相关信息啦，啦啦啦啦啦。 3 思考探索3.1 原始数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace XX.XXX.XXXX&#123; /// &lt;summary&gt; /// DEMO 的摘要说明 /// &lt;/summary&gt; public class DEMO &#123; /// &lt;summary&gt; /// 添加用户询问内容 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public Dictionary&lt;int, DEMOClass&gt; getDEMO() &#123; DEMOClass demo1 = new DEMOClass(); demo1.NAME = &quot;HELLO1&quot;; demo1.AGE = 20; demo1.WAGES = 20000; demo1.EXPER = 1.5; DEMOClass demo2 = new DEMOClass(); demo2.NAME = &quot;HELLO2&quot;; demo2.AGE = 30; demo2.WAGES = 30000; demo2.EXPER = 5.5; DEMOClass demo3 = new DEMOClass(); demo3.NAME = &quot;HELLO3&quot;; demo3.AGE = 40; demo3.WAGES = 40000; demo3.EXPER = 10.5; DEMOClass demo4 = new DEMOClass(); demo4.NAME = &quot;HELLO4&quot;; demo4.AGE = 50; demo4.WAGES = 50000; demo4.EXPER = 15.5; Dictionary&lt;int, DEMOClass&gt; dicDEMO = new Dictionary&lt;int, DEMOClass&gt;(); //先保证插入的数据是乱序的 dicDEMO.Add(3, demo1); dicDEMO.Add(1, demo2); dicDEMO.Add(2, demo3); dicDEMO.Add(4, demo4); return dicDEMO; &#125; public class DEMOClass &#123; /// &lt;summary&gt; /// 姓名 /// &lt;/summary&gt; public string NAME &#123; get; set; &#125; /// &lt;summary&gt; /// 年龄 /// &lt;/summary&gt; public int AGE &#123; get; set; &#125; /// &lt;summary&gt; /// 薪水 /// &lt;/summary&gt; public string WAGES &#123; get; set; &#125; /// &lt;summary&gt; /// 工作经验 /// &lt;/summary&gt; public double EXPER &#123; get; set; &#125; &#125; &#125;&#125; 3.2 通过自定义字段进行排序 关键语句 排序可以通过默认Dictionary初始化的序号o =&gt; o.Key进行排序，但是，还可以通过自定义属性o =&gt; o.Value.AGE进行排序 123456789101112131415161718192021/// &lt;summary&gt;/// 通过自定义的字段进行排序/// &lt;/summary&gt;/// &lt;param name=&quot;type&quot;&gt;ASC|DESC&lt;/param&gt;public Dictionary&lt;int, DEMOClass&gt; GetCostomerData(string type) &#123; //先获取方法测试的数据 Dictionary&lt;int, DEMOClass&gt; dicCSYL = getDEMO(); Dictionary&lt;int, DEMOClass&gt; dicOrder = new Dictionary&lt;int, DEMOClass&gt;(); if(type.Equals(&quot;ASC&quot;))&#123; //对于取出来的值进行升序，举个栗子，从1到10 dicOrder = dicCSYL.OrderBy(o =&gt; o.Value.AGE).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125;else if(type.Equals(&quot;DESC&quot;))&#123; //对于取出来的值进行降序，举个栗子，从10到1 dicOrder = ddicCSYL.OrderByDescending(o =&gt; o.Value.AGE).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125; else&#123; //默认是进行升序展示，举个栗子，从1到10 dicOrder = dicCSYL.OrderBy(o =&gt; o.Value.AGE).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125; retrun dicOrder;&#125; 3.2 通过多条件进行排序 关键语句 排序可以通过默认Dictionary可以通过自定义属性o =&gt; o.Value.AGE进行排序之后，还可以通过o =&gt; o.Value.EXPER进行再次排序。 1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// 通过两个字段进行综合排序/// &lt;/summary&gt;/// &lt;param name=&quot;ftype&quot;&gt;第一个字段的排序规则 ASC|DESC&lt;/param&gt;/// &lt;param name=&quot;stype&quot;&gt;第二个字段的排序规则 ASC|DESC&lt;/param&gt;public Dictionary&lt;int, DEMOClass&gt; GetMultipleOrderData(string ftype,string stype) &#123; //先获取方法测试的数据 Dictionary&lt;int, DEMOClass&gt; dicCSYL = getDEMO(); Dictionary&lt;int, DEMOClass&gt; dicOrder = new Dictionary&lt;int, DEMOClass&gt;(); if(ftype.Equals(&quot;ASC&quot;))&#123; if(stype.Equals(&quot;ASC&quot;))&#123; //先通过年龄进行升序，然后通过工作经验降序 dicOrder = dicCSYL.OrderBy(o =&gt; o.Value.AGE).ThenBy(o =&gt; o.Value.EXPER).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125;else if(stype.Equals(&quot;DESC&quot;))&#123; //先通过年龄进行升序，然后通过工作经验升序 dicOrder = dicCSYL.OrderBy(o =&gt; o.Value.AGE).ThenByDescending(o =&gt; o.Value.EXPER).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125;else&#123; //如果第二个类型填写错误 默认先通过年龄进行升序，然后通过工作经验升序 dicOrder = dicCSYL.OrderBy(o =&gt; o.Value.AGE).ThenBy(o =&gt; o.Value.EXPER).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125; &#125;else if(ftype.Equals(&quot;DESC&quot;))&#123; if(stype.Equals(&quot;ASC&quot;))&#123; //先通过年龄进行降序，然后通过工作经验升序 dicOrder = dicCSYL.OrderByDescending(o =&gt; o.Value.AGE).ThenBy(o =&gt; o.Value.EXPER).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125;else if(stype.Equals(&quot;DESC&quot;))&#123; //先通过年龄进行降序，然后通过工作经验降序 dicOrder = dicCSYL.OrderByDescending(o =&gt; o.Value.AGE).ThenByDescending(o =&gt; o.Value.EXPER).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125;else&#123; //如果第二个类型填写错误 默认先通过年龄进行降序，然后通过工作经验升序 dicOrder = dicCSYL.OrderByDescending(o =&gt; o.Value.AGE).ThenBy(o =&gt; o.Value.EXPER).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125; &#125;else&#123; //如果两个类型都填写错误 //默认 先通过年龄进行升序，然后通过工作经验升序 dicOrder = dicCSYL.OrderBy(o =&gt; o.Value.AGE).ThenBy(o =&gt; o.Value.EXPER).ToDictionary(p=&gt;p.Key,o=&gt;o.Value); &#125; retrun dicOrder;&#125; 4 总结如果在数据库数据中通过SQL语句中多层ORDER BY xx DESC, xxx DESC,....得出的结果值是正确的，那么最好是在SQL中就写好，避免取出数据之后再排序，这样逻辑很累赘。 但是如果通过多层ORDER BY xx DESC, xxx DESC,....得出的结果值不是正确的，就像我上文中，数据库中某个字段是NVARCHAR2()、VARCHAR2()和TEXT()等等字符串数据类型，只能在取出来数据之后再转成int或者double等数据类型再进行排序操作，那么Dictionary这排序方法就很实用。 12//举个栗子dicXXX.OrderBy(o =&gt; o.Value.X).ThenBy(o =&gt; o.Value.XX).ThenByDescending(o =&gt; o.Value.XXX).ThenBy(o =&gt; o.Value.XXXX)......ToDictionary(p=&gt;p.Key,o=&gt;o.Value); 虽然这个排序方法可以无限循环下去，但是从实际情况下，感觉这个在只有一两个排序条件的时候效率比较高，但是在有多个排序条件的时候，这个效率就感觉一般了。","tags":[{"name":".NET","slug":"NET","permalink":"https://mowatermelon.github.io/tags/NET/"},{"name":"Dictionary","slug":"Dictionary","permalink":"https://mowatermelon.github.io/tags/Dictionary/"},{"name":"OrderBy","slug":"OrderBy","permalink":"https://mowatermelon.github.io/tags/OrderBy/"},{"name":"OrderByDescending","slug":"OrderByDescending","permalink":"https://mowatermelon.github.io/tags/OrderByDescending/"}]},{"title":"西瓜有话说之Js对象学习强制类型转换篇","date":"2017-10-20T16:00:00.000Z","path":"2017/10/21/js-Thinking-object-instanceof/","text":"1 js中强制类型转换在 JavaScript 中，大多数事物都是对象, 从作为核心功能的字符串和数组，到建立在 JavaScript 之上的浏览器 API。今天主要是学习六大基本对象数据类型之间的强制类型转化，将其他类型的对象实例转化成规定的`数据对象类型。 2 名词字典 本文中出现变量名词的解释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var oo = new Object();var oBool = new Boolean(true);var oNum = new Number(68);var oString = new String(\"hello world\");var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date();var ooo = Object(oo);var ooString = Object(oString);var ooBool = Object(oBool);var ooNum = Object(oNum);var ooArray = Object(oArray);var ooDate = Object(oDate);var soo = String(oo);var soString = String(oString);var soBool = String(oBool);var soNum = String(oNum);var soArray = String(oArray);var soDate = String(oDate);var boo = Boolean(oo);var boString = Boolean(oString);var boBool = Boolean(oBool);var boNum = Boolean(oNum);var boArray = Boolean(oArray);var boDate = Boolean(oDate);var noo = Number(oo);var noString = Number(oString);var noBool = Number(oBool);var noNum = Number(oNum);var noArray = Number(oArray);var noDate = Number(oDate);var aoo = Array(oo);var aoString = Array(oString);var aoBool = Array(oBool);var aoNum = Array(oNum);var aoArray = Array(oArray);var aoDate = Array(oDate);var doo = Date(oo);var doString = Date(oString);var doBool = Date(oBool);var doNum = Date(oNum);var doArray = Date(oArray);var doDate = Date(oDate);function demoo()&#123;&#125; 变量名 含义 举例 objectName 相关对象类型名称 就像上面js代码中Object,Boolean,Number,String,Array,Date varName 相关对象类型实例化后的变量名 就像上面js代码中oo,oBool,oNum,oString,oArray,oDate param1,param2,param3,…,paramN 函数中需要传入第一个到第N个的参数值 就像上面js代码中true,68,hello world functionName 函数名称 就像上文的demoo 3 varName转换前的信息3.1 打印原本相关数据 原始值 实例名 原始值 使用方法 oo {} oo.constructor oBool [Boolean: true] oBool.constructor oNum [Number: 68] oNum.constructor oString [String: ‘hello world’] oString.constructor oArray [ ‘demo’, ‘melon’, ‘water’ ] oArray.constructor oDate 2017-11-18T14:01:15.443Z oDate.constructor constructor 实例名 构造体 使用方法 oo [Function: Object] oo.constructor oBool [Function: Boolean] oBool.constructor oNum [Function: Number] oNum.constructor oString [Function: String] oString.constructor oArray [Function: Array] oArray.constructor oDate [Function: Date] oDate.constructor proto 实例名 默认值 使用方法 oo {} oo.__proto__ oBool [Boolean: false] oBool.__proto__ oNumber [Number: 0] oNum.__proto__ oString [String: ‘’] oString.__proto__ oArray [] oArray.__proto__ oDate Date {} oDate.__proto__ 实例对象原型链中是否包含Object的原型链 实例名 属性值 使用方法 oo true oo instanceof Object oBool true oBool instanceof Object oNumber true oNum instanceof Object oString true oString instanceof Object oArray true oArray instanceof Object oDate true oDate instanceof Object 实例对象原型链中是否包含String的原型链 实例名 属性值 使用方法 oo false oo instanceof String oBool false oBool instanceof String oNumber false oNum instanceof String oString true oString instanceof String oArray false oArray instanceof String oDate false oDate instanceof String 实例对象原型链中是否包含Boolean的原型链 实例名 属性值 使用方法 oo false oo instanceof Boolean oBool true oBool instanceof Boolean oNumber false oNum instanceof Boolean oString false oString instanceof Boolean oArray false oArray instanceof Boolean oDate false oDate instanceof Boolean 实例对象原型链中是否包含Number的原型链 实例名 属性值 使用方法 oo false oo instanceof Number oBool false oBool instanceof Number oNumber true oNum instanceof Number oString false oString instanceof Number oArray false oArray instanceof Number oDate false oDate instanceof Number 实例对象原型链中是否包含Array的原型链 实例名 属性值 使用方法 oo false oo instanceof Array oBool false oBool instanceof Array oNumber false oNum instanceof Array oString false oString instanceof Array oArray true oArray instanceof Array oDate false oDate instanceof Array 实例对象原型链中是否包含Date的原型链 实例名 属性值 使用方法 oo false oo instanceof Date oBool false oBool instanceof Date oNumber false oNum instanceof Date oString false oString instanceof Date oArray false oArray instanceof Date oDate true oDate instanceof Date 3.2 强制类型转换列表 方法名 解释 使用方法 Object 将其他类型的对象转换成Object类型对象 Object(varName) String 将其他类型的对象转换成String类型对象 String(varName) Boolean 将其他类型的对象转换成Boolean类型对象 Boolean(varName) Number 将其他类型的对象转换成Number类型对象 Number(varName) Array 将其他类型的对象转换成Array类型对象 Array(varName) Date 将其他类型的对象转换成Date类型对象 Date(varName) 3.3 instanceof用法 语法 1object instanceof constructor 参数 @param1 object 要检测的对象. @param2 constructor 某个构造函数 描述 instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 注意事项 请注意方法接受传入的构造体包括六个数据对象类型名，还有函数方法名，如果传入其他则会报错，比如如果传入varName，会报错Expecting a function in instanceof check, but got #&lt;C&gt;。 五大基本数据类型（null，undefined，String，Number，Boolean），即隐式声明变量，没有通过new关键字或者强制类型转换的变量，默认的原型链是未定义的 通过new关键词实例化functionName的时候，使用instanceof检测是否包含object原型链会返回true。 objectName instanceof functionName的值为false，不代表functionName instanceof objectName的值也为false 存在父子关系的两个对象或者函数，实例化子对象或着子方法之后，在没有修改父级和子级的原型链前提下，使用instanceof检测子级或者父级的对象或者方法的时候，都会返回true。 需要注意的是，如果表达式 varName instanceof functionName 返回true，则并不意味着该表达式会永远返回true。 因为functionName.prototype属性的值有可能会改变，改变之后的值很有可能不存在于varName的原型链上，这时原表达式的值就会成为false。 另外一种情况下，原表达式的值也会改变，就是改变对象varName的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的__proto__魔法属性，是可以实现的，比如执行varName.__proto__ = {}之后，varName instanceof functionName就会返回false了。 4 强制转换结果4.1 Object强制转换 原始值 实例名 原始值 使用方法 ooo {} ooo.constructor ooBool [Boolean: true] ooBool.constructor ooNum [Number: 68] ooNum.constructor ooString [String: ‘hello world’] ooString.constructor ooArray [ ‘demo’, ‘melon’, ‘water’ ] ooArray.constructor ooDate 2017-11-18T14:01:15.443Z ooDate.constructor constructor 实例名 构造体 使用方法 ooo [Function: Object] ooo.constructor ooBool [Function: Boolean] ooBool.constructor ooNum [Function: Number] ooNum.constructor ooString [Function: String] ooString.constructor ooArray [Function: Array] ooArray.constructor ooDate [Function: Date] ooDate.constructor proto 实例名 默认值 使用方法 ooo {} ooo.__proto__ ooBool [Boolean: false] ooBool.__proto__ ooNumber [Number: 0] ooNum.__proto__ ooString [String: ‘’] ooString.__proto__ ooArray [] ooArray.__proto__ ooDate Date {} ooDate.__proto__ 实例对象原型链中是否包含Object的原型链 实例名 属性值 使用方法 ooo true ooo instanceof Object ooBool true ooBool instanceof Object ooNumber true ooNum instanceof Object ooString true ooString instanceof Object ooArray true ooArray instanceof Object ooDate true ooDate instanceof Object 实例对象原型链中是否包含String的原型链 实例名 属性值 使用方法 ooo false ooo instanceof String ooBool false ooBool instanceof String ooNumber false ooNum instanceof String ooString true ooString instanceof String ooArray false ooArray instanceof String ooDate false ooDate instanceof String 实例对象原型链中是否包含Boolean的原型链 实例名 属性值 使用方法 ooo false ooo instanceof Boolean ooBool true ooBool instanceof Boolean ooNumber false ooNum instanceof Boolean ooString false ooString instanceof Boolean ooArray false ooArray instanceof Boolean ooDate false ooDate instanceof Boolean 实例对象原型链中是否包含Number的原型链 实例名 属性值 使用方法 ooo false ooo instanceof Number ooBool false ooBool instanceof Number ooNumber true ooNum instanceof Number ooString false ooString instanceof Number ooArray false ooArray instanceof Number ooDate false ooDate instanceof Number 实例对象原型链中是否包含Array的原型链 实例名 属性值 使用方法 ooo false ooo instanceof Array ooBool false ooBool instanceof Array ooNumber false ooNum instanceof Array ooString false ooString instanceof Array ooArray true ooArray instanceof Array ooDate false ooDate instanceof Array 实例对象原型链中是否包含Date的原型链 实例名 属性值 使用方法 ooo false ooo instanceof Date ooBool false ooBool instanceof Date ooNumber false ooNum instanceof Date ooString false ooString instanceof Date ooArray false ooArray instanceof Date ooDate true ooDate instanceof Date 4.2 String强制转换 原始值 实例名 原始值 使用方法 soo [object Object] soo.constructor soBool true soBool.constructor soNum 68 soNum.constructor soString hello world soString.constructor soArray demo,melon,water soArray.constructor soDate Sat Nov 18 2017 22:01:15 GMT+0800 (CST) soDate.constructor constructor 实例名 构造体 使用方法 soo [Function: String] soo.constructor soBool [Function: String] soBool.constructor soNum [Function: String] soNum.constructor soString [Function: String] soString.constructor soArray [Function: String] soArray.constructor soDate [Function: String] soDate.constructor proto 实例名 默认值 使用方法 soo [String: ‘’] soo.__proto__ soBool [String: ‘’] soBool.__proto__ soNumber [String: ‘’] soNum.__proto__ soString [String: ‘’] soString.__proto__ soArray [String: ‘’] soArray.__proto__ soDate [String: ‘’] soDate.__proto__ 实例对象原型链中是否包含Object的原型链 实例名 属性值 使用方法 soo false soo instanceof Object soBool false soBool instanceof Object soNumber false soNum instanceof Object soString false soString instanceof Object soArray false soArray instanceof Object soDate false soDate instanceof Object 实例对象原型链中是否包含String的原型链 实例名 属性值 使用方法 soo false soo instanceof String soBool false soBool instanceof String soNumber false soNum instanceof String soString false soString instanceof String soArray false soArray instanceof String soDate false soDate instanceof String 实例对象原型链中是否包含Boolean的原型链 实例名 属性值 使用方法 soo false soo instanceof Boolean soBool false soBool instanceof Boolean soNumber false soNum instanceof Boolean soString false soString instanceof Boolean soArray false soArray instanceof Boolean soDate false soDate instanceof Boolean 实例对象原型链中是否包含Number的原型链 实例名 属性值 使用方法 soo false soo instanceof Number soBool false soBool instanceof Number soNumber false soNum instanceof Number soString false soString instanceof Number soArray false soArray instanceof Number soDate false soDate instanceof Number 实例对象原型链中是否包含Array的原型链 实例名 属性值 使用方法 soo false soo instanceof Array soBool false soBool instanceof Array soNumber false soNum instanceof Array soString false soString instanceof Array soArray false soArray instanceof Array soDate false soDate instanceof Array 实例对象原型链中是否包含Date的原型链 实例名 属性值 使用方法 soo false soo instanceof Date soBool false soBool instanceof Date soNumber false soNum instanceof Date soString false soString instanceof Date soArray false soArray instanceof Date soDate false soDate instanceof Date 4.3 Boolean强制转换 原始值 实例名 原始值 使用方法 boo true boo.constructor boBool true boBool.constructor boNum true boNum.constructor boString true boString.constructor boArray true boArray.constructor boDate true boDate.constructor constructor 实例名 构造体 使用方法 boo [Function: Boolean] boo.constructor boBool [Function: Boolean] boBool.constructor boNum [Function: Boolean] boNum.constructor boString [Function: Boolean] boString.constructor boArray [Function: Boolean] boArray.constructor boDate [Function: Boolean] boDate.constructor proto 实例名 默认值 使用方法 boo [Boolean: false] boo.__proto__ boBool [Boolean: false] boBool.__proto__ boNumber [Boolean: false] boNum.__proto__ boString [Boolean: false] bobString.__proto__ boArray [Boolean: false] boArray.__proto__ boDate [Boolean: false] boDate.__proto__ 实例对象原型链中是否包含Object的原型链 实例名 属性值 使用方法 boo false boo instanceof Object boBool false boBool instanceof Object boNumber false boNum instanceof Object boString false boString instanceof Object boArray false boArray instanceof Object boDate false boDate instanceof Object 实例对象原型链中是否包含String的原型链 实例名 属性值 使用方法 boo false boo instanceof String boBool false boBool instanceof String boNumber false boNum instanceof String boString false boString instanceof String boArray false boArray instanceof String boDate false boDate instanceof String 实例对象原型链中是否包含Boolean的原型链 实例名 属性值 使用方法 boo false boo instanceof Boolean boBool false boBool instanceof Boolean boNumber false boNum instanceof Boolean boString false boString instanceof Boolean boArray false boArray instanceof Boolean boDate false boDate instanceof Boolean 实例对象原型链中是否包含Number的原型链 实例名 属性值 使用方法 boo false boo instanceof Number boBool false boBool instanceof Number boNumber false boNum instanceof Number boString false boString instanceof Number boArray false boArray instanceof Number boDate false boDate instanceof Number 实例对象原型链中是否包含Array的原型链 实例名 属性值 使用方法 boo false boo instanceof Array boBool false boBool instanceof Array boNumber false boNum instanceof Array boString false obString instanceof Array boArray false boArray instanceof Array boDate false boDate instanceof Array 实例对象原型链中是否包含Date的原型链 实例名 属性值 使用方法 boo false boo instanceof Date boBool false boBool instanceof Date boNumber false boNum instanceof Date boString false boString instanceof Date boArray false boArray instanceof Date boDate false boDate instanceof Date 4.4 Number强制转换 原始值 实例名 原始值 使用方法 noo NaN noo.constructor noBool 1 noBool.constructor noNum 68 noNum.constructor noString NaN noString.constructor noArray NaN noArray.constructor noDate 1511022672428 noDate.constructor constructor 实例名 构造体 使用方法 noo [Function: Number] noo.constructor noBool [Function: Number] noBool.constructor noNum [Function: Number] noNum.constructor noString [Function: Number] noString.constructor noArray [Function: Number] noArray.constructor noDate [Function: Number] noDate.constructor proto 实例名 默认值 使用方法 noo [Number: 0] noo.__proto__ noBool [Number: 0] noBool.__proto__ noNumber [Number: 0] noNum.__proto__ noString [Number: 0] noString.__proto__ noArray [Number: 0] noArray.__proto__ noDate [Number: 0] noDate.__proto__ 实例对象原型链中是否包含Object的原型链 实例名 属性值 使用方法 noo false noo instanceof Object noBool false noBool instanceof Object noNumber false noNum instanceof Object noString false noString instanceof Object noArray false noArray instanceof Object noDate false noDate instanceof Object 实例对象原型链中是否包含String的原型链 实例名 属性值 使用方法 noo false noo instanceof String noBool false noBool instanceof String noNumber false noNum instanceof String noString false noString instanceof String noArray false noArray instanceof String noDate false noDate instanceof String 实例对象原型链中是否包含Boolean的原型链 实例名 属性值 使用方法 noo false noo instanceof Boolean noBool false noBool instanceof Boolean noNumber false noNum instanceof Boolean noString false noString instanceof Boolean noArray false noArray instanceof Boolean noDate false noDate instanceof Boolean 实例对象原型链中是否包含Number的原型链 实例名 属性值 使用方法 noo false noo instanceof Number noBool false noBool instanceof Number noNumber false noNum instanceof Number noString false noString instanceof Number noArray false noArray instanceof Number noDate false noDate instanceof Number 实例对象原型链中是否包含Array的原型链 实例名 属性值 使用方法 noo false noo instanceof Array noBool false noBool instanceof Array noNumber false noNum instanceof Array noString false noString instanceof Array noArray false noArray instanceof Array noDate false noDate instanceof Array 实例对象原型链中是否包含Date的原型链 实例名 属性值 使用方法 noo false noo instanceof Date noBool false noBool instanceof Date noNumber false noNum instanceof Date noString false noString instanceof Date noArray false noArray instanceof Date noDate false noDate instanceof Date 4.5 Array强制转换 原始值 实例名 原始值 使用方法 aoo [ {} ] aoo.constructor aoBool [ [Boolean: true] ] aoBool.constructor aoNum [ [Number: 68] ] aoNum.constructor aoString [ [String: ‘hello world’] ] aoString.constructor aoArray [ [ ‘demo’, ‘melon’, ‘water’ ] ] aoArray.constructor aoDate [ 2017-11-18T16:35:16.315Z ] aoDate.constructor constructor 实例名 构造体 使用方法 aoo [Function: Array] aoo.constructor aoBool [Function: Array] aoBool.constructor aoNum [Function: Array] aoNum.constructor aoString [Function: Array] aoString.constructor aoArray [Function: Array] aoArray.constructor aoDate [Function: Array] aoDate.constructor proto 实例名 默认值 使用方法 aoo [] aoo.__proto__ aoBool [] aoBool.__proto__ aoNumber [] aoNum.__proto__ aoString [] aoString.__proto__ aoArray [] aoArray.__proto__ aoDate [] aoDate.__proto__ 实例对象原型链中是否包含Object的原型链 实例名 属性值 使用方法 aoo true aoo instanceof Object aoBool true aoBool instanceof Object aoNumber true aoNum instanceof Object aoString true aoString instanceof Object aoArray true aoArray instanceof Object aoDate true aoDate instanceof Object 实例对象原型链中是否包含String的原型链 实例名 属性值 使用方法 aoo false aoo instanceof String aoBool false aoBool instanceof String aoNumber false aoNum instanceof String aoString false aoString instanceof String aoArray false aoArray instanceof String aoDate false aoDate instanceof String 实例对象原型链中是否包含Boolean的原型链 实例名 属性值 使用方法 aoo false aoo instanceof Boolean aoBool false aoBool instanceof Boolean aoNumber false aoNum instanceof Boolean aoString false aoString instanceof Boolean aoArray false aoArray instanceof Boolean aoDate false aoDate instanceof Boolean 实例对象原型链中是否包含Number的原型链 实例名 属性值 使用方法 aoo false aoo instanceof Number aoBool false aoBool instanceof Number aoNumber false aoNum instanceof Number aoString false aoString instanceof Number aoArray false aoArray instanceof Number aoDate false aoDate instanceof Number 实例对象原型链中是否包含Array的原型链 实例名 属性值 使用方法 aoo true aoo instanceof Array aoBool true aoBool instanceof Array aoNumber true aoNum instanceof Array aoString true aoString instanceof Array aoArray true aoArray instanceof Array aoDate true aoDate instanceof Array 实例对象原型链中是否包含Date的原型链 实例名 属性值 使用方法 aoo false aoo instanceof Date aoBool false aoBool instanceof Date aoNumber false aoNum instanceof Date aoString false aoString instanceof Date aoArray false aoArray instanceof Date aoDate false aoDate instanceof Date 4.6 Date强制转换 原始值 实例名 原始值 使用方法 doo Sun Nov 19 2017 01:39:06 GMT+0800 (CST) doo.constructor doBool Sun Nov 19 2017 01:39:06 GMT+0800 (CST) doBool.constructor doNum Sun Nov 19 2017 01:39:06 GMT+0800 (CST) doNum.constructor doString Sun Nov 19 2017 01:39:06 GMT+0800 (CST) doString.constructor doArray Sun Nov 19 2017 01:39:06 GMT+0800 (CST) doArray.constructor doDate Sun Nov 19 2017 01:39:06 GMT+0800 (CST) doDate.constructor constructor 实例名 构造体 使用方法 doo [Function: String] doo.constructor doBool [Function: String] doBool.constructor doNum [Function: String] doNum.constructor doString [Function: String] doString.constructor doArray [Function: String] doArray.constructor doDate [Function: String] doDate.constructor proto 实例名 默认值 使用方法 doo [String: ‘’] doo.__proto__ doBool [String: ‘’] doBool.__proto__ doNumber [String: ‘’] doNum.__proto__ doString [String: ‘’] doString.__proto__ doArray [String: ‘’] doArray.__proto__ doDate [String: ‘’] doDate.__proto__ 实例对象原型链中是否包含Object的原型链 实例名 属性值 使用方法 doo false doo instanceof Object doBool false doBool instanceof Object doNumber false doNum instanceof Object doString false doString instanceof Object doArray false doArray instanceof Object doDate false doDate instanceof Object 实例对象原型链中是否包含String的原型链 实例名 属性值 使用方法 doo false doo instanceof String doBool false doBool instanceof String doNumber false doNum instanceof String doString false doString instanceof String doArray false doArray instanceof String doDate false doDate instanceof String 实例对象原型链中是否包含Boolean的原型链 实例名 属性值 使用方法 doo false doo instanceof Boolean doBool false doBool instanceof Boolean doNumber false doNum instanceof Boolean doString false doString instanceof Boolean doArray false doArray instanceof Boolean doDate false doDate instanceof Boolean 实例对象原型链中是否包含Number的原型链 实例名 属性值 使用方法 doo false doo instanceof Number doBool false doBool instanceof Number doNumber false doNum instanceof Number doString false doString instanceof Number doArray false doArray instanceof Number doDate false doDate instanceof Number 实例对象原型链中是否包含Array的原型链 实例名 属性值 使用方法 doo false doo instanceof Array doBool false doBool instanceof Array doNumber false doNum instanceof Array doString false doString instanceof Array doArray false doArray instanceof Array doDate false doDate instanceof Array 实例对象原型链中是否包含Date的原型链 实例名 属性值 使用方法 doo false doo instanceof Date doBool false doBool instanceof Date doNumber false doNum instanceof Date doString false doString instanceof Date doArray false doArray instanceof Date doDate false doDate instanceof Date 5 总结5.1 object 强制类型转换 不会所有修改对象内容 所有对象的__proto__也不会改变 所有对象的构造体也不会改变 所有对象的原型链都包含object的原型链 除此之外，所有对象的原型链判断都和非强制转换前一样，原本是什么构造体生成的，现在对哪个构造体原型链的值就为真，比如oNumber原本是实例化的Number对象，所以在判断原型链包含情况的时候，只会在判断时候包含Number构造体原型链的时候是true，对于剩下的四种构造体原型链判断，都是false。 5.2 String强制类型转换 所有对象的内容展示形式会有不同 原本object的展示为[object Object] 原本String的展示没有变化 原本Boolean的展示为字符串类型的boolean值 原本Number的展示为字符串类型的Number值 原本Array的展示为字符串类型的Array值，原数组中每个数值，都以逗号拼接起来 原本Date的展示为默认日期类型（显示了所有时间信息并且有时区之类） 所有对象的__proto__全部变成了[String: &#39;&#39;] 所有对象的构造体全部变成了[Function: String] 所有对象的原型链和六大数据类型的原型链都不匹配 5.3 Boolean强制类型转换 所有对象的内容都变成了true 所有对象的__proto__全部变成了[Boolean: false] 所有对象的构造体全部变成了[Function: Boolean] 所有对象的原型链和六大数据类型的原型链都不匹配 5.4 Number强制类型转换 所有对象的内容展示形式会有不同 原本object的展示为NaN 原本String的展示没有变化 原本Boolean的展示为1 原本Number的展示为68 原本Array的展示为NaN 原本Date的展示为1511022672428，当前日期（2017-11-18T16:31:12.428Z）对应的时间戳，当前日期距离1970年1月1日的毫秒数，时间戳/(10006060*24)，可以得出当前日期到1970年1月1日的天数。 所有对象的__proto__全部变成了[Number: 0] 所有对象的构造体全部变成了[Function: Number] 所有对象的原型链和六大数据类型的原型链都不匹配 5.5 Array强制类型转换 所有对象的内容展示形式会有不同，就是在原始内容外层套了一层中括号，比如 原本Array的内容为[ &#39;demo&#39;, &#39;melon&#39;, &#39;water&#39; ] ，转换之后成了[ [ &#39;demo&#39;, &#39;melon&#39;, &#39;water&#39; ] ] 所有对象的__proto__全部变成了[] 所有对象的构造体全部变成了[Function: Array] 所有对象的原型链都包含object的原型链和Array的原型链 所有对象的原型链和剩下的四个数据类型的原型链都不匹配 5.6 Date强制类型转换 所有对象的内容都变成了Sun Nov 19 2017 01:39:06 GMT+0800 (CST)默认日期类型（显示了所有时间信息并且有时区之类） 所有对象的__proto__全部变成了[String: &#39;&#39;] 所有对象的构造体全部变成了[Function: String] 所有对象的原型链和六大数据类型的原型链都不匹配 5.6 强制类型转换共同点 所有对象通过Object或Array类型强制转换之后，原型链上都可以找到object构造体原型链 所有对象通过String或Date类型强制转换之后，对象的__proto__都是[String: &#39;&#39;]，对象的构造体都变成了[Function: String]。 除了Object和Array类型强制转换之外，其他强制类型转换之后，所有对象的原型链和六大数据类型的原型链都不匹配 6 学习源码地址learnInstanceof","tags":[{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"},{"name":"instanceof","slug":"instanceof","permalink":"https://mowatermelon.github.io/tags/instanceof/"},{"name":"强制类型转换","slug":"强制类型转换","permalink":"https://mowatermelon.github.io/tags/强制类型转换/"}]},{"title":"西瓜有话说之Js对象学习初始篇","date":"2017-10-19T16:00:00.000Z","path":"2017/10/20/js-Thinking-object-init/","text":"1 js中何为对象在 JavaScript 中，大多数事物都是对象, 从作为核心功能的字符串和数组，到建立在 JavaScript 之上的浏览器 API。你甚至可以自己创建对象，将相关的函数和变量封装打包成便捷的数据容器。理解这种面向对象 (object-oriented, OO) 的特性对于进一步学习 JavaScript 语言知识是必不可少的。 引用类型通常叫做类（class），也就是说，遇到引用值，所处理的就是对象。 注意：从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现类这个词。ECMAScript 定义了对象定义，逻辑上等价于其他程序设计语言中的类。 对象是由 new 运算符加上要实例化的对象的名字创建的，一个对象是一个包含相关资料和功能的集体（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）。这种语法与 Java 语言的相似，不过当有不止一个参数时，ECMAScript 要求使用括号。 如果没有参数，括号可以省略，注意：尽管括号不是必需的，但是为了避免混乱，最好使用括号。 2 名词字典 本文中出现变量名词的解释 123456var oo = new Object();var oBool = new Boolean(true);var oNum = new Number(68);var oString = new String(\"hello world\");var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date(); 变量名 含义 举例 objectName 相关对象类型名称 就像上面js代码中Object,Boolean,Number,String,Array,Date varName 相关对象类型实例化后的变量名 就像上面js代码中oo,oBool,oNum,oString,oArray,oDate param1,param2,param3,…,paramN 函数中需要传入第一个到第N个的参数值 就像上面js代码中true,68,hello world 不推荐使用 该特性是非标准的，请尽量不要在生产环境中使用它。 如果下面属性和方法的描述中出现这五个字，意思最好不要使用这个属性或者这个方法。 已废弃 目前现行的几大主流浏览器都不支持了 如果下面属性和方法的描述中出现这三个字，意思你使用了这个一般会报错，或者直接返回undefined。 测试中 此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 如果下面属性和方法的描述中出现这三个字，意思你使用了这个不一定被所有浏览器都兼容，最好不要使用这个属性或者这个方法。 3 js中对象的公有属性 属性名 描述 使用方法 constructor 对创建对象的函数的引用（指针）。 varName.constructor proto 对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型。 varName.__proto__ constructor 对象名 属性值 使用方法 Object [Function: Object] oo.constructor Boolean [Function: Boolean] oBool.constructor Number [Function: Number] oNum.constructor String [Function: String] oString.constructor Array [Function: Array] oArray.constructor Date [Function: Date] oDate.constructor proto 对象名 属性值 使用方法 Object {} oo.__proto__ Boolean [Boolean: false] oBool.__proto__ Number [Number: 0] oNum.__proto__ String [String: ‘’] oString.__proto__ Array [] oArray.__proto__ Date Date {} oDate.__proto__ 4 js中对象的公有方法 方法名 描述 使用方法 typeof 判断该对象的类型，无论引用的是什么类型的对象，它都返回 object typeof(varName) instanceof 判断该对象的实例化原型是不是某个对象类型，返回值是true或false varName.instanceof(objectName) isPrototypeOf 判断该对象是否为另一个对象的原型，返回值是true或false。 varName.isPrototypeOf(objectName) propertyIsEnumerable 判断给定的属性是否可以用 for...in 语句进行枚举，返回值是true或false。 varName.propertyIsEnumerable() hasOwnProperty 判断对象是否有某个特定的属性，必须用字符串指定该属性，返回值是true或false。 varName.hasOwnProperty(param1) toString 返回对象的原始字符串表示 varName.toString(param1) toLocaleString 返回对象的值转化为本地原始字符串表示 varName.toLocaleString(param1) valueOf 返回最适合该对象的原始值。 varName.valueOf() 5 js中string和array类的公有方法 方法名 描述 使用方法 indexOf 返回某个指定的字符串值在字符串中首次出现的位置，对大小写敏感 varName.indexOf(param1,param2) lastIndexOf 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索，对大小写敏感。 varName.lastIndexOf(param1,param2) concat 连接两个或多个字符串，可以接受传入多个参数，字符串返回值是拼接之后变量值，数组返回的是插入值之后数组。 varName.concat(param1,param2,param3,…,paramN) slice 返回对应字符串或者数组中下标从param1到param2的的元素 varName.slice(param1,param2) 6 标准对象分类6.1 值属性这些全局属性返回一个简单的值；他们没有属性和方法。 Infinity NaN undefined null 字面量 6.2 函数属性这些全局函数 - 被称为全局而不是对象的函数 - 直接将其结果返回给调用者。 eval() uneval() 测试中 isFinite() isNaN() parseFloat() parseInt() decodeURI() decodeURIComponent() encodeURI() encodeURIComponent() escape() 已废弃 unescape() 已废弃 6.3 基本对象这些是所有其他对象所基于的基本对象。这包括表示一般对象，函数和错误的对象。 Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError 6.4 数字和日期这些是表示数字，日期和数学计算的基础对象。 Number Math Date 6.5 文本处理这些对象表示字符串并支持操作它们。 String RegExp 6.6 索引集合这些对象表示由索引值排序的数据集合。这包括（类型）数组和类数组构造器。 Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array 6.7 键的集合这些对象表示使用键的集合；这些包含按插入顺序迭代的元素。 Map Set WeakMap WeakSet 6.8 矢量集合SIMD 矢量数据类型可以把数据整合到一个序列中。 SIMD 不推荐使用 SIMD.Float32x4 不推荐使用 SIMD.Float64x2 不推荐使用 SIMD.Int8x16 不推荐使用 SIMD.Int16x8 不推荐使用 SIMD.Int32x4 不推荐使用 SIMD.Uint8x16 不推荐使用 SIMD.Uint16x8 不推荐使用 SIMD.Uint32x4 不推荐使用 SIMD.Bool8x16 不推荐使用 SIMD.Bool16x8 不推荐使用 SIMD.Bool32x4 不推荐使用 SIMD.Bool64x2 不推荐使用 6.9 结构化数据这些对象表示结构化数据缓冲区与使用 JSON 编码的数据进行交互。 ArrayBuffer SharedArrayBuffer 不推荐使用 Atomics 不推荐使用 DataView JSON 6.10 控制抽象对象 Promise Generator GeneratorFunction AsyncFunction 不推荐使用 6.11 反射 Reflect Proxy 6.12 国际化增加ECMAScript核心的语言相关功能。 Intl Intl.Collator Intl.DateTimeFormat Intl.NumberFormat 6.13 WebAssembly WebAssembly WebAssembly.Module WebAssembly.Instance WebAssembly.Memory WebAssembly.Table WebAssembly.CompileError WebAssembly.LinkError WebAssembly.RuntimeError 6.14 其他 arguments","tags":[{"name":"object","slug":"object","permalink":"https://mowatermelon.github.io/tags/object/"},{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"}]},{"title":".NET学习之文字转码","date":"2017-10-18T16:00:00.000Z","path":"2017/10/19/NET-Learning-code/","text":"最近项目中需要用到了附件图片查看审批功能，业务申请的时候图片默认是上传到FTP的，由于之前没有写过处理FTP的文件，我需要将图片的路径绑到插件中去，我原本思路是直接把FTP路径放进去，结果发现不行，我以为是路径中中文编码有问题，所以我试了各种编码转换，结果一个后台大哥和我说，处理FTP文件都是先在后台启动一个FTP服务，将文件在本地有一个备份，再将本地的文件路径返回到页面上去，可怜我犯傻了一天，试了各种编码。 再次验证了写逻辑代码，一定要清楚功能是在前台处理还是在后台处理，要不然容易出乱子，今天就是，我当时在浏览器中直接可以访问FTP协议路径下的文件，没有输入帐号密码之类的，所以我以为是页面局部标签渲染，也是可以直接访问这个路径，结果浪费了一天时间，想想也是，服务器中的文件不用帐号密码就可以直接访问和下载，文件安全性得不到保证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/// &lt;summary&gt;/// GB2312转换成UTF8/// &lt;/summary&gt;/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string gb2312_utf8(string text)&#123; //声明字符集 System.Text.Encoding utf8, gb2312; //gb2312 gb2312 = System.Text.Encoding.GetEncoding(&quot;gb2312&quot;); //utf8 utf8 = System.Text.Encoding.GetEncoding(&quot;utf-8&quot;); byte[] gb; gb = gb2312.GetBytes(text); gb = System.Text.Encoding.Convert(gb2312, utf8, gb); //返回转换后的字符 return utf8.GetString(gb);&#125;/// &lt;summary&gt;/// UTF8转换成GB2312/// &lt;/summary&gt;/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string utf8_gb2312(string text)&#123; //声明字符集 System.Text.Encoding utf8, gb2312; //utf8 utf8 = System.Text.Encoding.GetEncoding(&quot;utf-8&quot;); //gb2312 gb2312 = System.Text.Encoding.GetEncoding(&quot;gb2312&quot;); byte[] utf; utf = utf8.GetBytes(text); utf = System.Text.Encoding.Convert(utf8, gb2312, utf); //返回转换后的字符 return gb2312.GetString(utf);&#125;/// &lt;summary&gt;/// UTF8转换成gbk/// &lt;/summary&gt;/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string utf8_gbk(string text)&#123; //声明字符集 System.Text.Encoding utf8, gbk; //utf8 utf8 = System.Text.Encoding.GetEncoding(&quot;utf-8&quot;); //gb2312 gbk = System.Text.Encoding.GetEncoding(&quot;gbk&quot;); byte[] utf; utf = utf8.GetBytes(text); utf = System.Text.Encoding.Convert(utf8, gbk, utf); //返回转换后的字符 return gbk.GetString(utf);&#125; public static int Asc(string character) &#123; if (character.Length == 1) &#123; System.Text.ASCIIEncoding asciiEncoding = new System.Text.ASCIIEncoding(); int intAsciiCode = (int)asciiEncoding.GetBytes(character)[0]; return (intAsciiCode); &#125; else &#123; throw new Exception(&quot;Character is not valid.&quot;); &#125; &#125; //显示图片 private void GetFJImg(HttpContext context) &#123; if (!string.IsNullOrEmpty(sSQBH) &amp;&amp; !string.IsNullOrEmpty(sFJMC)) &#123; //定义FTP请求对象 FtpWebRequest reqFTP = null; //定义FTP响应对象 FtpWebResponse response = null; //FTP数据流 Stream ftpStream = null; MemoryStream outStream = new MemoryStream(); try &#123; if (string.IsNullOrEmpty(sFTPLJ)) &#123; Stream stream = new MemoryStream(byteFTPNR); int bufferSize = 2048; byte[] buffer = new byte[bufferSize]; int contentLen = stream.Read(buffer, 0, bufferSize); while (contentLen != 0) &#123; outStream.Write(buffer, 0, contentLen); contentLen = stream.Read(buffer, 0, bufferSize); &#125; stream.Close(); &#125; else &#123; //FTP模式 string filePath = string.Empty; string URL = ConfigurationManager.AppSettings[&quot;FtpAddr&quot;]; string username = ConfigurationManager.AppSettings[&quot;FtpUser&quot;]; string password = ConfigurationManager.AppSettings[&quot;FtpPwd&quot;]; filePath = &quot;ftp://&quot; + URL + &quot;/&quot; + sSQBH + &quot;/&quot; + sFJMC; reqFTP = (FtpWebRequest)FtpWebRequest.Create(new Uri(filePath)); reqFTP.Method = WebRequestMethods.Ftp.DownloadFile; reqFTP.UseBinary = true; reqFTP.Credentials = new NetworkCredential(username, password); response = (FtpWebResponse)reqFTP.GetResponse(); ftpStream = response.GetResponseStream(); int bufferSize = 2048; byte[] buffer = new byte[bufferSize]; int contentLen = ftpStream.Read(buffer, 0, bufferSize); while (contentLen != 0) &#123; outStream.Write(buffer, 0, contentLen); contentLen = ftpStream.Read(buffer, 0, bufferSize); &#125; ftpStream.Close(); &#125; context.Response.ContentType = &quot;image/GIF&quot;; context.Response.Cache.SetCacheability(HttpCacheability.Public); context.Response.BufferOutput = false; context.Response.BinaryWrite(outStream.ToArray()); context.Response.Flush(); &#125; catch (Exception ex) &#123; ILog log = new ErrorLog(this.GetType()); log.WriteLog(ex, &quot;GetFJImg获取图片信息出错!&quot;, ex.Message); &#125; finally &#123; if (response != null) &#123; response.Close(); &#125; if (ftpStream != null) &#123; ftpStream.Close(); &#125; &#125; &#125; &#125;","tags":[{"name":".NET","slug":"NET","permalink":"https://mowatermelon.github.io/tags/NET/"},{"name":"转码","slug":"转码","permalink":"https://mowatermelon.github.io/tags/转码/"}]},{"title":"西瓜有话说之Js简介","date":"2017-10-17T16:00:00.000Z","path":"2017/10/18/js-Learning-timeline/","text":"1 js产生原因在js诞生之前，大部分因特网用户还仅仅通过 28.8 kbit/s 的调制解调器连接到网络，网络访问条件可以说很恶劣，拨号上网速度之慢，每次与服务器进行数据交互都是对用户耐心的一次考验，但是这个时候的网页为了更好提供更多功能，已经变得相对复杂了，很多页面存在表单信息提交。 可是，当时所有的请求都是直接发送到服务器进行处理的，不管是数据验证还是实质的读取存储数据，很多情况下，用户由于不太清楚页面信息填写规则，把一些错误信息发送到后台，后台肯定不干啊，结果用户填完信息，等了半天，页面才出现一个错误提示，某某字段是必填项啊，你必须要填什么信息或者你填写的某某信息不太符合规范之类。 有点像你到外面超市买东西，你把要买的东西给收银员，收银员安静的看着你大半天，才说一句，亲你给的钱不够哦，这种体验是很不友好的，所以当网上冲浪越来越流行时，对于开发网页脚本语言的需求也逐渐增大，因为客户端能够先对发送的数据做一定基础验证，这样尽量保证对于服务器的每次请求能够更有效。 2 开始造轮子历史上第一个比较成熟的网络浏览器，就是1994年，网景公司（Netscape）发布的Navigator浏览器0.9版，虽然这个版本的浏览器只能用来浏览，仍然轰动一时。所以网景公司最先确定要开发一个网页脚本语言，至少让浏览器有一定与用户互动的能力。 网景公司当时有两个选择： 选择 解释 优势 采用现有的语言 比如Perl、Python、Tcl、Scheme等等，允许它们直接嵌入网页 有利于充分利用现有代码和程序员资源，推广起来比较容易 采用全新的语言 发明一种全新的语言 有利于开发出完全适用的语言，实现起来比较容易。 到底采用哪一个选择，网景公司内部争执不下，管理层一时难以下定决心。 就在这时，发生了另外一件大事：1995年Sun公司将Oak语言改名为Java，正式向市场推出。 Sun公司大肆宣传，许诺这种语言可以一次编写，到处运行（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。 网景公司动了心，决定与Sun公司结成联盟。它不仅允许Java程序以applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。 总之，当时的形势就是，网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。因此，Javascript后来就是网景和Sun两家公司一起携手推向市场的，这种语言被命名为“Java+script”并不是偶然的。 1995年5月，网景公司做出决策，未来的网页脚本语言必须看上去与Java足够相似，但是比Java简单，使得非专业的网页作者也能很快上手。这个决策实际上将Perl、Python、Tcl、Scheme等非面向对象编程的语言都排除在外了。 指定当时刚入职一个月的34岁的系统程序员Brendan Eich为这种简化版Java语言的设计师。 可是Brendan Eich的主要方向和兴趣是函数式编程，网景公司最初招聘他的目的，是研究将Scheme语言作为网页脚本语言的可能性，他对面向对象编程的Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。 由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。 总的来说，他的设计思路是这样的： 借鉴C语言的基本语法； 借鉴Java语言的数据类型和内存管理； 借鉴Scheme语言，将函数提升到第一等公民（first class）的地位； 借鉴Self语言，使用基于原型（prototype）的继承机制。 由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定，Javascript语言风格=（简化的）函数式编程+（简化的）面向对象编程 多年以后，Brendan Eich还是看不起Java。他说： 1Java（对Javascript）的影响，主要是把数据分成基本类型（primitive）和对象类型（object）两种，比如字符串和字符串对象，以及引入了Y2K问题，（这导致后来不得不添加了一个返回四位数年份的Date.getFullYear()函数。），这真是不幸啊。 作为设计者，他一点也不喜欢自己的这个把Java作为Javascript设计原型的产品 1与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：‘它的优秀之处并非原创，它的原创之处并不优秀。’（the part that is good is not original, and the part that is original is not good.) JavaScript 和 Java 的对比 JavaScript Java 面向对象。不区分对象类型。通过原型机制继承，任何对象的属性和方法均可以被动态添加。 基于类系统。分为类和实例，通过类层级的定义实现继承。不能动态增加对象或类的属性或方法。 变量类型不需要提前声明(动态类型)。 变量类型必须提前声明(静态类型)。 不能直接自动写入硬盘。 可以直接自动写入硬盘。 3 开发版本迭代最初定js的名字是LiveScript，想用于在1995年发行的Netscape Navigator 2.0，目的是在浏览器和服务器（本来要叫它 LiveWire）端使用它。但是在 Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript，目的是为了利用Java这个因特网时髦词汇。Netscape 的赌注最终得到回报，JavaScript从此变成了因特网的必备组件。 因为 JavaScript 1.0 如此成功，Netscape 在 Netscape Navigator 3.0中发布了 1.1 版。恰巧那个时候，微软决定进军浏览器，发布了 IE 3.0 并搭载了一个 JavaScript 的克隆版，叫做 JScript（这样命名是为了避免与 Netscape 潜在的许可纠纷）。微软步入 Web浏览器领域的这重要一步虽然令其声名狼藉，但也成为JavaScript语言发展过程中的重要一步。 在微软进入后，有 3 种不同的 JavaScript 版本同时存在：Netscape Navigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase。与 C 和其他编程语言不同的是，JavaScript 并没有一个标准来统一其语法或特性，而这 3 种不同的版本恰恰突出了这个问题。随着业界担心的增加，这个语言的标准化显然已经势在必行。 1997 年，JavaScript 1.1 作为一个草案提交给欧洲计算机制造商协会（ECMA）。第 39 技术委员会（TC39）被委派来标准化一个通用、跨平台、中立于厂商的脚本语言的语法和语义。由来自 Netscape、Sun、微软、Borland 和其他一些对脚本编程感兴趣的公司的程序员组成的 TC39 锤炼出了 ECMA-262，该标准定义了名为 ECMAScript 的全新脚本语言。 第二年，国际标准化组织及国际电工委员会（ISO/IEC）也采纳 ECMAScript 作为标准（ISO/IEC-16262）。从此，Web浏览器就开始努力（虽然有着不同的程度的成功和失败）将 ECMAScript 作为 JavaScript 实现的基础。 4 时间线 时间 解释 1906年 国际电工委员会（IEC）成立 1946 ISO国际标准组织成立 1961 欧洲计算机制造联合会（ECMA）成立 1994 Netscape Navigator 0.9发布 1995.5 js 1.0编写完成 1997 EMCAScript标准产生 1998 ISO及IEC采纳ECMAScript作为标准 1998.6 ECMAScript 2.0版发布 1999.12 ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。强大的正则表达式，更好的文字链处理，新的控制指令，异常处理，错误定义更加明确，数输出的格式化及其它改变 2007.10 ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。 2008.7 由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。 2009.12 ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。 2011.6 ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。 2013.3 ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。 2013.12 ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。 2015.6.17 ECMAScript 6发布正式版本，即ECMAScript 2015。 5 名词小课堂 名词 解释 Netscape 网景 Brendan Eich js之父 Y2K 2000年问题（Year 2000 Problem，简称Y2K），台湾称千禧虫危机，香港则常称为千年虫问题，是指由于计算机程序设计的一些问题，使得计算机在处理2000年1月1日以后的日期和时间时候，可能会出现不正确的操作，从而可能导致一些敏感的工业部门（比如电力，能源）和银行，政府等部门在2000年1月1日零点工作停顿甚至是发生灾难性的结果。 ECMA European Computer Manufactures Association的缩写，中文称欧洲计算机制造联合会。是1961年成立的旨在建立统一的电脑操作格式标准–包括程序语言和输入输出的组织。 TC39 ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。TC39的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。 ECMA-262 定义了ECMAScript支持的一套关键字，这些关键字标识了ECMAScript语句的开头和/或结尾。根据规定，关键字是保留的，不能用作变量名或函数名。 ISO 是International Organization for Standardization的简称，中文称国际标准化组织，是一个全球性的非政府组织，是国际标准化领域中一个十分重要的组织。ISO一来源于希腊语ISOS，即EQUAL——平等之意。中国是ISO的正式成员，代表中国参加ISO的国家机构是中国国家技术监督局(CSBTS） IEC 是International Electrotechnical Commission的简称，中文称国际电工委员会，它是世界上成立最早的国际性电工标准化机构，负责有关电气工程和电子工程领域中的国际标准化工作。","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"history","slug":"history","permalink":"https://mowatermelon.github.io/tags/history/"},{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"}]},{"title":"样式之使用Margin负值","date":"2017-10-16T16:00:00.000Z","path":"2017/10/17/css-learning-margin-negative/","text":"之前想的是如果要在一个盒子上加一个小的文字标签，首先会考虑到absolute，结果我今天做position整理的时候看了一下张鑫旭关于使用margin负值做文字标签，才发现用margin写，代码会很简洁。 但是前提是知道父盒子的宽度和高度，如果不知道宽度，而且父盒子不是内联元素，使用absolute很可能满天飞；如果是使用margin的解决办法的话不知道图片大小那真的就是一脸懵，一点一点的左移上移，感觉效率也没那么高。 还有可以结合overflow和margin负值来做图片轮播图，就不过多举例了。 更多测试案例 先放上html结构 12345678910111213141516&lt;div class=\"demo-absolute\"&gt; &lt;dt class=\"p-img\"&gt; &lt;a href=\"javascript:void(0)\"&gt; &lt;img src=\"https://static.bootcss.com/www/assets/img/jqueryapi.png?1510078115427\"/&gt; &lt;/a&gt; &lt;div class=\"b-price\"&gt;￥999.00&lt;/div&gt; &lt;/dt&gt;&lt;/div&gt;&lt;div class=\"demo-margin\"&gt; &lt;dt class=\"p-img\"&gt; &lt;a href=\"javascript:void(0)\"&gt; &lt;img src=\"https://static.bootcss.com/www/assets/img/jqueryapi.png?1510078115427\"/&gt;&gt; &lt;/a&gt; &lt;div class=\"price-box\"&gt;&lt;span class=\"b-price\"&gt;￥999.00&lt;/span&gt;&lt;/div&gt; &lt;/dt&gt;&lt;/div&gt; 然后放上两种样式解决思路 12345678910111213141516171819202122232425262728293031323334/*先放上主要共有样式*/a img &#123; border: 0 none; vertical-align: middle;&#125;dt &#123; height: 130px;&#125;.p-img &#123; margin: 5px 0;&#125;.b-price&#123; background: none repeat scroll 0 0 #4ad5ff; color: #fff; font-family: arial; font-weight: bold; line-height: 1.5; padding: 2px 5px;&#125;/*absolute 解决方案*/.demo-absolute dt &#123; position: relative; width: 300px;&#125;.demo-absolute .b-price &#123; position: absolute; top: 5px; left: 20px;&#125;/*margin 解决方案*/.demo-margin .t-r .price-box&#123; margin: -145px 0 0 221px;&#125;","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"margin_negative","slug":"margin-negative","permalink":"https://mowatermelon.github.io/tags/margin-negative/"}]},{"title":"西瓜有话说之Js动画面板折叠","date":"2017-10-15T16:00:00.000Z","path":"2017/10/16/js-Thinking-animate-panel/","text":"项目中需要用到面板折叠效果，但是不想用bootstrap的js和样式，所以需要自己写一个折叠动画 1 核心js逻辑123456789101112131415//加载面板动画 主要就是点击面板的header 然后面板进行折叠或展开function LoadPanel() &#123; $(\".panel-head\").click(function () &#123; var _this = $(this); if (_this.siblings(\".panel-body\").hasClass('hide')) &#123; _this.siblings(\".panel-body\").animate(&#123; \"height\": _this.attr(\"cheight\"), \"padding\": \"15px\" &#125;, 200).removeClass(\"hide\").children(\"div\").removeClass(\"hide\"); _this.children(\"icon\").html(\"一\"); &#125; else &#123; var tempH = _this.siblings(\".panel-body\").height() _this.attr(\"cheight\", tempH); _this.siblings(\".panel-body\").animate(&#123; \"height\": \"0\", \"padding\": \"0\" &#125;, 200).addClass(\"hide\").children(\"div\").addClass(\"hide\"); _this.children(\"icon\").html(\"十\"); &#125; &#125;);&#125; 2 完整页面代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,Chrome=1\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, minimum-scale=1.0, maximum-scale=1, user-scalable=no\" /&gt; &lt;meta http-equiv=\"Pragma\" content=\"no-cache\"/&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\"/&gt; &lt;meta http-equiv=\"Expires\" content=\"0\"/&gt; &lt;meta name=\"author\" content=\"WU EVA\" /&gt; &lt;title&gt;panel折叠动画&lt;/title&gt; &lt;style&gt; *&#123;margin:0; padding:0&#125; body&#123;overflow-x: hidden&#125; *, *:before, *:after &#123;-webkit-box-sizing: border-box;-moz-box-sizing: border-box;box-sizing: border-box;&#125; .clearfix:after,.clearfix:before&#123;display:table;content:\" \"&#125;.clearfix:after&#123;clear:both&#125; .panel-head&#123;height:40px; width:100%; background-color:#d9edf7; line-height:40px; color:#3a87ad;cursor:pointer;border-bottom: 1px solid #FFF; &#125; .panel-head h5&#123;text-align: left;display: inline-block;line-height: 16px;font-size: 16px;text-indent: 1em;&#125; .panel-head icon&#123;margin-right:20px;font-size:20px;font-weight:bolder;float: right;&#125; .panel-body&#123;padding: 15px;display: inline-table;width: 100%;&#125; .input-group-addon, .input-group-btn &#123; width: 1%; white-space: nowrap; vertical-align: middle; &#125; .input-group-addon:first-child&#123;border-right: 0;&#125; .input-group &#123;position: relative;display: table;border-collapse: separate;margin-bottom:1em;&#125; .input-group label&#123;word-spacing:0.8em;background-color:rgb(217, 237, 247);border: solid 1px RGB(160, 200, 250);display: table-cell;&#125; .input-group-addon &#123;padding: 6px 12px;font-size: 14px;font-weight: normal;line-height: 1;text-align: center;background-color: #eeeeee;border: 1px solid #cccccc;border-radius: 4px;&#125; .input-group-addon:first-child&#123;border-top-right-radius: 0;border-bottom-right-radius: 0;&#125; .input-group .form-control:last-child&#123;border-bottom-left-radius: 0;border-top-left-radius: 0;&#125; .form-control &#123;width: 100%;padding: 6px 0 6px 6px;font-size: 14px;line-height: 1.428571429;color: #555;vertical-align: middle;background-color: #ffffff;border: 1px solid RGB(160, 200, 250);border-radius: 4px;-webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);-webkit-transition: border-color ease-in-out 0.15s, box-shadow ease-in-out 0.15s;transition: border-color ease-in-out 0.15s, box-shadow ease-in-out 0.15s;display: table-cell;&#125; .form-control:focus &#123;border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6); box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);&#125; .m-l-r-0&#123;margin:0;&#125; .text-danger &#123;color:Red;&#125; .hide &#123; display: none !important; &#125; .show &#123; display: block !important; &#125; .col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9&#123;position:relative;padding-right:1.6%;min-height:1px&#125; .col-xs-12 &#123;width: 98%;&#125; @media (min-width: 768px) &#123;.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9&#123;float:left&#125;.col-sm-6 &#123;width: 48.25%;&#125;.col-sm-4 &#123;width: 31.65%;&#125;&#125; .form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control&#123;background-color:#eee;cursor:not-allowed&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"panel-group\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"panel-head\"&gt; &lt;h5&gt;面板01&lt;/h5&gt;&lt;icon&gt;一&lt;/icon&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT1\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框一&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT1\" /&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT2\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框二&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT2\" /&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT3\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框三&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT3\"/&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT4\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框四&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT4\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"panel-head\"&gt; &lt;h5&gt;面板02&lt;/h5&gt;&lt;icon&gt;一&lt;/icon&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT21\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框一&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT21\" /&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT22\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框二&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT22\" /&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT23\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框三&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT23\"/&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT24\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框四&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT24\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"panel-head\"&gt; &lt;h5&gt;面板03&lt;/h5&gt;&lt;icon&gt;一&lt;/icon&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT31\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框一&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT31\" /&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT32\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框二&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT32\" /&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT33\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框三&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT33\"/&gt; &lt;/div&gt; &lt;div class=\"input-group col-xs-12 col-sm-6\"&gt; &lt;label for=\"txtTXT34\" class=\"input-group-addon\"&gt;&lt;b class='text-danger'&gt;*&lt;/b&gt;文本框四&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtTXT34\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function () &#123; LoadPanel(); &#125;); //加载面板动画 function LoadPanel() &#123; $(\".panel-head\").click(function () &#123; var _this = $(this); if (_this.siblings(\".panel-body\").hasClass('hide')) &#123; _this.siblings(\".panel-body\").animate(&#123; \"height\": _this.attr(\"cheight\"), \"padding\": \"15px\" &#125;, 200).removeClass(\"hide\").children(\"div\").removeClass(\"hide\"); _this.children(\"icon\").html(\"一\"); &#125; else &#123; var tempH = _this.siblings(\".panel-body\").height() _this.attr(\"cheight\", tempH); _this.siblings(\".panel-body\").animate(&#123; \"height\": \"0\", \"padding\": \"0\" &#125;, 200).addClass(\"hide\").children(\"div\").addClass(\"hide\"); _this.children(\"icon\").html(\"十\"); &#125; &#125;); &#125;&lt;/script&gt;&lt;/html&gt;","tags":[{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"panel","slug":"panel","permalink":"https://mowatermelon.github.io/tags/panel/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"},{"name":"animate","slug":"animate","permalink":"https://mowatermelon.github.io/tags/animate/"}]},{"title":"Js学习之prompt学习","date":"2017-10-14T16:00:00.000Z","path":"2017/10/15/js-Learning-promot/","text":"参考网站developer.mozilla 1 定义用于显示可提示用户进行输入的对话框，会弹出一个对话框， 有一点像 alert() 只不过 prompt() 需要用户输入数据，而且在用户点击 OK 后将数据存储在变量里。 2 语法1prompt(text,defaultText) 参数 描述 text 可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）。 defaultText 可选。默认的输入文本。 说明 如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段当前显示的文本。在用户点击确定按钮或取消按钮把对话框关闭之前，它将阻止用户对浏览器的所有输入。在调用 prompt() 时，将暂停对 JavaScript 代码的执行，在用户作出响应之前，不会执行下一条语句。 3 完整案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,Chrome=1\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1, minimum-scale=1.0, maximum-scale=1, user-scalable=no\" /&gt; &lt;meta http-equiv=\"Pragma\" content=\"no-cache\"/&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\"/&gt; &lt;meta http-equiv=\"Expires\" content=\"0\"/&gt; &lt;meta name=\"author\" content=\"WU EVA\" /&gt; &lt;title&gt;prompt_demo&lt;/title&gt; &lt;style&gt; button, html input[type=\"button\"], input[type=\"reset\"], input[type=\"submit\"] &#123; cursor: pointer; -webkit-appearance: button; &#125; .btn-info &#123; color: #ffffff; background-color: #5bc0de; border-color: #46b8da; &#125; .btn &#123; display: inline-block; padding: 6px 12px; margin-bottom: 0; font-weight: normal; line-height: 1.428571429; text-align: center; white-space: nowrap; outline: 0 none; vertical-align: middle; cursor: pointer; border: 1px solid transparent; border-radius: 4px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none; &#125; pre &#123; display: block; padding: 9.5px; margin: 0 0 10px; font-size: 13px; line-height: 1.428571429; color: #333333; word-break: break-all; word-wrap: break-word; background-color: #f5f5f5; border: 1px solid #cccccc; border-radius: 4px; &#125; h1, .h1 &#123; font-size: 36px; &#125; h1, h2, h3 &#123; margin-top: 20px; margin-bottom: 10px; &#125; h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 &#123; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-weight: 500; line-height: 1.5; &#125; h1 &#123; margin: 0.67em 0; font-size: 2em; &#125; *, *:before, *:after &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;study prompt()&lt;br/&gt;&lt;/h1&gt; &lt;input type=\"button\" class=\"btn btn-info\" value=\"Display a prompt box\" /&gt; &lt;br/&gt; &lt;br/&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; window.onload =function()&#123; var show_btn = document.querySelector('input'); var show_sel =document.querySelector('h1'); checkName(show_sel); show_btn.onclick =function()&#123; show_prompt(show_sel); &#125; &#125; //弹出promt提示框，并作转化处理 function show_prompt(selText)&#123; var myName = prompt('Please enter your name.','watermelon'); if (myName!=null &amp;&amp; myName!=\"\")&#123; localStorage.setItem('name', myName); selText.innerHTML += 'hello, &lt;span class=\"text-info\"&gt;' + myName+'&lt;/span&gt;'; selText.innerHTML += '&lt;br/&gt;' &#125; &#125; //检查当前的localstroge 的用户姓名 function checkName(selText)&#123; var usrName = localStorage.getItem('name'); if (usrName!=null &amp;&amp; usrName!=\"\")&#123; selText.innerHTML += 'hello, &lt;span class=\"text-info\"&gt;' + usrName+'&lt;/span&gt;'; selText.innerHTML += '&lt;br/&gt;' &#125; &#125; &lt;/script&gt;&lt;/html&gt;","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"prompt","slug":"prompt","permalink":"https://mowatermelon.github.io/tags/prompt/"},{"name":"localStorage","slug":"localStorage","permalink":"https://mowatermelon.github.io/tags/localStorage/"}]},{"title":"Js学习之对象学习","date":"2017-10-13T16:00:00.000Z","path":"2017/10/14/js-Learning-base-object/","text":"学习对象的相关方法–未完结版 1 前言引用类型通常叫做类（class），也就是说，遇到引用值，所处理的就是对象。 注意：从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现类这个词。ECMAScript 定义了对象定义，逻辑上等价于其他程序设计语言中的类。 提示：本教程将使用术语对象。 对象是由 new 运算符加上要实例化的对象的名字创建的。这种语法与 Java 语言的相似，不过当有不止一个参数时，ECMAScript 要求使用括号。如果没有参数，括号可以省略注意：尽管括号不是必需的，但是为了避免混乱，最好使用括号。 共有属性 __proto__ &amp;&amp; constructor 在JavaScript中，每个具有原型的对象都会自动获得constructor属性。除了arguments、Enumerator、Error、Global、Math、RegExp、Regular Expression等一些特殊对象之外，其他所有的JavaScript内置对象都具备constructor属性。例如：Array、Boolean、Date、Function、Number、Object、String等。所有主流浏览器均支持该属性。 2 学习Object对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function learnObject()&#123; //Object 对象自身用处不大，不过在了解其他类之前，还是应该了解它。 //因为 ECMAScript 中的 Object 对象与 Java 中的 java.lang.Object 相似 //ECMAScript 中的所有对象都由这个对象继承而来， //Object 对象中的所有属性和方法都会出现在其他对象中， //所以理解了 Object 对象，就可以更好地理解其他对象。 var oo = new Object(); oo.name = \"Wu Eva\"; //首先打印本身内容 console.log(oo);//&#123; name: 'Wu Eva' &#125; console.log(typeof(oo));//object console.log(oo instanceof(Object));//true //----------------------------------------------------属性 //对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。 console.log(oo.constructor); //[Function: Object] //对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型 //就是这个构造体的默认值 console.log(oo.__proto__); // &#123;&#125; //----------------------------------------------------方法 //判断对象是否有某个特定的属性。必须用字符串指定该属性。 console.log(oo.hasOwnProperty(\"name\"));//true console.log(oo.hasOwnProperty(\"age\"));//false //判断该对象是否为另一个对象的原型。 console.log(oo.isPrototypeOf(Object));//false console.log(oo.isPrototypeOf(String));//false //判断给定的属性是否可以用 for...in 语句进行枚举。 console.log(oo.propertyIsEnumerable());//false //返回对象的原始字符串表示。 //无论它是伪对象，还是真对象都有 toString() 方法 //对于 Object 对象，这个方法就比较多余，所以ECMA-262 没有定义这个值。 console.log(oo.toString());//[object Object] //返回最适合该对象的原始值。对于 Object 对象，会将object内容以键值对的形式返回。 console.log(oo.valueOf()); //&#123; name: 'Wu Eva' &#125;&#125; 3 学习Boolean对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function learnBoolean()&#123; //Boolean 对象是 Boolean 原始类型的引用类型。 //要创建 Boolean 对象，只需要传递 Boolean 值作为参数 //遗憾的是，在 ECMAScript 中很少使用 Boolean 对象，即使使用，也不易理解。 var oBool = new Boolean(true); //构造函数 //首先打印本身内容 console.log(oBool);//[Boolean: true] console.log(typeof(oBool));//object 无论引用的是什么类型的对象，它都返回 \"object\" console.log(oBool instanceof(Boolean));//true console.log(oBool instanceof(Object));//true console.log(oBool instanceof(String));//false //强制类型转化，将其他类型的变量转化成布尔值类型 //如果省略 value 参数，或者设置为 0、-0、null、\"\"、false、undefined 或 NaN，则该对象设置为 false。 //否则设置为 true，即使 value 参数是字符串 \"false\"。 console.log(Boolean(\"false\"))//true console.log(Boolean(0))//false console.log(Boolean(-0))//false console.log(Boolean(null))//false console.log(Boolean(new Object()))//true console.log(Boolean(\"\"))//false console.log(Boolean(undefined))//false console.log(Boolean(NaN))//false //----------------------------------------------------属性 //对创建对象的函数的引用（指针）。对于 Boolean 对象，该指针指向原始的 Boolean() 函数。 console.log(oBool.constructor); //[Function: Boolean] //对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型 //就是这个构造体的默认值 console.log(oBool.__proto__); //[Boolean: false] //----------------------------------------------------方法 //返回对象的原始字符串表示，对于 Boolean 对象，返回字符串 \"true\" 或 \"false\"。 console.log(oBool.toString()); // true console.log(typeof oBool.toString()); // string //返回最适合该对象的原始值，对于 Boolean 对象，返回原始值，即 true 和 false。 console.log(oBool.valueOf()); // true console.log(typeof oBool.valueOf()); // boolean //判断该对象是否为另一个对象的原型。 console.log(oBool.isPrototypeOf(Object));//false //判断给定的属性是否可以用 for...in 语句进行枚举。 console.log(oBool.propertyIsEnumerable());//false //返回该对象的源代码 //可能有兼容问题，在chrome 61.0.3163.100（正式版本）（32 位）中，打印控制台报错说 oBool.toSource is not a function //但是在firefox 56.0（32 位）中 打印出结果(new Boolean(true)) //console.log(oBool.toSource()); //但是注意，在 Boolean 表达式中，所有对象都会被自动转换为 true，所以 oFalseObject 的值是 true var oFalse = new Boolean(false); console.log(oFalse);// [Boolean: false] console.log(oFalse &amp;&amp; true);// true console.log(oFalse &amp;&amp; false);// false&#125; 4 学习Number对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106function learnNumber()&#123; //Number 对象是 Number 原始类型的引用类型 //要创建 Number 对象，只需要传递 数值作为参数 //不过应该少用这种对象，以避免潜在的问题。只要可能，都使用数字的原始表示法 var oNum = new Number(68); //构造函数 //首先打印本身内容 console.log(oNum);//[Number: 68] console.log(typeof(oNum));//object 无论引用的是什么类型的对象，它都返回 \"object\" console.log(oNum instanceof(Number));//true console.log(oNum instanceof(Object));//true console.log(oNum instanceof(String));//false //强制类型转化，将其他类型的变量转化成Number类型 //字符串值和object对象不能转换成数字 //但是true和false有对应的数值转义，分别为1和0 //null值有对应的数值，但是undefined没有对应的数值 console.log(Number(false))//0 console.log(Number(true))//1 console.log(Number(undefined))//NaN console.log(Number(null))//0 console.log(Number(\"1.2.3\"))//NaN console.log(Number(new Object()))//NaN //----------------------------------------------------属性 //对创建对象的函数的引用（指针）。对于 Number 对象，该指针指向原始的 Number() 函数。 console.log(oNum.constructor); //[Function: Number] //对该对象的对象原型的引用。这里对于 oNum，因为没有写原型链，所以返回未定义，不确定这个认知是否正确。 //console.log(oNum.Prototype); //undefined //对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型 //就是这个构造体的默认值 console.log(oNum.__proto__); //[Number: 0] //这些值是构造函数 Number() 自身的属性，而不是单独的某个 Number 对象的属性 //可表示的最大的数。 console.log(oNum.MAX_VALUE);//undefined console.log(Number.MAX_VALUE);// 1.7976931348623157e+308 //可表示的最大的数。 console.log(oNum.MIN_VALUE);//undefined console.log(Number.MIN_VALUE);// 5e-324 //非数字值。 console.log(oNum.NaN);//undefined console.log(Number.NaN);//NaN //负无穷大，溢出时返回该值。 console.log(oNum.NEGATIVE_INFINITY);//undefined console.log(Number.NEGATIVE_INFINITY);//-Infinity //正无穷大，溢出时返回该值。 console.log(oNum.POSITIVE_INFINITY);//undefined console.log(Number.POSITIVE_INFINITY);//Infinity //----------------------------------------------------方法 //返回对象的原始字符串表示 //对于 Number 对象 toString() 方法比较特殊 //它有两种模式，即默认模式和基模式 //采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法） //在默认模式中，不管是初始值是以二进制，八进制，十进制或十六进制字面量形式声明的数字输出的都是十进制形式的 console.log(oNum.toString()); // 68 console.log(typeof oNum.toString()); // string //采用基模式，toString() 方法只是要转换成的基数的另一种加法而已 //在基模式中，不管是初始值是以二进制，八进制，十进制或十六进制字面量形式声明的数字输出的都是对应的规定进制形式的 console.log(oNum.toString(2)); // 1000100 console.log(oNum.toString(8)); // 104 console.log(oNum.toString(16)); // 44 //返回最适合该对象的原始值，对于 Number 对象，返回原始值，原始数值。 console.log(oNum.valueOf()); // 68 console.log(typeof oNum.valueOf()); // number //-----------------toFixed()、toExponential() 和 toPrecision() 方法都会进行四舍五入操作，以便用正确的小数位数正确地表示一个数 //返回的是具有指定位数小数的数字的字符串表示 //指定要输出的小数的位数 //空的字符串位由 0 来补充 //能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。 console.log(oNum.toFixed(2)); // 68.00 //返回的是用指数计数法表示的数字的字符串形式 //指定要输出的小数的位数 //如果指定的位数多于需要的位数，空的字符串位由 0 来补充 //能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。 console.log(oNum.toExponential(0)); //7e+1 console.log(oNum.toExponential(1)); //6.8e+1 console.log(oNum.toExponential(2)); //6.80e+1 //数字格式化为指定的长度。 //根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数） //如果指定的位数多于需要的位数，空的字符串位由 0 来补充 //能表示具有 1 到 21 位小数的数字，超过这个范围的值会引发错误。 console.log(oNum.toPrecision(1)); // 7e+1 console.log(oNum.toPrecision(2)); // 68 //把数字转换为字符串，使用本地数字格式顺序。 console.log(oNum.toLocaleString()); //判断该对象是否为另一个对象的原型。 console.log(oNum.isPrototypeOf(String));//false //判断给定的属性是否可以用 for...in 语句进行枚举。 console.log(oNum.propertyIsEnumerable());//false&#125; 5 学习String对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346function learnString()&#123; //String 原始类型的对象表示法 var oString = new String(\"hello world\"); //首先打印本身内容 console.log(oString);//[String: 'hello world'] console.log(typeof(oString));//object 无论引用的是什么类型的对象，它都返回 \"object\" console.log(oString instanceof(String));//true console.log(oString instanceof(Object));//true console.log(oString instanceof(Number));//false //强制类型转化，将其他类型的变量转化成String类型 //对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误 // 但是 null 和 undefined 值强制使用toString()，会引发错误 console.log(String(-0))//0 console.log(String(null))//null console.log(String(new Object()))//[object Object] console.log(String(undefined))//undefined console.log(String(NaN))//NaN //----------------------------------------------------属性 //对创建对象的函数的引用（指针）。对于 String 对象，该指针指向原始的 String() 函数。 console.log(oString.constructor); //[Function: String] //对该对象的对象原型的引用。对于 oString 对象，因为没有写原型链，所以返回未定义，不确定这个认知是否正确。 //console.log(oString.Prototype); //undefined //对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型 //就是这个构造体的默认值 console.log(oString.__proto__); // [String: ''] //----------------------------------------------------方法 //创建 HTML 锚。将字符串输出为有唯一标识的纯粹HTML //@para anchorname 必需。为锚定义名称。 console.log(oString.anchor(\"anchorDemo\"));//&lt;a name=\"anchorDemo\"&gt;hello world&lt;/a&gt; //把字符串显示为链接。只在页面中才会有效果。 //@para url 必需。规定要链接的 URL。 console.log(oString.link());//&lt;a href=\"undefined\"&gt;hello world&lt;/a&gt; console.log(oString.link(\"https://mowatermelon.github.io/\"));//&lt;a href=\"https://mowatermelon.github.io/\"&gt;hello world&lt;/a&gt; //把字符串显示为大号字体。只在页面中才会有大两个字体号效果。 console.log(oString.big());//&lt;big&gt;hello world&lt;/big&gt; console.log(\"\\n把字符串显示为小号字体。只在页面中才会有小两个字体号效果---------------------------------------------------------------------small()\"); //把字符串显示为小号字体。只在页面中才会有小两个字体号效果。 console.log(oString.small());//&lt;small&gt;hello world&lt;/small&gt; //把字符串显示闪动的字符串，目前没有看到有浏览器支持 console.log(oString.blink());//&lt;blink&gt;hello world&lt;/blink&gt; //把字符串显示粗体的字符串，只在页面中才会有粗体效果，IE不兼容 console.log(oString.bold());//&lt;b&gt;hello world&lt;/b&gt; //以打字机文本显示字符串。只在页面中才会有效果。 console.log(oString.fixed());//&lt;tt&gt;hello world&lt;/tt&gt; //返回指定的颜色的字符串。只在页面中才会有效果。 //color 必需。为字符串规定 font-color。 //该值必须是颜色名(red)、RGB 值(rgb(255,0,0))或者十六进制数(#FF0000)。 console.log(oString.fontcolor(\"Red\"));//&lt;font color=\"Red\"&gt;hello world&lt;/font&gt; //size 参数必须是从 1 至 7 的数字，数字越大字体越大。 console.log(oString.fontsize(6));//&lt;font size=\"6\"&gt;hello world&lt;/font&gt; //把字符串显示为斜体。只在页面中才会有效果。 console.log(oString.italics());//&lt;i&gt;hello world&lt;/i&gt; //把字符串显示为加了删除线的字符串。只在页面中才会有效果。 console.log(oString.strike());//&lt;strike&gt;hello world&lt;/strike&gt; //把字符串显示为下标。只在页面中才会有效果。 console.log(oString.sub());//&lt;sub&gt;hello world&lt;/sub&gt; //把字符串显示为上标。只在页面中才会有效果。 console.log(oString.sup());//&lt;sup&gt;hello world&lt;/sup&gt; //用于把字符串转换为小写。 //返回值 一个新的字符串，在其中 stringObject 的所有大写字符全部被转换为了小写字符。 //与 toLowerCase() 不同的是，toLocaleLowerCase() 方法按照本地方式把字符串转换为小写。 //---------------只有几种语言（如土耳其语）具有地方特有的大小写映射，所有该方法的返回值通常与 toLowerCase() 一样。 var sss =\"HELLO WORLD\"; console.log(sss.toLocaleLowerCase());//hello world //用于把字符串转换为小写。 //返回值 一个新的字符串，在其中 stringObject 的所有大写字符全部被转换为了小写字符。 console.log(sss.toLowerCase());//hello world //用于把字符串转换为大写。 //返回值 一个新的字符串，在其中 stringObject 的所有大写字符全部被转换为了大写字符。 //与 toUpperCase() 不同的是，toLocaleUpperCase() 方法按照本地方式把字符串转换为大写。 //---------------只有几种语言（如土耳其语）具有地方特有的大小写映射，所有该方法的返回值通常与 toLowerCase() 一样。 console.log(oString.toLocaleUpperCase());//HELLO WORLD //用于把字符串转换为大写。 //返回值 一个新的字符串，在其中 stringObject 的所有大写字符全部被转换为了大写字符。 console.log(oString.toUpperCase());//HELLO WORLD //返回在指定位置的字符 //不提供参数就返回第一个字符的字符 //提供游标值，就返回指定游标的字符 console.log(oString.charAt());//h console.log(oString.charAt(1));//e console.log(oString.charAt(2));//l //返回在指定的位置的字符的 Unicode 编码 //不提供参数就返回第一个字符的编码值 //提供游标值，就返回指定游标的编码值 console.log(oString.charCodeAt());//104 （h对应的编码） console.log(oString.charCodeAt(1));//101 （e对应的编码） console.log(oString.charCodeAt(2));//108 （l对应的编码） //可接受一个指定的 Unicode 值，然后返回一个字符串。 //这个方法是构造函数 String() 自身的方法，而不是单独的某个 String 对象的方法 //console.log(oString.fromCharCode(65,66,67));//报错 fromCharCode is not a function console.log(String.fromCharCode(65,66,67));//ABC //连接两个或多个字符串 //stringObject.concat(stringX,stringX,...,stringX) //concat() 方法将把它的所有参数转换成字符串 //然后按顺序连接到字符串 stringObject 的尾部 //并返回连接后的字符串。 //请注意，stringObject 本身并没有被更改。 //@para stringX 必需。将被连接为一个字符串的一个或多个字符串对象。 console.log(oString.concat(oString));//hello worldhello world //用本地特定的顺序来比较两个字符串。 //@para target 要以本地特定的顺序与 stringObject 进行比较的字符串。 //说明比较结果的数字。如果 stringObject 小于 target，则 localeCompare() 返回小于 0 的数。 //如果 stringObject 大于 target，则该方法返回大于 0 的数。 //如果两个字符串相等，或根据本地排序规则没有区别，该方法返回 0。 //把 &lt; 和 &gt; 运算符应用到字符串时，它们只用字符的 Unicode 编码比较字符串，而不考虑当地的排序规则。 //以这种方法生成的顺序不一定是正确的。 //ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用底层操作系统提供的排序规则。 //可以用于有多个字符串的数组进行排序 console.log(oString.localeCompare(\"\"));//1 console.log(oString.localeCompare(\"hello\"));//1 //var str = [\"99\",\"1\",\"7\",\"88\",\"30\",\"90\",\"444\",\"999\"]; //str.sort (function(a,b)&#123;return a.localeCompare(b)&#125;) //(8) [\"1\", \"30\", \"444\", \"7\", \"88\", \"90\", \"99\", \"999\"] //返回某个指定的字符串值在字符串中首次出现的位置。 //stringObject.indexOf(searchvalue,fromindex) //searchvalue 必需。规定需检索的字符串值。 //@para fromindex 可选的整数参数。规定在字符串中开始检索的位置。 //它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。 //该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。 //---------------开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定 fromindex 时）。 //---------------如果找到一个 searchvalue，则返回 searchvalue 的第一次出现的位置。 //stringObject 中的字符位置是从 0 开始的。 //这个是做的完全匹配,对大小写敏感 console.log(oString.indexOf(\"Hello\"));//-1 console.log(oString.indexOf(\"l\",1));//2 //返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 //stringObject.lastIndexOf(searchvalue,fromindex) //searchvalue 必需。规定需检索的字符串值。 //@para fromindex 可选的整数参数。规定在字符串中开始检索的位置。 //它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。 //该方法将从尾到头地检索字符串 stringObject，看它是否含有子串 searchvalue。 //---------------开始检索的位置在字符串的 fromindex 处或字符串的结尾（没有指定 fromindex 时）。 //---------------如果找到一个 searchvalue，则返回 searchvalue 的第一个字符在 stringObject 中的位置。 //stringObject 中的字符位置是从 0 开始的。 //这个是做的完全匹配,对大小写敏感 console.log(oString.lastIndexOf(\"Hello\"));//-1 console.log(oString.lastIndexOf(\"l\",1));//-1 //在字符串内检索指定的值，或找到一个或多个正则表达式的匹配 //存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。 //searchvalue 必需。规定要检索的字符串值。 console.log(oString.match(\"Hello\"));//null console.log(oString.match(\"hello\"));//[ 'hello', index: 0, input: 'hello world' ] console.log(oString.match(\"world\").index);//6 //regexp 必需。规定要匹配的模式的 RegExp 对象。 //如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 //match() 方法将检索字符串 stringObject，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。 //如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。 //---------------如果没有找到任何匹配的文本， match() 将返回 null。 //---------------否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 ///---------------该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。 //---------------除了这些常规的数组元素之外，返回的数组还含有两个对象属性。 //---------------index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，input 属性声明的是对 stringObject 的引用。 //如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。 //---------------若没有找到任何匹配的子串，则返回 null。 //---------------如果找到了一个或多个匹配子串，则返回一个数组。 //---------------不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。 // /^[a-z0-9\\.-]*$/g 正则中的$是匹配结束字符 ^ 是判断以什么开头 * 是判断字符串中是否包含某某内容 var charReg1 = /[a-z]/g;//验证是否全部为字符 var charReg2 = /[a-z]/;//验证是否全部为字符 var charReg3 = /[a-z]*/g;//验证是否全部为字符 //简而言之，就是正则中有g，能够进行匹配，则返回的数组只有一个值，就是传入的字符串值，不能匹配的话就返回空 //就是正则中没有g，能够进行匹配，则返回的数组有三个值，就是传入的字符串值，index属性和input属性以及对应的值，不能匹配的话就返回空 //如果RegExp中没有g 则 RegExp.exec(stringObject) 等价于 stringObject.match(RegExp) console.log(oString.match(charReg1));//[ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ] console.log(oString.match(charReg2));//[ 'h', index: 0, input: 'hello world' ] console.log(oString.match(charReg3));//[ 'hello', '', 'world', '' ] console.log(charReg1.test(oString));//true console.log(charReg2.test(oString));//true console.log(charReg3.test(oString));//true console.log(charReg1.exec(oString));//[ 'e', index: 1, input: 'hello world' ] console.log(charReg2.exec(oString));//[ 'h', index: 0, input: 'hello world' ] console.log(charReg3.exec(oString));//[ '', index: 5, input: 'hello world' ] //用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 //regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。 //---------------请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 //replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 //返回值 一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 //字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。 //---------------它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。 //---------------如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。 //---------------否则，它只替换第一个匹配子串。 //replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。 //---------------但是 replacement 中的 $ 字符具有特定的含义。 //---------------如下表所示，它说明从模式匹配得到的字符串将用于替换。 // | 字符 | 替换文本 | // |:----------------|:-----------------| // | $1、$2、...、$99 | 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 | // | $&amp; | 与 regexp 相匹配的子串。 | // | $` | 位于匹配子串左侧的文本。 | // | $' | 位于匹配子串右侧的文本。 | // | $$ | 直接量符号。 | //ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。 //---------------在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。 //---------------该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。 //---------------接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 //Flag: i-----------标识ignore忽略大小，g-----------标识global 反复检索,m-----------标识多行检索(这个暂时没试验) console.log(oString.replace(/o/, \"watermelon\"));//hell watermelon world 只会进行一次替换的replace console.log(oString.replace(/o/g, \" watermelon \"));//hell watermelon w watermelon rld 加上g之后会对所有匹配的内容进行替换 console.log(oString.replace(/o/g, \" $` \"));//hell hell w hello w rld 原字符串中第一个匹配到o左侧文本是 hell所以 hello 变成了 hell hell 第二个匹配到o的左侧文本是 hello w ， 所以 world 变成了 w hello w rld console.log(oString.replace(/o/g, \" $' \"));//hell world w rld rld 原字符串中第一个匹配到o右侧文本是 world 所以 hello 变成了 hell world 第二个匹配到o的右侧文本是 rld ， 所以 world 变成了 w rld rld console.log(oString.replace(/o/g, \"$$\")); //hell$ w$rld 将所有匹配o的地方替换成 $ console.log(oString.replace(/o/g, \" $&amp;+$&amp; \")); //hell o+o w o+o rld 这里的$&amp;指代的就是替换条件 o 所以 $&amp;+$&amp; 等价于 o+o var ss=\"AaAB\"; console.log(ss.replace(/A/ig, \"RR\"));//RRRRRRB 加上ig之后会对所有匹配的内容进行替换，并且忽略大小写 console.log(oString.replace(/(\\w+)\\s* \\s*(\\w+)/, \"$2 $1\"));//world hello 通过字符串中的空格，对字符串进行分割，$1是第一个匹配的文本，$2是第二个匹配的文本，然后进行反序输出 console.log(oString.replace(/\\b\\w+\\b/g, function(word)&#123; return word.substring(0,1).toUpperCase()+word.substring(1);&#125; )); //Hello World 所有单词的首字母都转换为大写 也就是说replace的第二个参数是可以支持函数形式 //用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 //regexp 该参数可以是需要在 stringObject 中检索的子串，也可以是需要检索的 RegExp 对象。 //---------------注释：要执行忽略大小写的检索，请追加标志 i。 //返回值 stringObject 中第一个与 regexp 相匹配的子串的起始位置。 //---------------注释：如果没有找到任何匹配的子串，则返回 -1。 //search() 方法不执行全局匹配，它将忽略标志 g。 //---------------它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。 console.log(oString.search(/o/));//4 console.log(oString.search(/O/));//-1 search()对大小写比较敏感 console.log(oString.search(/O/i));//4 对字符串忽略大小写进行匹配 //如果只是对一个具体字符串来查找，那么使用indexOf()的系统资源消耗更小，效率更高； //---------------如果是查找具有某些特征的字符串（比如查找以a开头，后面是数字的字符串） //---------------那么indexOf()就无能为力，必须要使用正则表达式和search()方法了。 // 很多时候用indexOf()不是为了真的想知道子字符串的位置，而是想知道长字符串中没有包含这个子字符串。 //---------------如果返回索引值是-1，那么说明没有：不等于-1，那么就是有。 //一般情况下indexOf比search更省资源。 //提取字符串的某个部分，并以新的字符串返回被提取的部分。 //start 要抽取的片断的起始下标。 必填 //---------------如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。 //---------------也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 //end 紧接着要抽取的片段的结尾的下标。 选填 //---------------若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。 //---------------如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。 //返回值 一个新的字符串。包括字符串 stringObject 从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符。 //String 对象的方法 slice()、substring() 和 substr() （不建议使用）都可返回字符串的指定部分。 //---------------slice() 比 substring() 要灵活一些，因为它允许使用负数作为参数。 //---------------slice() 与 substr() 有所不同，因为它用两个字符的位置来指定子串，而 substr() 则用字符位置和长度来指定子串。 //---------------还要注意的是，String.slice() 与 Array.slice() 相似。 console.log(oString.slice(6));//world 提取从位置 6 开始的所有字符 console.log(oString.slice(6,8));//wo 提取从位置 6 到位置 11 的所有字符 console.log(oString.slice(6,6)); // 返回值为空 slice不支持start =end console.log(oString.slice(8,6)); // 返回值为空 slice不支持start &gt;end console.log(oString.slice(-3,-1));//rl 提取从倒数的位置 3 到倒数的位置 1 的所有字符 //在字符串中抽取从 start 下标开始的指定数目的字符。 //start 必需。要抽取的子串的起始下标。 //---------------必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。 //---------------也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 //length 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。 //返回值 一个新的字符串，包含从 stringObject 的 start（包括 start 所指的字符） 处开始的 length 个字符。 //---------------如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。 //注释：substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。 //ECMAscript 没有对该方法进行标准化，因此反对使用它。 //在 IE 4 中，参数 start 的值无效。在这个 BUG 中，start 规定的是第 0 个字符的位置。在之后的版本中，此 BUG 已被修正。 console.log(oString.substr(6));//world console.log(oString.substr(6,8));//world console.log(oString.substr(-3));//rld console.log(oString.substr(-3,-1));// 返回值为空 substr不支持第二个参数为负数 //用于提取字符串中介于两个指定下标之间的字符。 //start 必需。一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。 //stop 可选。一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。 //---------------如果省略该参数，那么返回的子串会一直到字符串的结尾。 //返回值 一个新的字符串，该字符串值包含 stringObject 的一个子字符串， //---------------其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。 //substring() 方法返回的子串包括 start 处的字符，但不包括 stop 处的字符。 //---------------如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 //---------------如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 //与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数。 console.log(oString.substring(6));//world console.log(oString.substring(6,8));//wo console.log(oString.substring(6,6));// 返回值为空 console.log(oString.substring(8,6));//wo 因为8比6大 所以替换了位置之后再请求的数据 console.log(oString.substring(-3,-1));// 返回值为空 substring不支持参数为负数 //把一个字符串分割成字符串数组 //separator 必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。 //howmany 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。 //---------------如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 //返回值 一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。 //---------------返回的数组中的字串不包括 separator 自身。 //---------------但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。 //如果把空字符串 (\"\") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 //String.split() 执行的操作与 Array.join 执行的操作是相反的。 console.log(oString.split(\" \"));//[ 'hello', 'world' ] console.log(oString.split(/\\s+/));//[ 'hello', 'world' ] console.log(oString.split(\"\"));//[ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ] 不写howmany 返回所有数据 console.log(oString.split(\"\",4));//[ 'h', 'e', 'l', 'l' ] 写howmany 返回符合从1到howmany的所有数据 //返回对象的原始字符串表示。 //无论它是伪对象，还是真对象都有 toString() 方法 //对于 Object 对象，这个方法就比较多余，所以ECMA-262 没有定义这个值。 console.log(oString.toString());//hello world //返回最适合该对象的原始值。对于 Object 对象，会将object内容以键值对的形式返回。 console.log(oString.valueOf()); //hello world&#125;","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"object","slug":"object","permalink":"https://mowatermelon.github.io/tags/object/"},{"name":"function","slug":"function","permalink":"https://mowatermelon.github.io/tags/function/"}]},{"title":"Linux学习之基础指令学习","date":"2017-10-12T16:00:00.000Z","path":"2017/10/13/Linux-Learning-command/","text":"我之前都没有怎么使用过linux系统，最近刚刚装了deepin，感觉对着终端，无从下手，所以查了相关指令，进行学习。 1 deepin简介Deepin 原名Linux Deepin，在2014年4月改名Deepin。Deepin团队基于Qt/C++（用于前端）和Go（用于后端）开发了的全新深度桌面环境（DDE），以及音乐播放器，视频播放器，软件中心等一系列特色软件。 Deepin是由武汉深之度科技有限公司开发的Linux发行版。Deepin 是一个基于 Linux 的操作系统，专注于使用者对日常办公、学习、生活和娱乐的操作体验的极致，适合笔记本、桌面计算机和一体机。它包含了所有你需要的应用程序，网页浏览器、幻灯片演示、文档编辑、电子表格、娱乐、声音和图片处理软件，即时通讯软件等等。 Deepin 的历史可以追溯到 2004年，其前身 Hiweed Linux 是中国第一个基于 Debian的本地化衍生版，并提供轻量级的可用LiveCD，旨在创造一个全新的简单、易用、美观的 Linux 操作系统。 Deepin拥有自主设计的特色软件：深度软件中心、深度截图、深度音乐播放器和深度影音，全部使用自主的DeepinUI，其中有深度桌面环境，DeepinTalk（深谈）等。 Deepin是中国最活跃的 Linux 发行版，Deepin 为所有人提供稳定、高效的操作系统，强调安全、易用、美观。其口号为“免除新手痛苦，节约老手时间”。在社区的参与下，“让 Linux 更易用”也不断变成可以触摸的现实。 2 常用指令 指令名称 指令含义 ls 显示文件或目录 ls -l 列出文件详细信息l(list) ls -a 列出当前目录下所有文件及目录，包括隐藏的a(all) mkdir 创建目录 mkdir -p 创建目录，若无父目录，则创建p(parent) cd 切换目录 man command 查看某个指令的帮助文档 touch 创建空文件 echo 创建带有内容的文件。 cat 查看文件内容 cp 拷贝 mv 移动或重命 rm 删除文件 rm -r 递归删除，可删除子目录及文件 rm -f 强制删除 find 在文件系统中搜索某文件 wc 统计文本中行数、字数、字符数 grep 在文本文件中查找某个字符串 rmdir 删除空目录 tree 树形结构显示目录，需要安装tree包 pwd 显示当前目录 ln 创建链接文件 more、less 分页显示文本文件内容 head、tail 显示文件头、尾内容 ctrl+alt+F1 命令行全屏模式s 3 系统管理命令 指令名称 指令含义 stat 显示指定文件的详细信息，比ls更详细 who 显示在线登陆用户 whoami 显示当前操作用户 hostname 显示主机名 uname 显示系统信息 top 动态显示当前耗费资源最多进程信息 ps 显示瞬间进程状态 ps -aux du 查看目录大小 du -h /home带有单位显示目录信息 df 查看磁盘大小 df -h 带有单位显示磁盘信息 ifconfig 查看网络情况 ping 测试网络连通 netstat 显示网络状态信息 man 命令不会用了，找男人 如：man ls clear 清屏 alias 对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit kill 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。 4 打包压缩相关命令 指令名称 指令含义 gzip&amp;bzip2&amp;tar: 打包压缩 -c 归档文件 -x 压缩文件 -z gzip压缩文件 -j bzip2压缩文件 -v 显示压缩或解压缩过程 v(view) -f 使用档名 举个栗子 12345tar -cvf /home/abc.tar /home/abc #只打包，不压缩tar -zcvf /home/abc.tar.gz /home/abc #打包，并用gzip压缩tar -jcvf /home/abc.tar.bz2 /home/abc #打包，并用bzip2压缩 当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的c 换成x 就可以了。 5 关机/重启机器 指令名称 指令含义 shutdown -r 关机重启 shutdown -h 关机不重启 shutdown now 立刻关机 halt 关机 reboot 重启 6 Linux管道将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。 12#在home目录下所有文件中查找，包括close的文件，并分页输出。grep -r \"close\" /home/* | more 7 Linux软件包管理7.1 dpkgDebian Package管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。 比如安装tree命令的安装包，先将tree.deb传到Linux系统中。再使用如下命令安装。 12sudo dpkg -i tree_1.5.3-1_i386.deb # 安装软件sudo dpkg -r tree #卸载软件 注：将tree.deb传到Linux系统中，有多种方式。VMwareTool使用挂载方式；或者使用winSCP工具等； 7.2 APTAdvanced Packaging Tool高级软件工具，这种方法适合系统能够连接互联网的情况。 依然以tree为例 1234sudo apt-get install tree #安装treesudo apt-get remove tree #卸载treesudo apt-get update #更新软件sudo apt-get upgrade 8 vim使用vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i来切换模式。 命令模式下： 字符内容 字符含义 :q 退出 :q! 强制退出 :wq 保存并退出 :set number 显示行号 :set nonumber 隐藏行号 /apache 在文档中查找apache 按n跳到下一个，shift+n上一个 yyp 复制光标所在行，并粘贴 h 左移一个字符← j 下一行↓ k 上一行↑ l 右移一个字符→ 8 用户及用户组管理 账号地址 地址含义 /etc/passwd 存储用户账号 /etc/group 存储组账号 /etc/shadow 存储用户账号的密码 /etc/gshadow 存储用户组账号的密码 useradd 用户名 添加用户 userdel 用户名 删除用户 adduser 用户名 未知 groupadd 组名 添加用户组 groupdel 组名 删除用户组 passwd root 给root设置密码 su root 进入管理员帐号，这个时候会提示需要输入密码 su - root 以管理员身份做些事情 /etc/profile 系统环境变量 bash_profile 用户环境变量 .bashrc 用户环境变量 su user 切换用户，加载配置文件.bashrc su - user 切换用户，加载配置文件/etc/profile ，加载bash_profile 更改文件的用户及用户组 1sudo chown [-R] owner[:group] &#123;File|Directory&#125; 例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop 要想切换此文件所属的用户及组，可以使用命令。 1sudo chown root:root jdk-7u21-linux-i586.tar.gz 9 文件权限管理 三种基本权限 字符内容 字符含义 R 读 数值表示为4 W 写 数值表示为2 X 可执行 数值表示为1 如图所示，jdk-7u21-linux-i586.tar.gz文件的权限为-rw-rw-r-- -rw-rw-r--一共十个字符，分成四段。 第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录 第二三四个字符“rw-”表示当前所属用户的权限。 所以用数值表示为4+2=6 第五六七个字符“rw-”表示当前所属组的权限。 所以用数值表示为4+2=6 第八九十个字符“r–”表示其他用户权限。 所以用数值表示为2 所以操作此文件的权限用数值表示为662 更改权限 1sudo chmod [u所属用户 g所属组 o其他用户 a所有用户] [+增加权限 -减少权限] [r w x] 目录名 例如：有一个文件filename，权限为-rw-r----x ,将权限值改为-rwxrw-r-x，用数值表示为765 12345sudo chmod u+x g+w o+r filename# 上面的例子可以用数值表示sudo chmod 765 filename","tags":[{"name":"Linux","slug":"Linux","permalink":"https://mowatermelon.github.io/tags/Linux/"},{"name":"command","slug":"command","permalink":"https://mowatermelon.github.io/tags/command/"}]},{"title":".NET学习之validate安全管理学习","date":"2017-10-11T16:00:00.000Z","path":"2017/10/12/NET-Learning-validation/","text":"今天测试和我说项目中的富文本编辑器上传图片不成功，我查了一下，是在上传图片信息的时候，违反了c#的安全信息验证，所以我在web.config中添加了以下内容，去掉了这个验证，不知道对项目中的其他的验证会不会有影响。 12345678&lt;configuration&gt; &lt;system.web&gt; &lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.0&quot; /&gt; &lt;!--为了保证富文本编辑器图片上传成功，需要去掉网站在这块的危险认证--&gt; &lt;httpRuntime maxQueryStringLength=&quot;1024000&quot; requestValidationMode=&quot;2.0&quot; /&gt; &lt;pages validateRequest=&quot;false&quot; /&gt; &lt;/system.web&gt;&lt;/configuration&gt;","tags":[{"name":".NET","slug":"NET","permalink":"https://mowatermelon.github.io/tags/NET/"},{"name":"validate","slug":"validate","permalink":"https://mowatermelon.github.io/tags/validate/"}]},{"title":"js学习之jquery.iviewer图片插件学习","date":"2017-10-10T16:00:00.000Z","path":"2017/10/11/js-Learning-jquery-iviewer/","text":"今天同事找我说，他今天使用jquery.iviewer图片切换出了点问题，我过去看了半天，因为之前没有用过，实在越看越糊涂，很怂的回来，想下了源码看一下，在gayhub中找了半天，有好几个比较相近的，最终确定了https://github.com/vmeln/iviewer-fix.git，下载了之后，文件夹中没有专门的使用案例，也没说方法怎么用，我看了半天源码，才知道初始化之后想要调用对象方法怎么玩。 第一步12//声明一个全局变量接管这个方法var viewer = $(selector).iviewer(&#123;src: \"XXX.jpg\"&#125;); 第二步123456//对全局变量进行操作,第一个参数是方法名，从第二个参数开始，就是接收传入方法的参数值viewer.iviewer(\"functionName\",\"param01\",\"param02\",...................,\"paramN\");//举个栗子//iviewer源码中 有个方法是 zoom_by(delta, zoom_center)， viewer.iviewer(\"zoom_by\", -0.98, origin);//后面两个就是传入方法的参数 完整代码放上完整代码，这个是做图片切换的例子，比较常用的一个方法 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #container &#123; position: absolute; top: 200px; left: 100px; border: 1px solid; width: 600px; height: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;button id=\"cli\"&gt;切换&lt;/button&gt;&lt;/body&gt;&lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery.iviewer.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; var viewer = $('#container').iviewer(&#123; src: \"http://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-51908.jpg\", update_on_resize: false, onMouseMove: function (ev, coords) &#123; &#125; &#125;); $(\"#cli\").click(function()&#123; viewer.iviewer(\"loadImage\", \"http://img3.imgtn.bdimg.com/it/u=3504081194,1127587637&amp;fm=27&amp;gp=0.jpg\"); &#125;);&#125;)&lt;/script&gt;&lt;/html&gt; 总结最开始我以为在初始化之后，我这边就可以直接viewer.loadImage(url)，就可以调用了结果这边一直说对象没有这个方法，然后我就以为viewer.iviewer({loadImage(url)})这样调用，结果还是不行，只有认真去看源码，以及下载的案例中怎么用的，才发现是viewer.iviewer(‘loadImage&#39;,&#39;url&#39;)这样调用的，我去给同事说了之后，同事还说了一句我好厉害，日常羞愧，感觉做东西真的不能想当然，还有，这个要认真看源码，日常捂脸.jpg。","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"jquery","slug":"jquery","permalink":"https://mowatermelon.github.io/tags/jquery/"},{"name":"iviewer","slug":"iviewer","permalink":"https://mowatermelon.github.io/tags/iviewer/"}]},{"title":"西瓜有话说之Js学习funciton篇","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/js-Thinking-function-funciton/","text":"1. 定义构造函数，创建一个新的function对象。 在 javascript 中, 每个函数实际上都是一个function对象。 2 名词字典 本文中出现变量名词的解释 1234567891011121314var oo = new Object();var oBool = new Boolean(true);var oNum = new Number(68);var oString = new String(\"hello world\");var oArray = new Array(\"demo\",\"melon\",\"water\");var oDate = new Date();function demoParent()&#123;&#125;function demoChildren()&#123;&#125; 变量名 含义 举例 objectName 相关对象类型名称 就像上面js代码中Object,Boolean,Number,String,Array,Date varName 相关对象类型实例化后的变量名 就像上面js代码中oo,oBool,oNum,oString,oArray,oDate param1,param2,param3,…,paramN 函数中需要传入第一个到第N个的参数值 就像上面js代码中true,68,hello world functionName 函数名称 就像上文的demoParent，demoChildren 3. function的属性3.1 继承对象的属性3.2 函数的常用属性值 属性名 描述 使用方法 arguments 不推荐使用，属性代表传入函数的实参，它是一个类数组对象。已经被废弃很多年了，现在推荐的做法是使用函数内部可用的 arguments 对象来访问函数的实参。在函数递归调用的时候（在某一刻同一个函数运行了多次，也就是有多套实参），那么 arguments 属性的值是最近一次该函数调用时传入的实参。如果函数不在执行期间，那么该函数的 arguments 属性的值是 null。 functionName.arguments arity 已废弃，返回一个函数的形参数量，是一个古老的已经没有浏览器支持的属性,你应该使用length属性来代替.。 functionName.arity caller 不推荐使用，如果一个函数functionName是在全局作用域内被调用的,则functionName.caller为null,相反,如果一个函数是在另外一个函数作用域内被调用的,则functionName.caller指向调用它的那个函数，该属性的常用形式arguments.callee.caller替代了被废弃的arguments.caller。 functionName.caller callee 不推荐使用，callee放回正在执行的函数本身的引用，它是arguments的一个属性。 arguments.callee displayName 不推荐使用，获取函数的显示名称。 functionName.displayName length 指明函数的形参个数，length 是函数对象的一个属性值，指该函数有多少个必须要传入的参数，即形参的个数。形参的数量不包括剩余参数个数，仅包括第一个具有默认值之前的参数个数。与之对比的是，arguments.length 是函数被调用时实际传参的个数。 functionName.length name 返回一个函数声明的名称，使用new Function(...)语法创建的函数或只是 Function(...) create Function对象及其名称为anonymous。 functionName.name prototype 函数对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型。 functionName.prototype 3.3 注意3.3.1 callee 这个属性只有在函数执行时才有效 它有一个length属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较arguments.length是否等于arguments.callee.length 它可以用来递归匿名函数。 1234567891011121314151617181920212223var a = function() &#123; console.log(\"arguments.callee\"); // arguments.callee console.log(arguments.callee); //在浏览器控制台 打印效果 // ƒ () &#123; // console.log(\"arguments.callee\"); // console.log(arguments.callee); // console.log(\"arguments.callee.length\"); // console.log(arguments.callee.length); // &#125; //在js文件以node的形式运行 打印效果 //[Function: a] console.log(\"arguments.callee.length------a\"); //arguments.callee.length console.log(arguments.callee.length); // 0&#125;var b = function(n,m) &#123; a(); console.log(\"arguments.callee.length------b\"); //arguments.callee.length console.log(arguments.callee.length); // 2&#125;b(); 3.3.2 length 请注意这个指的是形参的个数，如果参数在传入的时候是以已经定义的情况下，这个时候是不会被计算的 1234567891011121314151617console.log(Function.length); /* 1 */console.log((function() &#123;&#125;).length); /* 0 */console.log((function(a) &#123;&#125;).length); /* 1 */console.log((function(a, b) &#123;&#125;).length); /* 2 etc. */console.log((function(...args) &#123;&#125;).length);// 0, rest parameter is not countedconsole.log((function(a, b = 1, c) &#123;&#125;).length);// 1, only parameters before the first one with// a default value is countedconsole.log((function(a = 1, b, c) &#123;&#125;).length) // 0console.log((function(b, a = 1, c) &#123;&#125;).length) // 1console.log((function(b, c, a = 1) &#123;&#125;).length) // 2 4. function的方法4.1 继承对象的方法4.2 函数的常用方法","tags":[{"name":"watermelon","slug":"watermelon","permalink":"https://mowatermelon.github.io/tags/watermelon/"},{"name":"js_thinking","slug":"js-thinking","permalink":"https://mowatermelon.github.io/tags/js-thinking/"},{"name":"funciton","slug":"funciton","permalink":"https://mowatermelon.github.io/tags/funciton/"}]},{"title":".NET学习之一般处理文件中使用SESSION","date":"2017-09-24T16:00:00.000Z","path":"2017/09/25/NET-learning-session/","text":"一 什么是一般处理文件1.1 WHAT虽然通过标准的方式可以创建处理程序，但是实现的步骤比较复杂，为了方便网站开发中对处理程序的应用，从ASP.NET 2.0开始，ASP.NET提供了称为一般处理程序的处理程序，允许我们使用比较简单的方式定义扩展名为ASHX的专用处理程序是一种较为简单、高效的处理程序，在非WEB窗体处理的请求中有着重要的作用。 1.2 WHY对于ASP.NET网站来说，网站最常规的处理结果就是HTML网页，生成网页的工作通常使用扩展名为ASPX的WEB窗体来完成。对于非WEB窗体处理的请求，都可以通过一般处理程序完成，适合产生供浏览器处理的、不需要回发处理的数据格式，例如生成RSS、FEED、XML、图片等动态内容。 ASHX通常是实现IHTTPHANDLER接口，因为不必继承自PAGE类，它免去了普通.ASPX页面的控件解析以及页面处理的过程，所以没有那么多事件需要处理，不必消耗太多资源，所以性能方面要比ASPX高。一般来说能够用一般处理文件实现的功能，就在一般处理文件中写，但是涉及到WEB窗体内容读取和修改的话，就会放到ASPX.CS中进行处理，一般在项目逻辑处理文件夹新建REMOTEHANDLE(远程处理文件夹)，然后把一般处理文件放在这个文件夹。 二 问题产生原因在WEBFORM中ASPX脚本中使用SESSION，是不用声明直接使用的。 1234567891011121314public void checkDemo()&#123; //声明 //session[&apos;键名&apos;]=&apos;键值&apos;; session[&apos;demo&apos;] = true; //使用 //以上文的设置的demo为例 bool isDemo = false; if(session[&apos;demo&apos;])&#123; isDemo = true; &#125; Response.Write(isDemo);&#125; 但是在一般处理程序ASHX中需要先引用对应的命名空间和继承对应SESSION接口，然后在项目中可以通过CONTEXT.SESSION[&quot;XX&quot;]大法才能正常调用SESSION，如果是未引用正确的命名空间，会报错SESSION对象未定义，如果是未继承正确的接口，会报错SESSION对象为空，不可用。 12345678910111213141516171819202122232425262728293031323334using System.Web;using System.Web.SessionState;namespace XXX.XXX.RemoteHandle&#123; /// &lt;summary&gt; /// XXX 的摘要说明 /// &lt;/summary&gt; public class XX : IHttpHandler, IRequiresSessionState &#123; public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = &quot;text/plain&quot;; string strType = context.Request[&quot;action&quot;]; switch (strType) &#123; case &quot;sessionDemo&quot;: SessionDemo(context); break; &#125; &#125; /// &lt;summary&gt; /// 在一般处理文件中使用session功能 /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt; private void SessionDemo(HttpContext context) &#123; context.Session[&quot;DEMO&quot;] = false; context.Response.Write(context.Session[&quot;DEMO&quot;]); &#125; &#125;&#125;","tags":[{"name":".NET","slug":"NET","permalink":"https://mowatermelon.github.io/tags/NET/"},{"name":"CS","slug":"CS","permalink":"https://mowatermelon.github.io/tags/CS/"},{"name":"SESSION","slug":"SESSION","permalink":"https://mowatermelon.github.io/tags/SESSION/"}]},{"title":".NET学习之基础学习","date":"2017-09-23T16:00:00.000Z","path":"2017/09/24/NET-learning-base/","text":"一 ASP.NET产生背景虽然可以使用JavaScript、Dom在浏览器端完成很多工作，但是功能还是有限，所以基于.NET的ASP.NET产生了，是一种动态网页技术，在服务器端运行.NET代码，动态生成HTML,然后响应给浏览器。 二 ASP.NET工作逻辑从使用的角度看，ASP.NET的运行过程包含页面请求、分析、编译、组装、页面缓冲五大环节。当客户端通过浏览器请求（Request）页面时，服务器端首先由页面分析器（Parser）对被请求的页面进行分析；再将通过分析的页面内容传递给编译器（Compiler）；经过编译器编译的页面内容被传输给组装缓存（Assembly Cache），同时，一些需要较高资源代价的元素可以创建一次后存人内存（Memory）；将组装缓存和内存中的内容有机结合后形成一个完整页面（包括数据、编译代码、HTML代码等），完整页面最后被送往输出缓存（Output Cache）。输出缓存中的内容将作为客户端的页面请求结果被送回浏览器。当同一页面被第二次请求时，服务器端将跳过所有中间环节，直接从输出缓存中送出页面请求结果。 三 ASP.NET文件解析3.1 概况 ASP.NET的页面文件是*.aspx，每个页面对应一个*.resx资源文件和一个*.aspx.cs的代码文件。 *.resx是资源文件。每个页面都有一个资源文件相对应。 global.asax是global.asa的.net版 global.asax.cs是global.asax的后台文件。 *.ascx是一个用户自定义控件。 *.ascx.cs是自定义控件的代码文件，C#的是*.ascx.cs *.ascx.resx是自定义控件的资源文件。 *.aspx.cs是*.aspx页面的后台代码。 web.config是整个Web Application的配置文件。 *.csproj是CS.NET的工程文件。 *.vsdisco是Web Service的文件。 *.csproj.webinfo是CS.NET工程文件的Web Application文件。 *.sln是VS.NET的解决方案文件。 其中global.asax,global.asax.cs,web.config,*.csproj,*.vsdisco,*.csproj.webinfo,*.sln都是在建立一个Web Application工程的时候自动产生的。 3.2 详细介绍 其中被加粗显示的文件类型，是我现在有所了解的，捂脸羞愧.jpg。 文件类型 位置 说明 .asax 应用程序根目录。 通常是 Global.asax 文件，该文件包含从 HttpApplication 类派生并表示该应用程序的代码。 有关更多信息，请参见 Global.asax 语法。 .ascx 应用程序根目录或子目录。 Web 用户控件文件，该文件定义自定义、可重复使用的用户控件。 有关更多信息，请参见 ASP.NET 用户控件。 .ashx 应用程序根目录或子目录。 一般处理程序文件，该文件包含实现 IHttpHandler 接口以处理所有传入请求的代码。 有关更多信息，请参见 HTTP 处理程序介绍。 .asmx 应用程序根目录或子目录。 XML Web services 文件，该文件包含通过 SOAP 方式可用于其他 Web 应用程序的类和方法。 有关更多信息，请参见 XML Web 服务的发布和部署。 .aspx 应用程序根目录或子目录。 ASP.NET Web 窗体文件，该文件可包含 Web 控件和其他业务逻辑。 有关更多信息，请参见 ASP.NET 网页和 ASP.NET Web 服务器控件。 .axd 应用程序根目录。 跟踪查看器文件，通常是 Trace.axd。 有关更多信息，请参见 ASP.NET 跟踪。 .browser App_Browsers 子目录。 浏览器定义文件，用于标识客户端浏览器的启用功能。 有关更多信息，请参见 ASP.NET Web 服务器控件和浏览器功能。 .cd 应用程序根目录或子目录。 类关系图文件。 有关更多信息，请参见使用类关系图，对于每个.cs后台脚本，都可以通过右键查看类图，显示脚本的相关内容，比如继承的类型、字段、嵌套类型和方法等 .compile Bin 子目录。 预编译的 stub（存根）文件，该文件指向相应的程序集。可执行文件类型（.aspx、ascx、.master、主题文件）已经过预编译并放在 Bin 子目录下。 有关更多信息，请参见 ASP.NET 网站预编译概述。 .config 应用程序根目录或子目录。 通常是 Web.config 配置文件，该文件包含其设置配置各种 ASP.NET 功能的 XML 元素。 有关更多信息，请参见 ASP.NET 配置文件。 .cs、.jsl、.vb App_Code 子目录；但如果是 ASP.NET 页的代码隐藏文件，则与网页位于同一目录。 运行时要编译的类源代码文件。类可以是 HTTP 模块、HTTP 处理程序，或者是 ASP.NET 页 HTTP 处理程序介绍的代码隐藏文件。 .csproj、.vbproj、vjsproj Visual Studio 项目目录。 Visual Studio 客户端应用程序项目的项目文件。 有关更多信息，请参见项目和解决方案。 .disco、.vsdisco App_WebReferences 子目录。 XML Web services 发现文件，用于帮助定位可用的 Web services。 有关更多信息，请参见 XML Web 服务的发布和部署。 .dsdgm、.dsprototype 应用程序根目录或子目录。 分布式服务关系图 (DSD) 文件，该文件可以添加到任何提供或使用 Web services的Visual Studio解决方案，以便对Web service交互的结构视图进行反向工程处理。 有关更多信息，请参见 XML Web 服务的发布和部署。 .dll Bin 子目录。 已编译的类库文件。或者，可以将类的源代码放在 App_Code 子目录下。 有关更多信息，请参见 ASP.NET 网站中的共享代码文件夹。 .licx、.webinfo 应用程序根目录或子目录。 许可证文件。控件创作者可以通过授权方法来检查用户是否得到使用控件的授权，从而帮助保护自己的知识产权。 有关更多信息，请参见如何：License 组件和控件。 .master 应用程序根目录或子目录。 母版页，它定义应用程序中引用母版页的其他网页的布局。 有关更多信息，请参见 ASP.NET 母版页。 .mdb、.ldb App_Data 子目录。 Access 数据库文件。 有关更多信息，请参见通过 ASP.NET 访问数据。 .mdf App_Data 子目录。 SQL 数据库文件。 有关更多信息，请参见通过 ASP.NET 访问数据。 .msgx、.svc 应用程序根目录或子目录。 Indigo Messaging Framework (MFx) service 文件。 .rem 应用程序根目录或子目录。 远程处理程序文件。 有关更多信息，请参见使用 SOAP 扩展修改 SOAP 消息。 .resources App_GlobalResources 或 App_LocalResources 子目录。 资源文件，该文件包含指向图像、可本地化文本或其他数据的资源字符串。有关更多信息，请参见应用程序中的资源或如何：为 ASP.NET 网站创建资源文件。 .resx App_GlobalResources 或 App_LocalResources 子目录。 资源文件，该文件包含指向图像、可本地化文本或其他数据的资源字符串。有关更多信息，请参见应用程序中的资源或如何：为 ASP.NET 网站创建资源文件。 .sdm、.sdmDocument 应用程序根目录或子目录。 系统定义模型 (SDM) 文件。 有关更多信息，请参见系统定义模型 (SDM) 概述。 .sitemap 应用程序根目录。 站点地图文件，该文件包含网站的结构。ASP.NET 中附带了一个默认的站点地图提供程序，它使用站点地图文件可以很方便地在网页上显示导航控件。 有关更多信息，请参见 ASP.NET 站点导航。 .skin App_Themes 子目录。 用于确定显示格式的外观文件。 有关更多信息，请参见 ASP.NET 主题和外观。 .sln Visual Web Developer 项目目录。 Visual Web Developer 项目的解决方案文件。 有关更多信息，请参见项目和解决方案。 .soap 应用程序根目录或子目录。 SOAP 扩展文件。有关更多信息，请参见使用 SOAP 扩展修改 SOAP 消息。 3.3 SOAP小课堂3.3.1 WHAT参考网站 简单对象访问协议是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计成在WEB上交换结构化的和固化的信息。 基于类对象的传输协议。 SOAP封装（envelop），它定义了一个框架，描述消息中的内容是什么，是谁发送的，谁应当接受并处理它以及如何处理它们； SOAP编码规则（encoding rules），它定义了一种序列化机制，用于表示应用程序需要使用的数据类型的实例； SOAP RPC表示（RPC representation），它定了一个协定，用于表示远程过程调用和应答； SOAP绑定（binding），它定义了SOAP使用哪种协议交换信息。使用HTTP/TCP/UDP协议都可以。 把SOAP绑定到HTTP提供了同时利用SOAP的样式和分散的灵活性的特点以及HTTP的丰富的特征库的优点。在HTTP上传送SOAP并不是说SOAP会覆盖现有的HTTP语义，而是HTTP上的SOAP语义会自然的映射到HTTP语义。在使用HTTP作为协议绑定的场合中，RPC请求映射到HTTP请求上，而RPC应答映射到HTTP应答。然而，在RPC上使用SOAP并不仅限于HTTP协议绑定。 SOAP、WSDL(WebServicesDescriptionLanguage)、UDDI(UniversalDescriptionDiscovery andIntegration)之一， SOAP用来描述传递信息的格式， WSDL 用来描述如何访问具体的接口， uddi用来管理，分发，查询webService 。 SOAP 可以和现存的许多因特网协议和格式结合使用，包括超文本传输协议（HTTP），简单邮件传输协议（SMTP），多用途网际邮件扩充协议（MIME）。它还支持从消息系统到远程过程调用（RPC）等大量的应用程序。SOAP使用基于XML的数据结构和超文本传输协议(HTTP)的组合定义了一个标准的方法来使用Internet上各种不同操作环境中的分布式对象。 3.3.2 HOW123456789101112131415161718&lt;?xml version=\"1.0\"?&gt;&lt;soap:Envelopexmlns:soap=\"http://www.w3.org/2001/12/soap-envelope\"soap:encodingStyle=\"http://www.w3.org/2001/12/soap-encoding\"&gt;&lt;soap:Header&gt;...&lt;/soap:Header&gt;&lt;soap:Body&gt;... &lt;soap:Fault&gt; ... &lt;/soap:Fault&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;","tags":[{"name":".NET","slug":"NET","permalink":"https://mowatermelon.github.io/tags/NET/"},{"name":"BASE","slug":"BASE","permalink":"https://mowatermelon.github.io/tags/BASE/"}]},{"title":"框架学习之Hexo建blog","date":"2017-09-12T06:29:17.000Z","path":"2017/09/12/framework-learning-hexo/","text":"1. 了解hexo A fast, simple &amp; powerful blog framework一个快速，简单和强大的博客框架 放上官网 2. 所需要的使用环境2.1. 软件环境2.1.1 markdown编辑器推荐vscode，一个颜值比较赞的编辑器，支持多种语言开发环境，主要是对于markdwon的插件也多，支持git版本管理或者svn版本管理，而且软件启动快，也支持多个终端命令行，记得安装相关以下推荐插件。 Auto-Open Markdown Preview 你打开一个markdown文件，右侧会对当前文件进行预览显示。 Markdown Preview Github Style 你打开一个markdown文件，预览效果与你在Github上的预览效果是一样的，VSCODE上默认的预览高亮不会改变背景颜色，只会改变字体颜色，还有和平常使用atom预览的效果有很多不同，所以你如果要用VSCODE写markdown，建议要安装这个。 markdownlint 管理现有markdown的格式正确性 terminal 支持多中命令的终端命令行 2.1.2 node放上安装地址，这个安装过程就可以一路next就好，当然你如果有强迫症要改变安装路径，记得修改安装地址，但是一定要记住安装路径，然后将安装路径下的node_global文件夹，或者指令安装的配置到环境变量中(计算机--&gt;右键属性--&gt;高级系统设置--&gt;环境变量)，对于node不一定要下载最新的版本，可以下载的LTS稳定版本，截止到20170918，node官网显示的最稳定的版本是v6.11.3 。 举个配置环境变量的栗子，我公司电脑系统盘是D盘，软件安装在系统盘，这边的默认全局安装路径是D:\\Program Files\\nodejs\\node_global，但是我家中的电脑，系统盘是C盘，软件不是安装在系统盘，所以全局安装之后的安装路径是C:\\Users\\Administrator\\AppData\\Roaming\\npm。 12345678910111213141516171819# 在node cmd中进行全局安装，将安装地址更换为国内的淘宝镜像地址D:\\Users\\Administrator&gt;npm i cnpm -g --registry=https://registry.npm.taobao.org# 在vscode终端中输入以下指令，如果能够正常输出版本号，就是安装成功PS x:\\xx\\xxxx&gt;node -vv6.9.4PS x:\\xx\\xxxx&gt;npm -v3.10.10PS x:\\xx\\xxxx&gt;cnpm -vcnpm@5.1.1 (D:\\Program Files\\nodejs\\node_global\\node_modules\\cnpm\\lib\\parse_argv.js)npm@5.4.1 (D:\\Program Files\\nodejs\\node_global\\node_modules\\cnpm\\node_modules\\npm\\lib\\npm.js)node@6.9.4 (D:\\Program Files\\nodejs\\node.exe)npminstall@3.1.4 (D:\\Program Files\\nodejs\\node_global\\node_modules\\cnpm\\node_modules\\npminstall\\lib\\index.js)prefix=D:\\Program Files\\nodejs\\node_globalwin32 x64 6.1.7601registry=http://registry.npm.taobao.org 一定要保证cnpm -v可以在vscode终端中正常执行，要不然后续通过hexo指令新建blog，会一直显示hexo指令未定义的。 2.1.3 github 注册github账号。 新建一个{注册呢称}.github.io的仓库。 进入新建好的仓库Settings，找到GitHub Pages，设置Source下的page页所处的branch，这个一般就选择master，然后选择Save。 成功之后该页面会显示 123Your site is published at https://&#123;注册呢称&#125;.github.io/Your GitHub Pages site is currently being built from the master branch. Learn more. 页面上可以直接选择Jekyll theme，随便选择一个主题，在浏览器中输入https://{注册呢称}.github.io/，看是否能够正常预览界面。 下载github客户端，在安装过程中记得不要一路点击next，其中有一步是询问git指令是全局安装还是仅能在git shell或者git bash中运行，软件默认是第一个，指令只能在git shell或者git bash中运行，请选择第二个，git指令所有的命令行工具都可以运行。20170913的最新版vscode支持powershell，cmd和bash终端命令行，这个限制可以不用管了。 123# 在vscode终端中验证git指令能不能全局执行PS x:\\xx\\xxxx&gt;git --versiongit version 2.10.2.windows.1 验证git命令是否能够全局执行，这个很重要，要不然你在非git命令行面板中，是不能执行hexo将blog推送到远程仓库的。 2.2. 相关依赖包 12345678910111213141516# 在node cmd中进行全局安装，cnpm i hexo-cli -g# 在vscode终端中输入以下指令，安装成功的效果PS x:\\xx\\xxxx&gt;hexo -vhexo-cli: 1.0.3os: Windows_NT 6.1.7601 win32 x64http_parser: 2.7.0node: 6.9.4v8: 5.1.281.89uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 48openssl: 1.0.2j 全局安装之后，会提示安装路径，如果该路径你之前已经设置成环境变量就不用管，但是如果提示的安装路径你没有设置过环境变量，你就会发现这个全局安装的指令一直跑不了，记得把提示的安装路径设置成环境变量。 2.3. hexo初始化 在文件本地新建测试项目文件，右键在vscode中打开 12345678910111213141516# 在vscode终端中输入以下指令，安装成功的效果PS x:\\xx\\xxxx&gt;hexo init #博客初始化PS x:\\xx\\xxxx&gt;npm install #安装相关依赖包# 成功之后查看blog文件夹中的内容是否正常生成PS x:\\xx\\xxxx&gt;dirMode LastWriteTime Length Name---- ------------- ------ ----d---- 2017/9/12 9:05 .vscode #vscode自动生成的，可以忽略d---- 2017/9/12 9:06 node_modules #安装相关环境d---- 2017/9/12 9:06 scaffolds #转化不同layout的markdown文章的模板d---- 2017/9/12 9:06 source #markdown文章所在地d---- 2017/9/12 9:06 themes #主题-a--- 2017/9/12 14:32 174 db.json #source解析所得到的-a--- 2017/9/3 1:36 721 package.json #项目所需模块项目的配置信息-a--- 2017/9/8 16:30 2460 _config.yml #博客的主要配置 2.4. 必须要配置的文件2.4.1. 在根目录_config.yml里修改配置12345678910111213141516171819202122232425# Sitetitle: &#123;&#123;你想要显示在网页title上的名称&#125;&#125;subtitle: &#123;&#123;你想要显示在网页上的座右铭&#125;&#125;description: &#123;&#123;你想要显示在网页上的描述&#125;&#125;author: &#123;&#123;你想要显示在网页的呢称&#125;&#125;language: chinesetimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://&#123;&#123;注册呢称&#125;&#125;.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults:····# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/&#123;&#123;注册呢称&#125;&#125;/&#123;&#123;注册呢称&#125;&#125;.github.io.git branch: master···· 2.4.2. 主题文件夹中_config.yml里添加配置如果没有更换主题的话，就在默认主题landscape中的_config.yml里添加配置，如果已经更换主题，请在对应的主题文件夹中的_config.yml里添加配置。 12345678910111213141516171819# SubNav# 如果你想将网站与某个你的个人账户管理显示，正确配置之后，就放开对应的账号前面的 # 号subnav: github: \"https://github.com/&#123;&#123;注册呢称&#125;&#125;\" #weibo: \"#\" #rss: \"#\" zhihu: \"https://www.zhihu.com/people/&#123;&#123;注册呢称&#125;&#125;/activities\" #qq: \"#\" #weixin: \"#\" #jianshu: \"#\" #douban: \"#\" #segmentfault: \"#\" #bilibili: \"#\" #acfun: \"#\" #mail: \"mailto:&#123;&#123;你的呢称&#125;&#125;\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\" 2.5. 预览效果1234567# 现在本地预览效果PS x:\\xx\\xxxx&gt;hexo s --watchINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.# 如果本地blog内容已经修改完成，生成本地静态文件，上传到github上去PS x:\\xx\\xxxx&gt;hexo d -g 在浏览器中输入https://github.com/{注册呢称}/{注册呢称}.github.io，查看文件是否上传成功，如果全部上传成功，这个仓库下的文件内容应该和本地的public中的文件一模一样。然后在浏览器中输入https://{注册呢称}.github.io/，看是否能够看到blog相关内容。 3. 可能遇见的问题3.1 git指令无效 环境变量没有正确配置，请将git路径所在文件夹，配置到环境变量中 3.2 hexo指令无效 环境变量没有正确配置，请将hexo路径所在文件夹，配置到环境变量中 3.3 上传到github上之后页面404 查看上传文件中没有index.html，如果没有请检查一下本地根目录的package.json文件，看一下安装包是否完整，如果不完整的话，请在vscode中执行cnpm i --save ，一定要记得写--save，这样依赖包安装才会保存到package.json，避免以后重复安装。 12345678910111213141516 \"dependencies\": &#123; \"hexo\": \"^3.2.0\", \"hexo-deployer-git\": \"^0.3.1\", \"hexo-deployer-openshift\": \"^0.1.2\", \"hexo-deployer-rsync\": \"^0.1.3\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.2.0\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-sitemap\": \"^1.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.0\", \"hexo-renderer-marked\": \"^0.3.0\", \"hexo-renderer-stylus\": \"^0.3.1\", \"hexo-server\": \"^0.2.2\"&#125; 3.4 不知道怎么更换主题 官方主题shop，你可以选择你想要的主题，每个主题的readme.md中都有相关说明，日常摊手.jpg，我肯定是要拿自己改写的主题做例子，我主题的名称是melon，如果大家对这个主题有什么好的建议，可以直接这个仓库下提issues进行相关建议。 安装 1234# 在vscode终端中输入以下指令，这个是在项目根文件夹下执行这个指令PS x:\\xx\\xxxx&gt;git clone &#123;主题github地址&#125; themes/&#123;你想设置的主题名称&#125;#举个栗子PS x:\\xx\\xxxx&gt;git clone https://github.com/mowatermelon/hexo-theme-melon.git themes/melon 配置 修改hexo根目录下的_config.yml 1234#主题一定要和上文对应theme: &#123;你想设置的主题名称&#125;#举个栗子theme: melon 主题更新 123456#主题一定要和上文对应cd themes/&#123;你想设置的主题名称&#125;git pull#举个栗子cd themes/melongit pull 3.5 全局安装了hexo但是命令无效我最近电脑刚换了系统（2017-11-23），全局安装的hexo是比较新的，全局安装完成之后，我在cmd中执行hexo -v，是正常的，但是在进入blog所在文件夹的时候，hexo s --watch指令不能正常使用，当时以为我打开文件夹的方式不对，最后测试得出，是一个hexo相关环境包hexo-deployer-heroku有问题，主要问题是hexo-deployer-heroku所依赖包中一个叫swig的包已经找不到了，所以这边找hexo-deployer-heroku的就找不到，然后导致hexo看到自己所依赖的包找不到，特别委屈巴巴，他就不想运行了，把package.json中hexo-deployer-heroku删掉就好了。 这次错误主要是我使用指令的时候一般只关注error，不关注warning，其实在将远程仓库clone到本地之后，使用cnpm install的时候，就看到安装了17个环境包，没有关注下面的warning，再次执行cnpm install，warning不会再次出现，所以在第一次warning警告出现的时候，就需要仔细看一下，可能以后就不出现了，那之后就发现不了问题实质了。 4. hexo的相关指令和参数4.1 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是默认提供的参数，可以将这些参数添加到scaffolds/**.md中。 预定参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 4.2 默认指令1Usage: hexo &lt;command&gt; Commands: 可选参数名 官方解释 个人解读 hexo clean Remove generated files and cache. 清除所有生成的网页文件夹和数据缓存，主要是清除项目中hexo -g生成的public文件夹中内容，或者通过hexo s --watch生成网站的一些数据缓存 hexo config Get or set configurations. 获取当前的hexo所有配置 hexo deploy Deploy your website. 将本地的blog推送到对应的git仓库，使用缩写d也可以执行，一般执行hexo d -g hexo generate Generate static files. 将本地静态md文件生成对应的静态blog文件，使用缩写g也可以执行，本地预览的时候一般执行hexo g --watch，也会结合deploy，如hexo g -d，一键生成和部署，生成的文件一般在本地项目public文件夹中 hexo help Get help on a command. 当对某个指令用法不太清楚的时候，可以用这个指令 hexo init Create a new Hexo folder. hexo的初始化，自动下载默认的博客主题和相关依赖包 hexo list type List the information of the site 列出当前文件夹的文件列表，type的类型可以为 page, post, route, tag, category，type参数为必填参数 hexo migrate type source Migrate your site from other system to Hexo. 从其他blog系统迁移到hexo blog，目前需要通过指令迁移的支持的type参数是joomla、rss和wordpress，详细说明请看4.3.2 hexo new layout title Create a new post. 生成规定layout和规定title的md文件，layout可以是post, page, draft or whatever you want，title是生成的md文件名，内容可以是whatever you want，但是请注意使用英文名，也不要出现太多奇怪符号。 hexo publish layout filename Moves a draft post from _drafts to _posts folder. 将md文件从draft中发布成post模版格式，在post中的md文件在执行hexo s时在页面才会被看到，layout参数为选填参数，默认是draft，filename参数为必填参数，文件名必须是source/_drafts中已经存在的文件名 hexo render Render files with renderer plugins. 强制将文件进行渲染，可参考4.3.1 hexo server Start the server. 启动hexo本地服务，在本地查看网页运行效果，并且实时监听页面变化，可以简写成hexo s --watch hexo version Display version information. 查看本地hexo版本，还可以写成hexo v或者hexo -v Global Options: 可选参数名 官方解释 个人解读 –config Specify config file instead of using _config.yml 展示_config.yml的配置内容 –cwd Specify the CWD 目前不理解 –debug Display all verbose messages in the terminal 会把运行过程中的内容记录到debug.log –draft Display draft posts 显示文章草稿 –safe Disable all plugins and scripts 禁用所有插件和脚本 –silent Hide output on console 隐藏在控制台输出 4.3 复杂指令的说明4.3.1 手动渲染文章格式（目前没有发现有什么用）1PS x:\\xx\\xxxx&gt;hexo render &lt;file1&gt; [file2] ... Description: Render files with renderer plugins (e.g. Markdown) and save them at the specified path. Options: 备选参数名 官方解释 个人解读 –engine Specify render engine 自定义渲染引擎 –output Output destination. Result will be printed in the terminal if the output destination is not set. 指令执行时的默认在终端打印的提示文本内容 –pretty Prettify JSON output 将文件中的json进行格式化输出 4.3.2 如何从其他blog系统进行迁移 RSS 首先，安装 hexo-migrator-rss 插件。 1PS x:\\xx\\xxxx&gt;npm install hexo-migrator-rss --save 插件安装完成后，执行下列命令，从 RSS 迁移所有文章。source 可以是文件路径或网址。 1PS x:\\xx\\xxxx&gt;hexo migrate rss &lt;source&gt; Jekyll 把 _posts 文件夹内的所有文件复制到 source/_posts 文件夹，并在 _config.yml 中修改 new_post_name 参数。 1new_post_name: :year-:month-:day-:title.md Octopress 把 Octopress中source/_posts 文件夹内的所有文件转移到 Hexo 的 source/_posts 文件夹，并修改 _config.yml 中的 new_post_name 参数。 1new_post_name: :year-:month-:day-:title.md WordPress 首先，安装 hexo-migrator-wordpress 插件。 1PS x:\\xx\\xxxx&gt;npm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考WP支持页面）。 插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。 1PS x:\\xx\\xxxx&gt;hexo migrate wordpress &lt;source&gt; 注意 这个插件并不能完美地实现WordPress-&gt;Hexo的数据转换，尤其是在处理WordPress的分类方面存在问题（见Front-matter中的分类与标签）。因此，建议您在迁移完成后，手工审阅所有生成的markdown文件，检查其中是否有错误。对于文章数量较大的WordPress站点，这项工作可能要花很长的时间。 Joomla 首先，安装 hexo-migrator-joomla 插件。 1PS x:\\xx\\xxxx&gt;npm install hexo-migrator-joomla --save 使用 J2XML 组件导出 Joomla 文章。插件安装完成后，执行下列命令来迁移所有文章。source 可以是 Joomla 导出的文件路径或网址。 1PS x:\\xx\\xxxx&gt;hexo migrate joomla &lt;source&gt; 4.3.3 发布文章1Usage: hexo new [layout] &lt;title&gt; Description: Create a new post. Arguments: 必要参数名 官方解释 个人解读 layout Post layout. Use post, page, draft or whatever you want. 新建的md模板类型，非必写，默认是draft title Post title. Wrap it with quotations to escape. 新建的md文件名称，必写 Options: 必要参数名 官方解释 个人解读 -p, –path Post path. Customize the path of the post. 自定义生成的文章地址 -r, –replace Replace the current post if existed. 对于已经存在的文件进行重写的时候，直接替换，要不然会新建不成功 -s, –slug Post slug. Customize the URL of the post. 文章缩略名，自定义文章显示的url地址中文章名","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"node","slug":"node","permalink":"https://mowatermelon.github.io/tags/node/"},{"name":"hexo","slug":"hexo","permalink":"https://mowatermelon.github.io/tags/hexo/"},{"name":"vscode","slug":"vscode","permalink":"https://mowatermelon.github.io/tags/vscode/"},{"name":"github page","slug":"github-page","permalink":"https://mowatermelon.github.io/tags/github-page/"},{"name":"markdown","slug":"markdown","permalink":"https://mowatermelon.github.io/tags/markdown/"}]},{"title":"框架学习之Angular_app学习","date":"2017-09-03T16:00:00.000Z","path":"2017/09/04/framework-learning-angular-SPA/","text":"本文档是学习Angular JS 仿拉勾网 WebApp 开发移动端单页应用学习日志 1 了解涉及到的技术1.1 angular诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。 angular主要使用到的概念，module diretive 表达式 service injector 依赖注入 模型 filter 数据绑定 $scope controller view，对于其中部分进行相关解释。 module 模块 所有的东西必须先放在模块中 才会正常运行 魔法书 directive 指令 召唤魔法定义:通过HTML标签、属性、样式或注释使Angular编译器居来为指定的DOM元素绑定特定的行为，甚至是改变DOM元素和它的子元素。 内置指令:ng-model,ng-bind,ng-click,ng-class,ng-if,ng-hide,ng-repeat 自定义指令常用属性:template,templateUrl,link,restrict,scope,transclude service 服务 共有的代码逻辑 攻击魔法 controller 控制器 私有的代码逻辑 辅助魔法 filter 过滤器 对数据进行过滤 view 视图 指令是angular的灵魂 核心 angular webapp 结构图 1.2 bowertwitter 推出的一款包管理工具，基于The Only Real Dev Language的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。包是指一系列有意义的资源的集合，在bower这里，更多体现在json文件，它是这些资源的配置文件，一个完整的包都应该有一个bower.json文件。管理包含获取，下载，安装，更新，查找,注册等等一系列对资源的操作。 1.2.1 基础功能`注册模块`：每个包需要确定一个唯一的 ID 使得搜索和下载的时候能够正确匹配 `文件存储`：把文件存储在一个有效的网络地址上,使用的时候可以直接下载到 `上传下载`：你可以把你的包注册后上传存储，使用的时候可以使用一条命令直接下载到当前项目 `依赖分析`：它帮我们解决了包与包直接的依赖关系，当我们下载一个`包A`的时候,由于它依赖`包B`,所以`bower`会自动帮我们下载好`包B` 1.2.2 Bower 与 npm 的关系npm是专门管理node模块的管理工具，而bower是node的模块，因为bower是依赖node，npm和git。正如前面所言，npm是擅长的是管理node模块，而bower管理的范围更大，涉及html,css,js和图片等媒体资源。或许，这也是人们喜欢在服务器端使用npm,而在客户端使用bower。 1.2.3 为什么要使用Bower? 节省时间 为什么要学习Bower的第一个原因，就是它会为你节省寻找客户端的依赖关系的时间。一般安装jQuery的时候，都需要去jQuery网站下载包或使用CDN版本。但是有了Bower，只需要输入一个命令，jquery就会安装在本地计算机上，你 不需要 去记版本号之类的东西，你也可以通过Bower的info命令去查看任意库的信息。 脱机工作 Bower会在用户主目录下创建一个.bower的文件夹，这个文件夹会下载所有的资源、并安装一个软件包使它们可以离线使用。如果你熟悉Java，Bower即是一个类似于现在流行的Maven构建系统的.m2仓库。每次你下载任何资源库都将被安装在两个文件夹中 —— 一个在的应用程序文件夹，另一个在用户主目录下的.bower文件夹。因此，下一次你需要这个仓库时，就会用那个用户主目录下.bower中的版本。 可以很容易地展现客户端的依赖关系 你可以创建一个名为json的文件，在这个文件里你可以指定所有客户端的依赖关系，任何时候你需要弄清楚你正在使用哪些库，你可以参考这个文件。 让升级变得简单 假设某个库的新版本发布了一个重要的安全修补程序，为了安装新版本，你只需要运行一个命令，bower会自动更新所有有关新版本的依赖关系。 1.3 gulpgulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 123456789101112gulp.src() //读取文件和文件夹gulp.dest() //生成文件和文件夹gulp.watch() //监控文件和文件夹gulp.task() //定制任务gulp.pipe() //用流的方式处理文件//举个栗子gulp.task('happyLife',function()&#123; gulp.src('happyPepople/life/**/*') .pipe(gulp.dest(EVA.devPath)) .pipe(gulp.dest(EVA.proPath)) .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;); 1.4 less 样式预处理器LESS将CSS赋予了动态语言的特性，是css预编译处理，如变量，继承，运算，函数。LESS既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可以借助Node.js或者Rhino在服务端运行。本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。 1.4.1 基础使用案例1234567891011121314151617181920212223242526//这里是一些简单的LESS语法//@import 'a.less'//自动计算依赖文件生成对应的综合的css文件@width:400px;@height:300px;@font_size:12px;@bg:#111;textarea &#123; width:@width; height:@height; font-size:@font_size;&#125;.bg&#123; .fun(123px);/*调用相关函数*/ background-color:@bg; .select&#123; width:@width; &#125; &amp;:after&#123; content:''; &#125;&#125;.fun(@px)&#123; height:@px;&#125; 1.4.2 生成的css文件形式123456789101112131415textarea &#123; width: 400px; height: 300px; font-size: 12px;&#125;.bg &#123; height: 123px; background-color: #111111;&#125;.bg .select &#123; width: 400px;&#125;.bg:after &#123; content: '';&#125; 1.5 单页应用单页应用（SPA）是指在浏览器中运行的应用，它们在使用期间不会重新加载页面。像所有的应用一样，它旨在帮助用户完成任务，比如编写文档或者管理Web服务器。可以认为单页应用是一种从Web服务器加载的富客户端。说白就是无刷新，整个webapp就一个html文件，里面的各个功能页面是javascript通过hash,或者history api来进行路由，并通过ajax拉取数据来实现响应功能。因为整个webapp就一个html，所以叫单页面。单页应用的页面切换流畅,属于前后端分离的典型。 2 安装相关环境先安装好node和git bash两个软件，注意安装git bash不要一路点击next，其中有一步是询问git指令是全局安装还是仅能在git shell或者git bash中运行，软件默认是第一个，指令只能在git shell或者git bash中运行，请选择第二个，git指令所有的命令行工具都可以运行。当然如果你本地已经安装过github客户端，那你就不用安装这个软件，直接通过git shell就可以了。对于node不一定要下载最新的版本，可以下载之前的稳定版本，然后通过node命令指示符全局安装相关环境。 12345678# 已经翻墙npm install -g bowernpm install -g gulp# 未翻墙npm install cnpm -g --registry=https://registry.npm.taobao.orgcnpm i -g bowercnpm i -g gulp 将安装指令的文件夹配置到系统环境变量PATH中(计算机--&gt;右键属性--&gt;高级系统设置--&gt;环境变量)，我公司电脑系统盘是D盘，这边的默认全局安装路径是D:\\Program Files\\nodejs\\node_global，但是我家中的电脑，系统盘是C盘，全局安装之后的安装路径是C:\\Users\\Administrator\\AppData\\Roaming\\npm，每次全局安装之后，会提示安装路径，如果该路径你之前已经设置成环境变量就不用管，但是如果提示的安装路径你没有设置过环境变量，你就会发现这个全局安装的指令一直跑不了，还有就是bower指令这个是基于git指令的，如果你的github在安装的时候没有设置全局安装，还需要手动将git指令所在文件夹配置到环境变量中，我就是由于前期安装了github客户端，直接用的git shell,git的声明路径应该是C:\\Users\\Administrator\\AppData\\Local\\GitHub\\PortableGit_f02737a78695063deace08e96d5042710d3e32db\\mingw32\\bin，就是你本地github安装路径下的bin文件夹，具体地址请根据实际情况配置。 3 开始写项目3.1 git初始化如果上一步没有将git指令设置全局可用，那么需要在其他终端进行git初始化，如果没有设置的话，将gitbash添加到右键功能栏，相关教程,或者将git shell添加到右键功能栏。但是如果已经将git指令设置为所有终端都可以用，那就直接在vscode终端中输入相关指令，新建项目文件夹，并在项目文件夹中执行git初始化。 1git init 执行完成之后，空项目文件夹中应该有以下文件夹 12345- .git - hooks - info - objects - refs 3.2 bower初始化在项目文件夹中右键选择open with code，在vscode中打开当前项目文件,如果没有下载的可以点击链接进行下载Download scode，请注意一定要先git初始化，再bower初始化，要不然会报错，说当前文件夹找不到git相关文件，在终端中输入bower初始化指令。 12345678910111213141516171819202122232425262728293031323334353637383940bower init? name angular_app # 项目名称? description this is a test angular webapp # 项目描述? main file # 项目主目录? keywords angular gulp less bower # 项目关键词? authors mowatermelon # 作者名称? license MIT # 项目版权? homepage # 项目主页? set currently installed components as dependencies? Yes # 现在是否已经按照一些组件，请根据实际情况输入 yes or no? add commonly ignored files to ignore list? Yes# 是否忽略一些默认需要忽略检测的文件 yes or no? would you like to mark this package as private which prevents it from being ac? would you like to mark this package as private which prevents it from being accidentally published to the registry? Yes# 是否把这个包标记为私有，防止它成为ac yes or no&#123; name: 'angular_app', authors: [ 'mowatermelon' ], description: 'this is a test angular webapp', main: '', keywords: [ 'angular', 'gulp', 'less', 'bower' ], license: 'MIT', homepage: '', private: true, ignore: [ '**/.*', 'node_modules', 'bower_components', 'test', 'tests' ]&#125;? Looks good? Yes//相关文件夹是否正确生成 bowerrc处理 重新配置bower包安装路径，非必要步骤，bower下载的包默认的安装路径是bower_components，如果你看到默认文件夹名字特别不爽，是换一个文件夹放安装包，注意新建.bowerrc文件有一定窍门。 1234//新建`.bowerrc`路径配置文件，这个必须通过指令新建，`window`默认文件必须有文件名PS X:\\XX\\demo&gt;null&gt;.bowerrc//命令执行之后会新建文件，但是会报错，这个报错可以忽略。//该命令只能在系统或者`node`的命令管理器中执行，请注意这个语句在`vscode`终端中是不能执行的 在.bowerrc文件中配置以下json，设置默认bower的包下载文件夹名称 123&#123; \"directory\": \"lib\"&#125; 3.3 bower 安装运行相关包3.3.1 举个安装的完整栗子1234567891011121314 bower install --save angular # 默认安装不是不会更新到包管理中的，需要添加--save 才会自动保存到bower管理中。 # 针对移动端不存在兼容性，如果是pc项目，需要考虑ie兼容，需要安装低版本 # bower install --save angular#1.2 bower not-cached https://github.com/angular/bower-angular.git#* bower resolve https://github.com/angular/bower-angular.git#* bower download https://github.com/angular/bower-angular/archive/v1.6.6.tar.gz bower extract angular#* archive.tar.gz bower resolved https://github.com/angular/bower-angular.git#1.6.6 bower install angular#1.6.6angular#1.6.6 bower_components\\angular# 添加到配置文件 3.3.2 安装依赖包然后在vscode终端中开始安装其他包 12345678910111213 bower install --save requirejs bower install --save ui-router#0.4.2# 如果你想按照课程学下去，# 请注意一定要安装这个指定ng路由版本(ui-router)，# 或者你可以去研究一下最新版怎么玩，你就不用管版本了# 这边不指定版本，直接安装最新版本的话，# 反正我这边是在安装最新的是`1.0.6`，# 安装下来之后，完全找不到`angular-ui-router.js`这个文件，# 然后我安装网上的安装# \"angular-ui-router\": \"0.2.8-bowratic-tedium\"，# 结果控制台一直报各种\"transition\"的错，# 程序都还没有做什么，就这么多错，真的气到原地爆炸.gif bower install --save mdui # 这个样式库不一定要安装，只是个人喜好 3.3.3 卸载依赖包如果发现包安装错误或者安装多余可以进行包的卸载 12bower uninstall --save requirejs #卸载相关包并且修改bower.json，推荐这种卸载bower uninstall requirejs #仅卸载相关包不会修改bower.json 3.3.3 复制配置好的bower.json或者你想偷懒不想通过指令去安装，可以直接把我这边配置好的bower.json的dependencies内容直接拿过去用，然后直接执行bower install就好，其中mdui这个是我个人喜欢的一个样式框架，非必须安装。 123456\"dependencies\": &#123; \"angular\": \"^1.5.5\", \"angular-resource\": \"^1.5.6\", \"angular-ui-router\": \"^0.4.2\", \"mdui\": \"^0.3.0\"&#125; 3.4 npm安装服务环境相关包12 npm install --save-dev gulp gulp-clean gulp-concat gulp-connect gulp-cssmin gulp-imagemin gulp-less gulp-load-plugins gulp-uglify open# 每个模块之间通过空格隔开，可以进行批量安装 相关说明 依赖包名 功能 gulp 必要的运行包，毕竟还要靠gulp干大事 gulp-load-plugins 协助gulp找到其他gulp子包一起玩的类似脚手架之类的感觉 gulp-clean 在gulp-load-plugins的召唤下，可以清理相关文件夹 gulp-concat 在gulp-load-plugins的召唤下，可以整合文件夹下的所有js文件合并成一个文件 gulp-connect 在gulp-load-plugins的召唤下，可以重新刷新当前页面保证在编辑器中做修改，浏览器自动刷新展示 gulp-cssmin 在gulp-load-plugins的召唤下，可以压缩生成的css文件，在生产环境下的css文件需要进行压缩 gulp-imagemin 在gulp-load-plugins的召唤下，可以压缩生成的image文件，在生产环境下的image文件需要进行压缩 gulp-less 在gulp-load-plugins的召唤下，可以编译less文件生成正常的css文件 gulp-uglify 在gulp-load-plugins的召唤下，可以压缩生成的js文件，在生产环境下的js文件需要进行压缩 open 可以打开配置好的对应端口网页 配置好的package.json 最后放上安装好的配置，可以直接把我这边配置好的package.json的devDependencies内容直接拿过去用，然后直接执行npm install就好，或者你使用的是淘宝镜像，执行cnpm install就好。 123456789101112\"devDependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-load-plugins\": \"^1.5.0\", \"gulp-clean\": \"^0.3.2\", \"gulp-concat\": \"^2.6.1\", \"gulp-connect\": \"^5.0.0\", \"gulp-cssmin\": \"^0.2.0\", \"gulp-imagemin\": \"^3.3.0\", \"gulp-less\": \"^3.3.2\", \"gulp-uglify\": \"^3.0.0\", \"open\": \"0.0.5\"&#125; 3.5 编写相关gulp命令在当前项目的根目录下新建一个gulpfile.js，请注意文件名一定要正确，并编写相关gulp指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133var gulp =require('gulp');//调用总指令var $ = require('gulp-load-plugins')();//请注意一定要写后面这个空括号对，代表直接调用这个函数var open = require('open');var app =&#123; srcPath:'src/',//默认需要做处理的原始文件夹路径 devPath:'build/',//开发环境文件夹名字 proPath:'dist/'//生产环境文件夹名字&#125;/*gulp.task(taskName,callback);*/gulp.task('lib',function()&#123; gulp.src('lib/**/*.min.js') /* 获取bower安装包路径二级目录下所有已经压缩过的js， 色 请注意如果你之前没有使用bowerrc文件修改， 这里的lib文件名应该是默认的bower_components， vendor是供应商的意思，这个名字不是固定的，可换。 */ .pipe(gulp.dest(app.devPath+'vendor'))//复制文件到开发环境 .pipe(gulp.dest(app.proPath+'vendor'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);gulp.task('html',function()&#123; gulp.src(app.srcPath+'**/*.html')//获取src文件夹下所有的html文件 .pipe(gulp.dest(app.devPath))//复制文件到开发环境 .pipe(gulp.dest(app.proPath))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);gulp.task('json',function()&#123; gulp.src(app.srcPath+'data/**/*.json')// /* 因为不连接数据库，需要做数据mock，获取moock文件夹下所有的json文件， 如果直接连接数据库的话，就不用写 这个任务 */ .pipe(gulp.dest(app.devPath+'data'))//复制文件到开发环境 .pipe(gulp.dest(app.proPath+'data'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);/*MDUI大法好 以md开头的任务都是我为MDUI大法写的，如果你不用这个样式库可以直接忽略*/gulp.task('mdcss',function()&#123; gulp.src('lib/mdui/src/mdui.less')//这个lib文件夹注意对应你本地的bower安装包路径 .pipe($.less())//编译less成对应的css文件 .pipe(gulp.dest(app.devPath+'css'))//复制文件到开发环境 .pipe($.cssmin())//生产环境的样式文件需要压缩生成的 .pipe(gulp.dest(app.proPath+'css'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);gulp.task('mdfont',function()&#123; gulp.src('lib/mdui/dist/fonts/**/*')//这个lib文件夹注意对应你本地的bower安装包路径 .pipe(gulp.dest(app.devPath+'fonts'))//复制文件到开发环境 .pipe(gulp.dest(app.proPath+'fonts'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);gulp.task('mdicon',function()&#123; gulp.src('lib/mdui/dist/icons/**/*') /* 这个lib文件夹注意对应你本地的bower安装包路径, 注意这个还有一个坑，就是mdui下的字体图标路径相对不是fonts下， 原本的相对路径是../icons/material-icons/ 如果你想和我一样偷懒，把所有字体文件放到fonts下， 需要修改lib/mdui/src/icon/less/material-icons.less文件， 将字体文件路径都修改为 ../fonts/material-icons/， */ .pipe(gulp.dest(app.devPath+'fonts'))//复制文件到开发环境 .pipe(gulp.dest(app.proPath+'fonts'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);/*MDUI大法相关任务完结*/gulp.task('less',function()&#123; gulp.src(app.srcPath+'style/index.less')//复制在src下我们自己定义样式的总less文件，注意在该文件中，导入其他自定义样式less文件 .pipe($.less())//编译less成对应的css文件 .pipe(gulp.dest(app.devPath+'css'))//复制文件到开发环境 .pipe($.cssmin())//生产环境的样式文件需要压缩生成的 .pipe(gulp.dest(app.proPath+'css'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);gulp.task('js',function()&#123; gulp.src(app.srcPath+'script/**/*.js')//复制在src下我们自己写的所有js文件，注意指明文件格式 .pipe($.concat('index.js'))//把所有的js文件都整合成一个index.js文件 .pipe(gulp.dest(app.devPath+'js'))//复制文件到开发环境 .pipe($.uglify())//生产环境的js文件需要压缩生成的 .pipe(gulp.dest(app.proPath+'js'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);gulp.task('image',function()&#123; gulp.src(app.srcPath+'image/**/*')//复制在src下所有图片文件 .pipe(gulp.dest(app.devPath+'image'))//复制文件到开发环境 .pipe($.imagemin())//生产环境的图片文件需要压缩生成的 .pipe(gulp.dest(app.proPath+'image'))//复制文件到生产环境 .pipe($.connect.reload());//只要编译命令执行就刷新页面&#125;);gulp.task('build',['image','js','mdcss','mdfont','mdicon','less','lib','html','json']);gulp.task('serve',['build'],function()&#123; $.connect.server(&#123; root:[app.devPath],//默认的环境是开发环境，可以成修改成生产环境 app.proPath livereload:true,//是否实时监听，这个需要结合谷歌插件 port:1234//端口号，只要配置未被占用的端口号就行 &#125;); open('http://localhost:1234');//自动打开绑定的端口界面 gulp.watch(app.srcPath+'script/**/*.js',['js']);//监听自定义的js改动情况 gulp.watch(app.srcPath+'lib/**/*.js',['lib']);//监听加载其他插件的js改动情况 gulp.watch(app.srcPath+'**/*.html',['html']);//监听自定义的html改动情况 gulp.watch(app.srcPath+'data/**/*.json',['json']);//监听mook数据的改动情况 gulp.watch(app.srcPath+'lib/mdui/src/mdui.less',['mdcss']);//监听MDUI的样式文件的改动情况 gulp.watch(app.srcPath+'lib/mdui/dist/fonts/**/*',['mdfont']);//监听MDUI的主要字体文件的改动情况 gulp.watch(app.srcPath+'lib/mdui/dist/icons/**/*',['mdicon']);//监听MDUI的图标字体文件的改动情况 gulp.watch(app.srcPath+'style/index.less',['less']);//监听自定义的样式文件改动情况 gulp.watch(app.srcPath+'image/**/*',['image']);//监听图片文件改动情况&#125;);gulp.task('default',['serve']);//gulp默认执行的命令会执行的任务，即直接输入gulp就会执行的任务gulp.task('clean',function()&#123; gulp.src([app.devPath,app.proPath]) /* 当你觉得生产和开发环境中的文件中生成的错误文件比较多， 可以直接清理相关文件夹 可以执行该任务 */ .pipe($.clean());&#125;); 编写完成之后可以直接执行gulp命令就可以直接在生产和开发环境中生成对应文件，并且自动打开对应网页界面，当然，也可以单独执行一下执行，都是可以单独运行。 12345678910gulpgulp libgulp htmlgulp jsongulp mdcssgulp mdfontgulp mdicongulp lessgulp imagegulp clean 3.6 开始写界面3.6.1 hello World在src文件夹下新建index.html,当然也可以是其他名字，但是一般默认的就主页面名字就写index,添加相应的样式文件和js文件，写一个hello World，通过gulp指令，页面就自动打开在眼前，如果页面顺利打开，并且控制台没有任何报错，对应文件下所有文件都是正确生成，那么就继续往下走，如果控制台有报错，请往前看，是否有没有注意的细节。 src/index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;angular-webapp&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/mdui.css\"&gt;&lt;!--导入mdui样式文件--&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\"&gt;&lt;!--告诉angular这个范围的内容，都可以用ng指令，你注意ng-scope--&gt; &lt;div class=\"mdui-container\"&gt; &lt;div class=\"mdui-typo-display-4-opacity\"&gt;hello World&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"vendor/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;!--导入angular JS文件--&gt;&lt;script src=\"js/index.js\"&gt;&lt;/script&gt;&lt;!--一定要记得调用，要不然angular会召唤不成功--&gt;&lt;/html&gt; src/script/app.js 123\"use strict\";//使用严格模式//angular接收的第一个参数需要和index.html中的ng-app声明的值要一致。var app = angular.module('myApp',[]); 3.6.2 测试相关功能 保证控制台没有任何报错 在编辑器中修改src下的网页或者其他文件内容，浏览器中的内容是否正常刷新 测试gulp相关指令是否都可以正常执行 保证生产环境和开发环境中的相关js、css和html等都是正常生成，并且生产环境中的文件进行了相应压缩 测试angular是否被正常召唤，一般召唤成功的话，在页面所有标签下都会新增ng-scope样式 3.6.3 了解路由注意事项12345'/home':只匹配'/home''/mood/:id'、'/mood/&#123;id&#125;':匹配'/mood/1234'，或者'/mood/''/setting?before&amp;after'：非rest传参 3.6.4 开始写使用路由的demo src/index.html网页加入angular-ui-router.min.js文件，这个具体路径看实际开发环境文件夹中的Index页和这js文件的相对路径。 src/index.html网页加入index.css文件，加入自定义的样式文件 编写测试的路由页面，我这边是写了四个路由页面 src/script/app.js，中引用ui.router，告诉angular，可以使用第三方的路由啦。 src/script/config/router.js，中编写实际路由相关内容。 3.6.4 路由测试成功，放上所有文件 src/index.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;angular-webapp&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/mdui.css\"&gt;&lt;!--导入mdui样式文件--&gt; &lt;link rel=\"stylesheet\" href=\"css/index.css\"&gt;&lt;!--导入自定义样式文件--&gt;&lt;/head&gt;&lt;body ng-app=\"myApp\"&gt;&lt;!--告诉angular这个范围的内容，都可以用ng指令，你注意ng-scope--&gt; &lt;div class=\"mdui-bottom-nav mdui-bottom-nav-text-auto mdui-bottom-nav-scroll-hide mdui-color-blue\"&gt; &lt;!--ui-sref-active设置路由激活样式，这个结合实际使用的框架设置对应的样式名，这边我用的是mdui中面板激活的样式名。 ui-sref设置路由地址，路由地址必须要已经配置好的的，ng-animate设置路由视图展示动画效果\"--&gt; &lt;a href=\"javascript:void(0);\" ui-sref-active=\"mdui-bottom-nav-active\" class=\"mdui-ripple mdui-ripple-white\" ui-sref=\"home\"&gt; &lt;i class=\"mdui-icon material-icons\"&gt;home&lt;/i&gt; &lt;label&gt;主页&lt;/label&gt; &lt;/a&gt; &lt;a href=\"javascript:void(0);\" class=\"mdui-ripple mdui-ripple-white\" ui-sref=\"pic\"&gt; &lt;i class=\"mdui-icon material-icons\"&gt;picture_in_picture&lt;/i&gt; &lt;label&gt;美图&lt;/label&gt; &lt;/a&gt; &lt;a href=\"javascript:void(0);\" class=\"mdui-ripple mdui-ripple-white\" ui-sref=\"mood\"&gt; &lt;i class=\"mdui-icon material-icons\"&gt;mood&lt;/i&gt; &lt;label&gt;心情&lt;/label&gt; &lt;/a&gt; &lt;a href=\"javascript:void(0);\" class=\"mdui-ripple mdui-ripple-white\" ui-sref=\"setting\"&gt; &lt;i class=\"mdui-icon material-icons\"&gt;settings&lt;/i&gt; &lt;label&gt;设置&lt;/label&gt; &lt;/a&gt; &lt;/div&gt; &lt;ui-view class=\"mdui-container\" ng-animate=\"slide\"&gt;&lt;/ui-view&gt;&lt;/body&gt;&lt;script src=\"vendor/angular/angular.min.js\"&gt;&lt;/script&gt;&lt;!--导入angular JS文件--&gt;&lt;script src=\"vendor/angular-ui-router/release/angular-ui-router.min.js\"&gt;&lt;/script&gt;&lt;!--导入angular-ui-router.min.js文件--&gt;&lt;script src=\"vendor/mdui/dist/js/mdui.min.js\"&gt;&lt;/script&gt;&lt;!--导入mdui.min.js文件--&gt;&lt;script src=\"js/index.js\"&gt;&lt;/script&gt;&lt;/html&gt;&lt;!--因为是做测试，所以，这边四个路由页面，都是在src/view文件夹下直接新建网页文件，随便在body中写内容，就不放上来了--&gt; src/script/app.js 123\"use strict\"; //angular接收的第一个参数需要和index.html中的ng-app声明的值要一致。 var app = angular.module('myApp',['ui.router']);//可以导入多个三方插件，注意对应插件的名字 src/script/config/router.js 12345678910111213141516171819202122232425262728293031323334353637383940414243//请注意app这个变量是app.js中定义的变量名，请注意这两个变量名的一致//'$stateProvider','$urlRouterProvider'是为了更好的语义化，所以写的全名，只要注意和后面回调函数的参数名要一致app.config(['$stateProvider','$urlRouterProvider',function($stateProvider,$urlRouterProvider)&#123; $stateProvider.state('home',&#123; url: '/home',//子路由的虚拟路径名，这个要和路径title要一致即传入state函数的第一个参数名 templateUrl: 'view/home.html',//子路由的页面地址 controller: 'homeCtrl'//子路由的controller名，注意和下面controller中要一致 &#125;).state('mood',&#123; url: '/mood',//子路由的虚拟路径名，这个要和路径title要一致即传入state函数的第一个参数名 templateUrl: 'view/mood.html',//子路由的页面地址 controller: 'moodCtrl'//子路由的controller名，注意和下面controller中要一致 &#125;).state('pic',&#123; url: '/pic',//子路由的虚拟路径名，这个要和路径title要一致即传入state函数的第一个参数名 templateUrl: 'view/pic.html',//子路由的页面地址 controller: 'picCtrl'//子路由的controller名，注意和下面controller中要一致 &#125;).state('setting',&#123; url: '/setting',//子路由的虚拟路径名，这个要和路径title要一致即传入state函数的第一个参数名 templateUrl: 'view/setting.html',//子路由的页面地址 controller: 'settingCtrl'//子路由的controller名，注意和下面controller中要一致 &#125;); $urlRouterProvider.otherwise('home');//设置默认的路由页面&#125;]);app.controller('homeCtrl', function ($scope, $state) &#123; $scope.changeState = function () &#123; $state.go('/home');//点击该路由，激活的页面地址，请注意和上文中controller对应的url要一致 &#125;;&#125;);app.controller('moodCtrl', function ($scope, $state) &#123; $scope.changeState = function () &#123; $state.go('/mood');//点击该路由，激活的页面地址，请注意和上文中controller对应的url要一致 &#125;;&#125;);app.controller('picCtrl', function ($scope, $state) &#123; $scope.changeState = function () &#123; $state.go('/pic');//点击该路由，激活的页面地址，请注意和上文中controller对应的url要一致 &#125;;&#125;);app.controller('settingCtrl', function ($scope, $state) &#123; $scope.changeState = function () &#123; $state.go('/setting');//点击该路由，激活的页面地址，请注意和上文中controller对应的url要一致、 &#125;;&#125;); 3.7 后续添加4 参考网站 node官网 angular2官网 angular4官网 angular中文社区 Bower官网 使用Bower进行前端依赖管理 gulp官网 gulp详细入门教程 less官网 less中文官网 LESS CSS 框架简介 LESS CSS 框架简介 LESS在线编辑器","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"angular","slug":"angular","permalink":"https://mowatermelon.github.io/tags/angular/"},{"name":"bower","slug":"bower","permalink":"https://mowatermelon.github.io/tags/bower/"},{"name":"gulp","slug":"gulp","permalink":"https://mowatermelon.github.io/tags/gulp/"},{"name":"less","slug":"less","permalink":"https://mowatermelon.github.io/tags/less/"}]},{"title":"软件折腾之为右键添加Gitbash","date":"2017-09-03T16:00:00.000Z","path":"2017/09/04/software-learning-rightClick-to-add-Gitbash/","text":"之前主要使用GitHub客户端，这边项目中需要用到gitbash才发现这个软件不能直接在右键显示，搜索相关博客都是只有文字没有图片，避免以后还要用，写篇日志整理一下 1 了解注册表知识注册表（Registry，繁体中文版Windows操作系统称之为登录档）是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息。早在Windows 3.0推出OLE技术的时候，注册表就已经出现。随后推出的Windows NT是第一个从系统级别广泛使用注册表的操作系统。但是，从Microsoft Windows 95操作系统开始，注册表才真正成为Windows用户经常接触的内容，并在其后的操作系统中继续沿用至今。 2 实际操作2.1 打开注册表使用win+r快捷键，输入指令regedit，打开运行器 2.2 选择对应注册表选择HKEY_CLASSES_ROOT\\Directory\\Background，在下面新建项Git，当然这个名字你可以随便起，但是为了语义化，建议取与Git有关的名字 2.3 在Git项下配置相关参数首先配置Git项的默认参数，数据值是显示在右键选项上的text内容，为了语义化更清楚，我这边直接配置的git bash here。其次配置数据值是显示在右键选项上的icon内容,这里需要配置本机GitBash icon的地址，我本机的地址是D:\\Program Files\\Git\\mingw64\\share\\git\\git-for-windows.ico。 2.4 配置Git项下command项在Git项下新建command，配置command默认参数,这里也是配置本机GitBash的安装地址，我本机的安装地址是D:\\Program Files\\Git\\git-bash.exe。 3 测试是否安装成功","tags":[{"name":"软件折腾","slug":"软件折腾","permalink":"https://mowatermelon.github.io/tags/软件折腾/"},{"name":"gitbash","slug":"gitbash","permalink":"https://mowatermelon.github.io/tags/gitbash/"},{"name":"GitHub","slug":"GitHub","permalink":"https://mowatermelon.github.io/tags/GitHub/"},{"name":"cmd","slug":"cmd","permalink":"https://mowatermelon.github.io/tags/cmd/"}]},{"title":"Js学习之js数据类型","date":"2017-05-03T16:00:00.000Z","path":"2017/05/04/js-Learning-dataType/","text":"前不久我了解了js数组相关操作，才发现我的js在数据类型这块的基础真的很薄弱，所以整理了些文档，重新学习了一下。 1 DEFINTION数据类型在数据结构中的定义是一个值的集合以及定义在这个值集上的一组操作。 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。在声明变量时也可指定它的数据类型。所有变量都具有数据类型，以决定能够存储哪种数据。 数据类型包括原始类型、多元组、记录单元、代数数据类型、抽象数据类型、参考类型以及函数类型。 2 PARAMETER2.1 primitive type在JavaScript 有 5 种原始类型（primitive type），即 undefined、Null、Boolean、Number 和 String。 并且JavaScript 拥有动态类型，这意味着相同的变量可用作不同的类型 123456789101112var temp = undefined;console.log(typeof temp)//输出 undefinedtemp = null;console.log(typeof null)//输出 objecttemp = 1;console.log(typeof temp)//输出 numbertemp = \"undefined\";console.log(typeof \"undefined\")//输出 string!!!temp = \"true\";console.log(typeof temp)//输出 stringtemp = true;console.log(typeof true)//输出 boolean 2.1.1 undefined当声明的变量未初始化时，该变量的默认值是undefined，即该值的数据类型和数据内容都是undefined。 123var oTemp;console.log(typeof oTemp); //输出 undefined console.log(oTemp ==undefined);//输出 true 但是，值 undefined 并不同于未定义的值，typeof 运算符会将未定义和未声明的变量数据类型都打印为undefined。 123var oTemp;console.log(typeof oTemp); //输出 undefined console.log(typeof oTemp2); //输出 undefined 请注意，对于未声明的变量使用除 typeof 之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。 例如，下面的代码将引发错误： 12var oTemp;console.log(oTemp2 == undefined); 当函数无明确返回值时，返回的也是值 undefined，如下所示： 1234function testFunc() &#123;&#125;console.log(testFunc() == undefined); //输出 \"true\" 2.1.2 Null它只有一个专用值 null，即它的字面量。值undefined实际上是从值null派生来的，因此ECMAScript把它们定义为相等的。 1console.log(null == undefined); //输出 \"true\" 尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。 12console.log(typeof null)// \"object\"console.log(typeof &#123;&#125;)// \"object\" typeof 运算符对于 null 值会返回 Object，这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。 也可以通过将变量的值设置为 null 来清空变量。 1234var temp =\"\";console.log(typeof temp);//stringtemp=null;console.log(typeof temp);//object 2.1.3 BooleanBoolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的。 12345var temp = true;console.log(typeof temp);//booleantemp = !0;console.log(typeof temp)//booleanconsole.log(temp)//true 2.1.4 NumberECMA-262 中定义的最特殊的类型是 Number 类型。这种类型既可以表示 32 位的整数，还可以表示 64 位的浮点数。直接输入的（而不是从另一个变量访问的）任何数字都被看做 Number 类型的字面量。例如，下面的代码声明了存放整数值的变量，它的值由字面量 86 定义： 123var temp = 86;console.log(typeof temp);//numberconsole.log(temp);//86 八进制数和十六进制数 整数也可以被表示为八进制（以 8 为底）或十六进制（以 16 为底）的字面量。尽管所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制结果。 八进制的字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7），如下面的代码所示： 123var temp = 070;console.log(typeof temp);//numberconsole.log(temp);//打印出来是显示十进制的56 要创建十六进制的字面量，首位数字必须为0，后面接字母 x(不分大小写)，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的。例如： 1234var temp = 0x1f;console.log(temp);//打印出来是显示十进制的31temp = 0xAB;console.log(temp);//打印出来是显示十进制的171 浮点数 要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量。例如： 123456var temp = 5.0;console.log(temp);//显示整数 5temp = 5.5;console.log(temp);//显示浮点数 5.5temp = 5.5+\"\";console.log(typeof temp);//string 对于浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串。 科学计数法 对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数。对于极小值的浮点可以通过toFixed(number)将指定数字截取小数点后number位，或者是利用Math.round()方法将一个数字舍入为最接近的整数,但是对于正整数，需要使用toPrecision(number)将整个数字截取指定number长度。 12345678910111213141516171819var temp = 5.618e7;console.log(temp);//显示整数 56180000 5.618 x 10^7temp = 8e-17;console.log(temp);//8e-17temp = 0.000000000000000000000000000001245893576484897879;console.log(temp);//1.2458935764848978e-30//请注意只显示小数点位后十六位，之后会省略console.log(temp.toFixed(2));//0.00console.log(temp.toPrecision(2));//1.2e-30console.log(Math.round(temp));//0temp = 124589357648489787900000000000000000000000000000;console.log(temp);//1.245893576484898e+47//请注意只显示小数点位后十五位，之后会省略console.log(temp.toFixed(2));//1.245893576484898e+47console.log(temp.toPrecision(2));//1.2e+47console.log(Math.round(temp));//1.245893576484898e+47 ECMAScript 默认把具有6 个或 6 个以上前导 0 的浮点数转换成科学计数法。也可用 基于IEEE 754标准的64 位形式存储浮点值，这意味着十进制值最多可以有 17 个十进制位。17 位之后的值将被裁去，从而造成一些小的数学误差。 12345678IEEE 754 标准是IEEE二进位浮点数算术标准（IEEE Standard for Floating-Point Arithmetic）的标准编号[1] ，等同于国际标准ISO/IEC/IEEE 60559。该标准由美国电气电子工程师学会（IEEE）计算机学会旗下的微处理器标准委员会（Microprocessor Standards Committee, MSC）发布。这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的「浮点数运算子」；它也指明了四种数值修约规则和五种例外状况（包括例外发生的时机与处理方式）该标准的全称为IEEE二进位浮点数算术标准（ANSI/IEEE Std 754-1985），又称IEC 60559:1989，微处理器系统的二进位浮点数算术（本来的编号是IEC 559:1989）。后来还有「与基数无关的浮点数」的「IEEE 854-1987标准」，有规定基数为2跟10的状况。现在最新标准是「IEEE 854-2008标准」。IEEE 754 标准规定了计算机程序设计环境中的二进制和十进制的浮点数自述的交换、算术格式以及方法。 特殊的 Number 值 几个特殊值也被定义为 Number 类型。前两个是 Number.MAX_VALUE 和 Number.MIN_VALUE，它们定义了 Number 值集合的外边界。所有 ECMAScript 数都必须在这两个值之间。不过计算生成的数值结果可以不落在这两个值之间。当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为 -Infinity。由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用isFinite()方法，以确保该数不是无穷大。对于数字可以调用Number.isInteger()验证数据是否是整型数据。 12345var temp = Number.POSITIVE_INFINITY;console.log(isFinite(temp));//falsevar temp = 5;console.log(isFinite(temp));//trueconsole.log(Number.isInteger(\"0.55\"))//false 最后一个特殊值是 NaN，表示非数（Not a Number）。NaN是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，NaN 也不能用于算术计算。NaN 的另一个奇特之处在于，它与自身不相等。 1234567var temp = NaN;console.log(NaN == temp); //输出 \"false\"//出于这个原因，不推荐使用 NaN 值本身。函数 isNaN() 会做得相当好temp = NaN;console.log(isNaN(temp)); //输出 \"true\"temp = 666;console.log(isNaN(temp)); //输出 \"false\" Number 对象 Number 对象是原始数值的包装对象。 创建 Number 对象的语法： 1234567891011121314151617181920var temp=new Number(\"a\");console.log(temp);/*Number &#123;[[PrimitiveValue]]: NaN&#125; __proto__:Number constructor:ƒ Number() toExponential:ƒ toExponential() toFixed:ƒ toFixed() toLocaleString:ƒ toLocaleString() toPrecision:ƒ toPrecision() toString:ƒ toString() valueOf:ƒ valueOf() __proto__:Object [[PrimitiveValue]]:0[[PrimitiveValue]]:NaN*/var tmp=Number(\"b\");console.log(tmp);//NaNtmp=Number(\"\");console.log(tmp);//0 参数 参数 value 是要创建的 Number 对象的数值，或是要转换成数字的值。 返回值 当 Number() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 Number 对象。如果不用 new 运算符，把 Number() 作为一个函数来调用，它将把自己的参数转换成一个原始的数值，并且返回这个值（如果转换失败，则返回 NaN）。 Number 对象属性 属性 描述 constructor 返回对创建此对象的 Number 函数的引用。 MAX_VALUE 可表示的最大的数。 MIN_VALUE 可表示的最小的数。 NaN 非数字值。 NEGATIVE_INFINITY 负无穷大，溢出时返回该值。 POSITIVE_INFINITY 正无穷大，溢出时返回该值。 prototype 使您有能力向对象添加属性和方法。 Number 对象方法 方法 描述 toString 把数字转换为字符串，使用指定的基数。 toLocaleString 把数字转换为字符串，使用本地数字格式顺序。 toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字。 toExponential 把对象的值转换为指数计数法。 toPrecision 把数字格式化为指定的长度。 valueOf 返回一个 Number 对象的基本数字值。 2.1.5 string字符串是存储字符（比如 “Bill Gates”）的变量。字符串可以是引号中的任意文本。可以使用单引号或双引号，也可以在字符串中使用引号，只要不匹配包围字符串的引号即可。123var answer=\"Nice to meet you!\";var answer=\"He is called 'Bill'\";var answer='He is called \"Bill\"'; 2.2 衍生 type2.2.1 对象2.2.2 数组 直接声明并赋值 1var cars=[\"Audi\",\"BMW\",\"Volvo\"]; 数组下标是基于零的，所以第一个项目是 [0]，第二个是 [1]，以此类推。 利用array新建数组对象 Array 对象用于在单个的变量中存储多个值。创建 Array 对象的语法： 123new Array();new Array(size);new Array(element0, element1, ..., elementn); 参数 参数 size 是期望的数组元素个数。返回的数组，length 字段将被设为 size 的值。参数 element …, elementn 是参数列表。当使用这些参数来调用构造函数 Array() 时，新创建的数组的元素就会被初始化为这些值。它的 length 字段也会被设置为参数的个数。 返回值 返回新创建并被初始化了的数组。如果调用构造函数 Array() 时没有使用参数，那么返回的数组为空，length 字段为 0。当调用构造函数时只传递给它一个数字参数，该构造函数将返回具有指定个数、元素为 undefined 的数组。当其他参数调用 Array() 时，该构造函数将用参数指定的值初始化数组。当把构造函数作为函数调用，不使用 new 运算符时，它的行为与使用 new 运算符调用它时的行为完全一样。","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"数据类型","slug":"数据类型","permalink":"https://mowatermelon.github.io/tags/数据类型/"}]},{"title":"Js学习之js函数hacker","date":"2017-05-02T16:00:00.000Z","path":"2017/05/03/js-Learning-function-hacker/","text":"1 定义式函数与赋值式函数 123456789Fn(); //执行结果：console.log在控制台打印提示function Fn()&#123; //声明式函数 console.log(\"执行了定义式函数\");&#125;Fun(); //执行结果：程序报错，提示函数未定义var Fun= function()&#123; //赋值式函数 console.log(\"执行了赋值式函数\");&#125; JS的解析过程分为两个阶段：预编译期(预处理)与执行期，页面加载过程中，浏览器会对页面上或载入的每个js代码块(或文件)进行扫描，如果遇到定义式函数，则进行预处理(类似于C等的编译)，处理完成之后再开始由上至下执行；遇到赋值式函数，则只是将函数赋给一个变量，不进行预处理，待调用到的时候才进行处理。 2 代码块及js文件的处理 代码块是指一对&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;标签包裹着的JS代码，文件就是指通过src导入页面的JS文件。浏览器对每个代码块或文件进行独立的扫描，然后对全局的代码进行顺序执行。所以，在一个代码块(文件)中，函数可以在调用之后进行定义式定义(如案例一中的Fn()),但在两个独立的代码块中，定义函数所在的代码块必须在函数被调用的代码块之前。 12345&lt;script type=\"text/javascript\"&gt;function Fun()&#123; console.log(\"Hello World!\");&#125;&lt;/script&gt; 1234&lt;script type=\"text/javascript\"&gt;Fun();//控制台顺利打印，因为函数所在代码块在上一个代码块Fn(); //报错，提示函数未定义，因为函数所在代码块在下一个代码块&lt;/script&gt; 12345&lt;script type=\"text/javascript\"&gt;function Fn()&#123; console.log(\"Hello World!\");&#125;&lt;/script&gt; 3 重复定义函数会覆盖前面的定义 因为在JS中重名的函数，后定义的会覆盖前面定义的函数，这种策略和JS的顺序执行也是有关系的。 12345678fn(); //控制台打印提示 2function fn()&#123; console.log(1);&#125;function fn()&#123; console.log(2);&#125;fn(); //控制台打印提示 2 4 body的onload函数与body内部函数的执行 body中内部的函数会先于onload的函数执行,body的onload事件触发条件是body内容加载完成，而body中的JS代码会在这一事件触发之前运行。 1234567function fnOnLoad()&#123; console.log(\"I am outside the Wall!\");&#125;window.onload = fnOnLoad;console.log(\"I am inside the Wall..\");//先在控在控制台打印\"I am inside the Wall..\"//后在控制台打印\"I am outside the Wall!\" 5 JS是多线程or单线程？ 严格来说，JS是没有多线程概念的，所有的程序都是单线程依次执行的。 延时执行、Ajax异步加载只是看起来像多线程。 123456789101112function fn1()&#123; setTimeout(function()&#123; console.log(\"我先调用\") &#125;,1000);&#125;function fn2()&#123; console.log(\"我后调用\");&#125;fn1();fn2();// 先在控制台打印：“我后调用”，// 1秒后在控制台打印：“我先调用” 看上去，fn2()和延时程序是分两个过程再走，但其实，这是JS中的回调机制在起作用，类似于操作系统中的中断和响应 —— 延时程序设置一个中断，然后执行fn2()，待1000毫秒时间到后，再回调执行fn1()。同样，4中body的onload事件调用的函数，也是利用了回调机制——body加载完成之后，回调执行fnOnLoad()函数。Ajax请求中的数据处理函数也是一样的道理。 6 引入js中文乱码 在调用外部js进行相关验证的时候，中间会包涵部分中文，但是由于页面一般是使用utf-8作为编码，但是中文在utf-8显示乱码，成了一串乱七八糟的东西，所以在页面引用的时候，请加上编码格式。 123456// charset=\"gbk\"// charset=\"gb2312\"//举个例子&lt;script src=\"js/XXXX.js\" type=\"text/javascript\" charset=\"gb2312\"&gt;&lt;/script&gt; 参考网站 js 程序执行与顺序实现详解 JS——声明式函数与赋值式函数","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"hacker","slug":"hacker","permalink":"https://mowatermelon.github.io/tags/hacker/"}]},{"title":"Js学习之jq基础clone学习","date":"2017-05-01T16:00:00.000Z","path":"2017/05/02/js-Learning-jquery-clone/","text":"前情概要，项目中需要用到新增现有盒子和删除对应index盒子的需求，这边我之前做过这种类似的用的是自己手动拼接新增的字符串，感觉太浪费时间，所以这次想用到JQ中的clone，减少代码冗余 1 点满bugbug 1我使用class比较习惯，所以想通过class选择器，进行clone之后，再在进行重新绑定id之类的，结果发现，我点击一次，新增一个盒子，点击第二次，新增两个盒子，点击第三次，新增三个盒子，完全是群魔乱舞。 放上错误代码 12345678&lt;!--html代码--&gt;&lt;div id=\"main\" class=\"row\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"panel-info userPanel\"&gt;&lt;/div&gt; &lt;button class=\"btn btn-block btn-link text-center text-info\" id=\"addUser\"&gt;+新增&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 1234//javascript代码$(\"#addUser\").click(function () &#123; $('.userPanel').append($('.userPanel').clone());&#125;) bug原因:通过class获取没有唯一性，本意是再新增一行，但是由于class选择器做的是完全匹配，所以每一个对应的class之后都新增了一个盒子，修改为通过id获取clone对象，还有通过id获取需要添加盒子的对象。 bug 2修改为id获取之后我这边事件绑定又出现了问题，因为我是直接克隆的，没有修改id，导致这边id绑定有一定问题，出现了和上个bug一样的问题。 bug原因:绑定事件没有唯一性，所以我这边修改了页面标签结构，并同时修改了clone之后的对应id。 放上修改结构之后的代码12345678&lt;!--html代码--&gt;&lt;div id=\"main\" class=\"row\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"panel-info userPanel\" id=\"userPanel_01\"&gt;&lt;/div&gt; &lt;div class=\"userNull\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=\"btn btn-block btn-link text-center text-info\" id=\"addUser\"&gt;+新增&lt;/button&gt; &lt;/div&gt; 1234567891011121314var countU=2;//第一个userPanel是不能删除的，所以之后添加的面板序号默认是从第二个开始的，注意定义在$(function()&#123;&#125;)之外，因为之后外部的funciton需要调用到这个全局变量。//javascript代码$(\"#addUser\").click(function () &#123; $('#userPanel_01').clone(true) var _clonePanel = $('#userPanel_01').clone(true); _clonePanel.attr('id', 'userPanel_0' + countU); _clonePanel.find('.panel-title').html('信息(' + countU + ')'); _clonePanel.find('.deleteBtn').attr('onclick', \"deleteUser(userPanel_0\" + countU + \")\").removeClass(\"hide\").addClass(\"show\") ;//通过attr绑定事件，不要通过prop绑定事件，$('.userNull')克隆到了之后，赶紧把`.deleteBtn`的hide样式移除掉 _clonePanel.appendTo('.userNull'); ++countU;//在克隆了之后，赶紧将序号自增一下&#125;)function deleteUser(index) &#123; $('.userNull').children('.userPanel').eq(index-2).remove();&#125;) bug 3我现在需要绑定删除事件，我前期思路是传对应的Index索引过去，然后在.userNull中找对应的索引进行移除操作，结果发现如果我不按照顺序删除，这边通过索引是找不到对应的子盒子的，比如我新增了三个子盒子，我在第二个子盒子点击了删除，我在第三个子盒子中点击删除，就没有用了。 bug原因:因为此时.userNull只有两个子盒子，这个时候再找它的第三个子盒子，那就真的是尬找，找不到的，捂脸.jpg。 放上修改结构之后的代码，html没有修改结构 12345678910$(\"#addUser\").click(function () &#123; $('#userPanel_01').clone(true) ··· _clonePanel.find('.deleteBtn').attr('onclick',\"deleteUser(userPanel_0\" + countU+\")\");//修改的地方 ···&#125;)function deleteUser(id) &#123; $('.userNull').find(id).remove(); --countU;//在删除了之后，赶紧将序号自减一下&#125;) bug 4我的页面新增三个子盒子，我把页面上的第二个删除之后，页面上显示的是’信息(01)’，’信息(02)’，’信息(04)’，这样肯定不合理，而且我的删除肯定是需要有个确认行为的，万一我误碰了怎么办，我也很无辜啊。 bug原因:正常逻辑这边应该在删除之后重新刷一遍页面已有的盒子id，我没有管她们，她们这些盒子也很绝望啊，不能怪她们。 放上修改结构之后的代码，html没有修改结构 123456789101112131415161718192021222324252627//javascript代码 只修改了deleteUser方法function deleteUser(id) &#123; $(\"#bsznModal\").showmodal(&#123;//这个是我自己基于bootstrap modal写的一个模态窗插件，支持自定义很多内容。 flag: \"info\", title: \"警告\", //设置模态窗标题 content: \"确认删除这条记录吗？\", Qclose: true, fontSize: \"18\" &#125;); $(\"#close\").click(function () &#123;//点击确认按钮之后，才执行删除操作 $('.userNull').find(id).remove(); /* *遍历$(\".userNull\").children(\".userPanel\") *注意each (function (index, data)&#123;&#125;)结构，这个不是each(index, data)&#123;&#125; *each 有两个参数，第一个是该子盒子的当前索引，第二个是她的内容 *这边each默认索引是从0开始的，所以index需要在自身的索引增加2 */ $(\".userNull\").children(\".userPanel\").each(function (index, data) &#123; var _this = $(this); index = index + 2;//索引增加2 _this.attr('id', 'userPanel_0' + index);// _this.find('.panel-title').html('信息(' + index + ')'); _this.find('.deleteBtn').attr('onclick', \"deleteUser(userPanel_0\" + index + \")\"); &#125;) --countU;//注意这个时候索引自减实在点击了确认之后才进行，如果没有点击确认，不管不顾的之后在deleteUser()之后执行自减，这个会有问题哒。 &#125;)&#125; 2 触发技能 1 clone盒子成功拉 clone() 2 clone并修改内容成功拉 clone(true) 3 动态新增数据成功拉 appendTo() 4 动态修改btn单击事件成功拉 attr(&#39;onclick&#39;,&quot;···&quot;) 5 使用each进行遍历成功拉 each (function (index, data){}) 6 删除对应索引盒子成功拉 remove() 3 整理思路最近学习vue的使用，对于jquery的好感其实降到很低了，今天做这个功能其实比较小，整个做下来也感觉还算顺畅。就我目前学习的vue进度，这些如果在vue中做的话，其实也是比较麻烦的事情，数据驱动模式在dom动态新增上面只能通过字符串进行拼接，这边没有clone来的方便，而且在删除之后动态刷页面上的id内容，通过原生js比较繁琐，不过这边真的是需要注意细节，很多小细节，不要太粗心，不要浪费太多时间去回忆忘记的知识点，很多知识点忘记了之后，自己一个人尬想解决不了问题，还不如直接搜一下，也不是大事。 4 放上完整代码12345678910111213141516171819202122&lt;!--html代码--&gt;&lt;div id=\"main\" class=\"row\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"panel-info userPanel\" id=\"userPanel_01\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;span class=\"panel-title\"&gt;信息(1)&lt;/span&gt; &lt;button class=\"pull-right deleteBtn hide btn btn-link\"&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"container form-horizontal\" id=\"userdiv\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"txtMC\" class=\"col-xs-3 control-label\"&gt;姓名：&lt;/label&gt; &lt;div class=\"col-xs-9\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"txtMC\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"userNull\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=\"btn btn-block btn-link text-center text-info\" id=\"addUser\"&gt;+新增&lt;/button&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233//javascript代码var countU = 2;$(\"#addUser\").click(function () &#123; var _clonePanel = $('#userPanel_01').clone(true); _clonePanel.attr('id', 'userPanel_0' + countU); _clonePanel.find('.panel-title').html('信息(' + countU + ')'); _clonePanel.find('.deleteBtn').attr('onclick', \"deleteUser(userPanel_0\" + countU + \")\").removeClass(\"hide\").addClass(\"show\") ; _clonePanel.appendTo('.userNull'); ++countU;&#125;)function deleteUser(id) &#123; $(\"#bsznModal\").showmodal(&#123; flag: \"info\", title: \"警告\", //设置模态窗标题 content: \"确认删除这条记录吗？\", Qclose: true, fontSize: \"18\" &#125;); $(\"#close\").click(function () &#123; $('.userNull').find(id).remove(); $(\".userNull\").children(\".userPanel\").each(function (index, data) &#123; var _this = $(this); index = index + 2; _this.attr('id', 'userPanel_0' + index); _this.find('.panel-title').html('信息(' + index + ')'); _this.find('.deleteBtn').attr('onclick', \"deleteUser(userPanel_0\" + index + \")\"); &#125;) --countU; &#125;)&#125;","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"jq基础","slug":"jq基础","permalink":"https://mowatermelon.github.io/tags/jq基础/"},{"name":"clone","slug":"clone","permalink":"https://mowatermelon.github.io/tags/clone/"}]},{"title":"Js学习之jq基础","date":"2017-04-30T16:00:00.000Z","path":"2017/05/01/js-Learning-jquery-basics/","text":"1 相关节点操作 jQuery.parent(expr) 找父亲节点，可以传入expr进行过滤，比如$(&quot;span&quot;).parent()或者$(&quot;span&quot;).parent(&quot;.class&quot;) jQuery.parents(expr),类似于jQuery.parents(expr),但是是查找所有祖先元素，不限于父元素 jQuery.children(expr).返回所有子节点，这个方法只会返回直接的孩子节点，不会返回所有的子孙节点 jQuery.contents(),返回下面的所有内容，包括节点和文本。这个方法和children()的区别就在于，包括空白文本，也会被作为一个 jQuery对象返回，children()则只会返回节点 jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点 jQuery.prevAll()，返回所有之前的兄弟节点 jQuery.next(),返回下一个兄弟节点，不是所有的兄弟节点 jQuery.nextAll()，返回所有之后的兄弟节点 jQuery.siblings(),返回兄弟姐妹节点，不分前后 jQuery.find(expr),跟jQuery.filter(expr)完全不一样。jQuery.filter()是从初始的jQuery对象集合中筛选出一部分，而jQuery.find()的返回结果，不会有初始集合中的内容，比如$(&quot;p&quot;),find(&quot;span&quot;),是从元素开始找,等同于$(&quot;p span&quot;) 2 jquery判断子元素是否存在2.1 判断子元素是否存在123456789//一级子元素 if($(\"#specialId&gt;img\").length==0)if ($( \"#specialId:has(img)\" ).length==0)&#123;//-----没有img子标记-----&#125;else&#123;//-------有img子标记------&#125; 2.2 选择特定id元素下的特定id子元素1$(\"#form\" ).children( \"#t\" ) 2.3 选择特定id元素下的子元素1$(\"ul#u&gt;li:nth-child(2)\" ) 2.4 判断某个元素是否存在1234if ($( \"#myId\" ).length&gt;0)&#123;//存在&#125; 3 jquery样式移除123$(this).children(\".glyphicon-chevron-up\") .addClass(\"glyphicon-chevron-down\") .removeClass(\"glyphicon-chevron-up\"); 在选择器使用上面，通过某个样式进行选择，但是同时需要移除该样式，添加新样式，可以先添加新样式，再移除样式 4 按钮禁用12$(\"#btnBack\").addClass(\"disabled hidden\");//按钮的样式展示禁用效果$('#btnBack').prop('disabled', true);//按钮完全被禁用 5 监听回车事件12345678910111213141516171819202122232425$(function () &#123; //定义回车事件 if (document.addEventListener) &#123;//如果是Firefox document.addEventListener(\"keypress\", fireFoxHandler, true); &#125; else &#123; document.attachEvent(\"onkeypress\", ieHandler); &#125; function fireFoxHandler(evt) &#123; if (evt.keyCode == 13) &#123; $(\"#btnLogin\")[0].click(); &#125; &#125; function ieHandler(evt) &#123; if (evt.keyCode == 13) &#123; $(\"#btnLogin\")[0].click(); &#125; &#125; &#125;); &lt;/script&gt;","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"jq基础","slug":"jq基础","permalink":"https://mowatermelon.github.io/tags/jq基础/"}]},{"title":"js学习之FX获取文件路径方法","date":"2017-04-29T16:00:00.000Z","path":"2017/04/30/js-Learning-io/","text":"FX获取文件路径方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function readFileFirefox(fileBrowser) &#123;try &#123; netscape.security.PrivilegeManager.enablePrivilege(\"UniversalXPConnect\");&#125; catch (e) &#123; alert('无法访问本地文件，由于浏览器安全设置。为了克服这一点，请按照下列步骤操作：(1)在地址栏输入\"about:config\";(2) 右键点击并选择 New-&gt;Boolean; (3) 输入\"signed.applets.codebase_principal_support\" （不含引号）作为一个新的首选项的名称;(4) 点击OK并试着重新加载文件'); return;&#125;var fileName = fileBrowser.value; //这一步就能得到客户端完整路径。下面的是否判断的太复杂，还有下面得到ie的也很复杂。var file = Components.classes[\"@mozilla.org/file/local;1\"].createInstance(Components.interfaces.nsILocalFile);try &#123; // Back slashes for windows file.initWithPath(fileName.replace( ///g, \"\\\\\") ); &#125; catch (e) &#123; if (e.result != Components.results.NS_ERROR_FILE_UNRECOGNIZED_PATH) throw e; alert(\"File '\" + fileName + \"' cannot be loaded: relative paths are not allowed. Please provide an absolute path to this file.\"); return; &#125; if (file.exists() == false) &#123; alert(\"File '\" + fileName + \"' not found.\"); return; &#125; return file.path; &#125; //根据不同浏览器获取路径 function getvl() &#123; //判断浏览器 var Sys = &#123;&#125;; var ua = navigator.userAgent.toLowerCase(); var s; (s = ua.match(/msie ([d.]+)/)) ? Sys.ie = s[1] : (s = ua.match(/firefox/ ([d.] + ) / )) ? Sys.firefox = s[1] : (s = ua.match(/chrome/ ([d.] + ) / )) ? Sys.chrome = s[1] : (s = ua.match(/opera.([d.]+)/)) ? Sys.opera = s[1] : (s = ua.match(/version/ ([d.] + ). * safari / )) ? Sys.safari = s[1] : 0; var file_url = \"\"; if (Sys.ie &lt;= \"6.0\") &#123; //ie5.5,ie6.0 file_url = document.getElementById(\"file\").value; &#125; else if (Sys.ie &gt;= \"7.0\") &#123; //ie7,ie8 var file = document.getElementById(\"file\"); file.select(); file_url = document.selection.createRange().text; &#125; else if (Sys.firefox) &#123; //fx //file_url = document.getElementById(\"file\").files[0].getAsDataURL();//获取的路径为FF识别的加密字符串 file_url = readFileFirefox(document.getElementById(\"file\")); &#125; //alert(file_url); document.getElementById(\"text\").innerHTML = \"获取文件域完整路径为：\" + file_url; &#125;","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"获取文件路径","slug":"获取文件路径","permalink":"https://mowatermelon.github.io/tags/获取文件路径/"}]},{"title":"js学习之修改相关浏览URL","date":"2017-04-28T16:00:00.000Z","path":"2017/04/29/js-Learning-change-url/","text":"1 c#后台获取当前界面的url如果测试的url地址是http://www.test.com/testweb/default.aspx, 结果如下： 1234567891011Request.ApplicationPath: /testwebRequest.CurrentExecutionFilePath: /testweb/default.aspxRequest.FilePath: /testweb/default.aspxRequest.Path: /testweb/default.aspxRequest.PhysicalApplicationPath: E:\\WWW\\testwebRequest.PhysicalPath: E:\\WWW\\testweb\\default.aspxRequest.RawUrl: /testweb/default.aspxRequest.Url.AbsolutePath: /testweb/default.aspxRequest.Url.AbsoluteUrl: http://www.test.com/testweb/default.aspxRequest.Url.Host: http://www.test.com/Request.Url.LocalPath: /testweb/default.aspx 2 前台修改相关url2.1 html标签跳转123456&lt;head&gt;&lt;!-- 以下方式只是刷新不跳转到其他页面 --&gt;&lt;meta http-equiv=\"refresh\" content=\"10\"&gt;&lt;!-- 以下方式定时转到其他页面 --&gt;&lt;meta http-equiv=\"refresh\" content=\"5;url=hello.html\"&gt;&lt;/head&gt; 优点：简单缺点：Struts Tiles中无法使用 控制parent页面跳转，这个其实用不到jQuery 1window.parent.location.href = \"*****\"; 2.2 调用parent页面的函数，其实也不用jQuery1window.parent.method(para); 2.3 操作parent的DOM 1$(\".test\", window.parent.document).remove(); 2.4 location.href12self.loction.href=\"/url\"window.location.href=\"/url\" 以上两个用法相同均为在当前页面打开URL页面 1this.location.href=\"/url\" 当前页面打开URL 1parent.location.href=\"/url\" 在父页面打开新页面，如果页面中自定义了frame，那么可将parent self top换为自定义frame的名称,效果是在frame窗口打开url地址 1top.location.href=\"/url\" 在顶层页面打开新页面 2.5 关于刷新页面123window.location.href=window.location.hrefwindow.location.Reload() 都是刷新当前页面。区别在于是否有提交数据。当有提交数据时，第二种会提示是否提交，第一种则是向指定的url提交数据 2.6 js获取url相关参数123456789101112131415161718192021222324252627282930313233// 获取地址栏的参数数组function getUrlParams() &#123; var search = window.location.search; // 写入数据字典 var tmparray = search.substr(1, search.length).split(\"&amp;\"); var paramsArray = new Array; if (tmparray != null) &#123; for (var i = 0; i &lt; tmparray.length; i++) &#123; var reg = /[=|^==]/; // 用=进行拆分，但不包括== var set1 = tmparray[i].replace(reg, '&amp;'); var tmpStr2 = set1.split('&amp;'); var array = new Array; array[tmpStr2[0]] = tmpStr2[1]; paramsArray.push(array); &#125; &#125; // 将参数数组进行返回 return paramsArray;&#125;// 根据参数名称获取参数值 function getParamValue(name) &#123; var paramsArray = getUrlParams(); if (paramsArray != null) &#123; for (var i = 0; i &lt; paramsArray.length; i++) &#123; for (var j in paramsArray[i]) &#123; if (j == name) &#123; return paramsArray[i][j]; &#125; &#125; &#125; &#125; return null;&#125; 2.7 js设置url相关参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Js修改Url参数function changeURLPar(url, ref, value) &#123; var str = \"\"; if (url.indexOf('?') != -1) str = url.substr(url.indexOf('?') + 1); else return url + \"?\" + ref + \"=\" + value; var returnurl = \"\"; var setparam = \"\"; var arr; var modify = \"0\"; if (str.indexOf('&amp;') != -1) &#123; arr = str.split('&amp;'); for (i in arr) &#123; if (arr[i].split('=')[0] == ref) &#123; setparam = value; modify = \"1\"; &#125; else &#123; setparam = arr[i].split('=')[1]; &#125; returnurl = returnurl + arr[i].split('=')[0] + \"=\" + setparam + \"&amp;\"; &#125; returnurl = returnurl.substr(0, returnurl.length - 1); if (modify == \"0\") if (returnurl == str) returnurl = returnurl + \"&amp;\" + ref + \"=\" + value; &#125; else &#123; if (str.indexOf('=') != -1) &#123; arr = str.split('='); if (arr[0] == ref) &#123; setparam = value; modify = \"1\"; &#125; else &#123; setparam = arr[1]; &#125; returnurl = arr[0] + \"=\" + setparam; if (modify == \"0\") if (returnurl == str) returnurl = returnurl + \"&amp;\" + ref + \"=\" + value; &#125; else returnurl = ref + \"=\" + value; &#125; return url.substr(0, url.indexOf('?')) + \"?\" + returnurl;&#125; 3 HTML5无刷新修改URL HTML5新添加了两个api分别是pushState和replaceState，DOM中的window对象通过window.history方法提供了对浏览器历史记录的读取，可以在用户的访问记录中前进和后退，我们可以开始操作这个历史记录堆栈。 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;HTML5无刷修改url - XXX&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; function changeURL()&#123; var url = document.getElementById('url').value; window.history.pushState(&#123;&#125;,0,'http://'+window.location.host+'/'+url); &#125; &lt;/script&gt;&lt;/head&gt; &lt;h1&gt;html5无刷新改变url&lt;/h1&gt; &lt;div id=\"info\" style=\"margin:30px 0;\"&gt; 页面真实地址: &lt;span style=\"color:red;\"&gt;&lt;script type=\"text/javascript\"&gt;document.write(window.location.href);&lt;/script&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; 请输入要改变地URL字符串：&lt;input id='url' type=\"text\" /&gt; &lt;button onclick=\"changeURL();\"&gt;点击无刷改变url&lt;/button&gt; &lt;/div&gt; &lt;div style=\"color:red;margin-top:30px;\"&gt;请使用支持html5的浏览器访问&lt;/div&gt; &lt;div style=\"margin-top:30px;\"&gt;&lt;a href=\"http://www.qttc.net/201303292.html\" target=\"_blank\"&gt;《html5无刷新改变URL》&lt;/a&gt; - XXX&lt;/div&gt; 4 HTML5模拟翻页效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var changeURL = function()&#123; if(location.href.indexOf(\"?\") &gt; -1)&#123; var arr = location.href.split('?'); var urlbase = arr[0]; var pageObj = arr[1].match(/page=(\\d+)/); var page = Number(pageObj[1]) || 1; &#125;else&#123; var urlbase = location.href; var page = 1; &#125; load = false; var content = document.getElementById(\"content\"); var ajax = new XMLHttpRequest(); // 调用数据回掉函数 var ajaxCallback = function()&#123; if(ajax.readyState == 4)&#123; load = false; result = eval('('+ajax.responseText+')'); content.innerHTML = result.data; next.href = urlbase + \"?page=\" + (page + 1); // push到历史记录里，可以在点击后退时从历史记录里恢复内容 // 并且无刷修改url地址 window.history.pushState(&#123;content:content.innerHTML,page:page&#125;,page,urlbase + \"?page=\" + page); &#125; &#125;; // 点击事件 document.getElementById('next').onclick = function(event)&#123; if(!load)&#123; load = true; content.innerHTML = '加载中数据中...(注意看数据返回后url改变)'; page++; ajax.open('GET','shuju.php?page='+page, true); ajax.onreadystatechange = ajaxCallback; ajax.send(''); return false; &#125; &#125;; // 记录到历史里，当点击后退按钮还退回上次页面请求前的页面内容 window.onpopstate = function()&#123; content.innerHTML = history.state.content; page = history.state.page; &#125; // 修改当前页面在 history 中的记录 window.history.replaceState(&#123;content:content.innerHTML,page:page&#125;,page,urlbase + (page &gt; 1 ? '?page=' + page : '' )); &#125;; // 检测是否支持 try&#123; //监听事件 window.addEventListener('DOMContentLoaded', changeURL, false); &#125;catch(e)&#123; alert('浏览器不支持，请使用支持html5的浏览器'); &#125; &lt;div id=\"content\" style=\"width:300px;height:100px;border:1px solid #999;\"&gt;第1页的内容&lt;/div&gt; &lt;div&gt;&lt;a id=\"next\" href=\"?page=2\"&gt;下一页&lt;/a&gt;&lt;/div&gt; &lt;div style=\"color:red; margin-top:30px;\"&gt;请使用支持html5的浏览器测试&lt;/div&gt; &lt;div&gt;&lt;a href=\"http://www.XXX.net\"&gt;xxx&lt;/a&gt;&lt;/div&gt; 5 html5hash比如：我点击页面上的一个按钮，网址栏中的地址发生改变，但是页面不跳转也不刷新，但是我手动刷新此页面的时候，实际要刷新地址栏中的新地址 其实HTML5早就帮我们解决了 用history.pushState 详情： https://developer.mozilla.org/en/DOM/Manipulating_the_browser_history pushState方法pushState()有三个参数:state对象，标题(现在是被忽略，未作处理)，URL(可选)。具体细节 state对象 是一个JavaScript对象，它关系到由pushState()方法创建出来的新的history实体。用以存储关于你所要插入到历史记录的条目的相关信息。State对象可以是任何Json字符串。因为firefox会使用用户的硬盘来存取state对象，这个对象的最大存储空间为640k。如果大于这个数 值，则pushState()方法会抛出一个异常。如果确实需要更多的空间来存储，请使用本地存储。 title firefox现在回忽略这个参数，虽然它可能将来会被使用上。而现在最安全的使用方式是传一个空字符串，以防止将来的修改。或者可以传一个简短的标题来表示state URL 这个参数用来传递新的history实体的URL，注意浏览器将不会在调用pushState()方法后加载这个URL。但也许会过一会尝试加载这个URL。比如在用户重启了浏览器后，新的url可以不是绝对路径。如果是相对路径，那么它会相对于现有的url。新的url必须和现有的url同域，否则pushState()将抛出异常。这个参数是选填的，如果为空，则会被置为document当前的url。 某种意义上来说，调用pushState()方法很像设置了window.location = “#foo”,这两者都会创建和激活另一个关联到当前document的history实体，但pushState()另外有一些优点： 新的url可以是任何和当前url同域的url，相比之下，如果只设置hash，window.location会保持在同一个document。 如果不需要，你可以不修改url。对比而言，设置window.location = “#foo”;仅产生新的history实体，如果你当前的hash不是#foo 你可以将任意的数据与你的新history实体关联。使用基于hash的方法，需要将所有相关的数据编码为一个短字符串。 注意，pushState()方法不会使hashchange时间发生，即使是新旧url只是hash不同。 如浏览器地址为http://localhost:8080/tts6/user/teachertts6?pMUploadHomework=success 改变为http://localhost:8080/tts6/user/teachertts6 不用请求后台，直接改变url地址，怎么办了？很简单一句话1234567//window.location为//http://localhost:8080/tts6/user/teachertts6?pMUploadHomework=success var state = &#123;title:'',url:window.location.href.split(\"?\")[0]&#125;; history.pushState(state,'','teachertts6');//现在浏览器的地址变为//http://localhost:8080/tts6/user/teachertts6","tags":[{"name":"修改URL","slug":"修改URL","permalink":"https://mowatermelon.github.io/tags/修改URL/"},{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"}]},{"title":"Js学习之禁用常用按键事件","date":"2017-04-26T16:00:00.000Z","path":"2017/04/27/js-Learning-disableBtn/","text":"今天项目需求，我在项目中使用backspace可以在input中进行删除事件，但是不能让backspace触发回退历史上一级的事件 1 最开始我是准备直接监听backspace的keydown事件，直接禁用的，后期才发现，页面上有input是需要执行删除事件的这个也是需要判断的，这个时候是不能进行屏蔽的event.returnValue = true，后期才发现如果想禁用回退，也需要禁用alt+&lt;-,还有alt+-&gt;这边直接整合了一个版本，避免以后再次使用搜索。2 jq中event.which返回: Number描述: 针对键盘和鼠标事件，这个属性能确定你到底按的是哪个键。 event.which 将 event.keyCode 和 event.charCode 标准化了。推荐用 event.which 来监视键盘输入。更多细节请参阅： event.charCode on the MDC. event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3。使用event.which代替event.button。所以代码中的没有出现event.keyCode 3 万恶的ie，我这边主要在页面主框架页面调用了checkBack(),以为就好了，界面在页面中的iframe中还是会触发回退事件，结果我在第二级子页面框架中也调用了checkBack()，这边效果才好，在谷歌中其他按钮事件好像就禁用了，但是在ie中还是有部分问题，第一次认识到iframe其实内部回退机制和在主框架中的回退机制不同，这边之前只把它当作普通标签对，真的对不起他啊.还有在div中其实也可触发回退事件，我感觉我的真的是太乐观了。 4 上完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//页面上进行调用$(\"body,iframe\").bind(\"keydown\", function (e) &#123; &lt;% Response.Buffer=true; //在asp中可以这个样子设置清除缓存 Response.CacheControl=\"no-cache\"; //'禁止代理服务器缓存本页面 Response.Expires=-1000; //'让页面立即过期(这儿最好设置一个绝对值较大的负数) %&gt; checkBack();&#125;);//监听backspace的操作对象function checkBack()&#123; // 兼容FF和IE和Opera var Event = event || window.event; //获取事件对象 var elem = Event.relatedTarget || Event.srcElement || Event.target || Event.currentTarget; //console.log(\"Event.which\" + Event.which); if (Event.which == 8) &#123;//判断按键为backSpace键 //获取按键按下时光标做指向的element var elem = Event.srcElement || Event.currentTarget; //判断是否需要阻止按下键盘的事件默认传递 var name = elem.nodeName; if(name!='INPUT' &amp;&amp; name!='TEXTAREA')&#123; return _stopIt(Event); &#125; var type_e = elem.type.toUpperCase(); if(name=='INPUT' &amp;&amp; (type_e!='TEXT' &amp;&amp; type_e!='TEXTAREA' &amp;&amp; type_e!='PASSWORD' &amp;&amp; type_e!='FILE'))&#123; return _stopIt(Event); &#125; if(name=='INPUT' &amp;&amp; (elem.readOnly==true || elem.disabled ==true))&#123; return _stopIt(Event); &#125; &#125; $(window).bind(\"help\",function()&#123; return false //屏蔽F1帮助 &#125;); $(document).bind(\"contextmenu\", function () &#123; event.returnValue = false; //屏蔽鼠标右键 &#125;); onkeydown(Event);&#125; //判断是否需要阻断backspace的事件function _stopIt(e)&#123; if(e.returnValue)&#123; e.returnValue = false ; &#125; if(e.preventDefault )&#123; e.preventDefault(); &#125; return false;&#125;//监听其他按键的事件执行状态function onkeydown(event) &#123; //console.log(\"event.which\" + event.which); if ((event.altKey) &amp;&amp;((event.which == 37) || //屏蔽Alt+方向键← 2(event.which == 39))) &#123; //屏蔽Alt+方向键→ //console.log(\"不准你使用ALT+方向键前进或后退网页！\"); event.returnValue = false; &#125; if ((event.which == 116) || //屏蔽F5刷新键 2(event.ctrlKey &amp;&amp; event.which == 82)) &#123; //Ctrl+R event.which = 0; event.returnValue = false; &#125; if (event.which == 122) &#123; event.which = 0; event.returnValue = false; &#125; //屏蔽F11 if (event.ctrlKey &amp;&amp; event.which == 78) event.returnValue = false; //屏蔽Ctrl+n if (event.shiftKey &amp;&amp; event.which == 121) event.returnValue = false; //屏蔽shift+F10 if (event.srcElement.tagName == \"A\" &amp;&amp; event.shiftKey) event.returnValue = false; //屏蔽shift加鼠标左键新开一网页 if ((event.altKey) &amp;&amp; (event.which == 115)) &#123; //屏蔽Alt+F4 showModelessDialog(\"about:blank\", \"\", \"dialogWidth:1px;dialogheight:1px\"); return false; &#125;&#125; 5 后续更新 我最初在需要禁用的主页面框架中添加的是如下代码12345678910111213141516171819202122232425262728293031323334//版本一$(\"document,iframe\").bind(\"keydown\", function (e) &#123; &lt;% Response.Buffer=true; Response.CacheControl=\"no-cache\"; //'禁止代理服务器缓存本页面 Response.Expires=-1000; //'让页面立即过期(这儿最好设置一个绝对值较大的负数) %&gt; checkBack();&#125;);//版本二window.onload =function ()&#123; document.getElementsByTagName(\"body\")[0].onkeydown = checkBack;&#125;//版本三window.onload =function ()&#123; document.getElementsByTagName(\"body\")[0].onkeydown = function()&#123; checkBack(); &#125;&#125;//版本四$(function()&#123; //禁止后退键 作用于Firefox、Opera document.getElementsByTagName(\"body\")[0].onkeypress = checkBack; //禁止后退键 作用于IE、Chrome document.getElementsByTagName(\"body\")[0].onkeydown = checkBack; &#125;)//控制流程相关核心代码url = url + \"?XXXX=\" + XXXX +'&amp;new=' + Math.random();$(\"#XXX\").attr(\"src\", url);//控制流程代码方式切换尝试//XXX.location.repalce(url + '?new=' + Math.random());//alert(XXX.Src);//XXX.location.repalce=url + '?new=' + Math.random();//XXX.location.href=url + '?new=' + Math.random(); 然后在谷歌中页面大部分都好了，流程中的iframe也不会乱跳,但是在ie中就是不听话咯，所以我想了一个比较笨的方法，每个页面都添加了checkBack(),结果在ie9中点击iframe空白处还是会触发iframe回退,这边我尝试修改页面跳转方式，这边还是有些问题，不过在我本机的ie11中点击流程的iframe空白处,暂时没有触发回退事件，这边希望之后找到更好的解决办法，再来更新一波。","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"禁用按键","slug":"禁用按键","permalink":"https://mowatermelon.github.io/tags/禁用按键/"}]},{"title":"Js学习之获取当前的屏幕相关高度","date":"2017-04-25T16:00:00.000Z","path":"2017/04/26/js-Learning-getScreen-data/","text":"Javascript: 12345678910111213141516171819202122232425262728293031//IE中：document.body.clientWidth // BODY对象宽度document.body.clientHeight // BODY对象高度document.documentElement.clientWidth // 可见区域宽度document.documentElement.clientHeight // 可见区域高度//FireFox中：document.body.clientWidth // BODY对象宽度document.body.clientHeight // BODY对象高度document.documentElement.clientWidth // 可见区域宽度document.documentElement.clientHeight // 可见区域高度//Opera中：document.body.clientWidth // 可见区域宽度document.body.clientHeight // 可见区域高度document.documentElement.clientWidth // 页面对象宽度（即BODY对象宽度加上Margin宽）document.documentElement.clientHeight // 页面对象高度（即BODY对象高度加上Margin高）//通用：document.body.clientWidth//网页可见区域宽document.body.clientHeight//网页可见区域高document.body.offsetWidth //网页可见区域宽(包括边线的宽)document.body.offsetHeight //网页可见区域高(包括边线的高)document.body.scrollWidth//网页正文全文宽document.body.scrollHeight//网页正文全文高document.body.scrollTop//网页被卷去的高document.body.scrollLeft//网页被卷去的左window.screenTop//网页正文部分上window.screenLeft//网页正文部分左window.screen.height//屏幕分辨率的高window.screen.width//屏幕分辨率的宽window.screen.availHeight//屏幕可用工作区高度window.screen.availWidth//屏幕可用工作区宽度 JQ 12345678$(window).height() //浏览器当前窗口可视区域高度$(document).height() //浏览器当前窗口文档的高度$(document.body).height()/浏览器当前窗口文档body的高度$(document.body).outerHeight(true)//浏览器当前窗口文档body的总高度 包括border padding margin$(window).width()//浏览器当前窗口可视区域宽度$(document).width()//浏览器当前窗口文档对象宽度$(document.body).width()//浏览器当前窗口文档body的宽度$(document.body).outerWidth(true)//浏览器当前窗口文档body的总宽度 包括border padding margin","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"屏幕参数","slug":"屏幕参数","permalink":"https://mowatermelon.github.io/tags/屏幕参数/"}]},{"title":"Js学习之html5本地存储学习","date":"2017-04-24T16:00:00.000Z","path":"2017/04/25/js-Learning-localStorage/","text":"参考网站博客园–谢灿勇,developer.mozillalocalStorage只支持string类型的存储, 1234567891011121314151617181920212223// 保存数据到localStoragewindow.localStorage.setItem('key', 'value');// 从localStorage获取数据var data = window.localStorage.getItem('key');// 从localStorage删除保存的数据window.localStorage.removeItem('key');// 从localStorage删除所有保存的数据window.localStorage.clear();// 保存数据到sessionStoragewindow.sessionStorage.setItem('key', 'value');// 从sessionStorage获取数据var data = window.sessionStorage.getItem('key');// 从sessionStorage删除保存的数据window.sessionStorage.removeItem('key');// 从sessionStorage删除所有保存的数据window.sessionStorage.clear(); localStorage使用的例子123456789101112var storage=window.localStorage; var data=&#123; name:'xiecanyong', sex:'man', hobby:'program' &#125;; var d=JSON.stringify(data); storage.setItem(\"data\",d); //将JSON字符串转换成为JSON对象输出 var json=storage.getItem(\"data\"); var jsonObj=JSON.parse(json); console.log(typeof jsonObj); sessionStorage使用的例子123456789101112131415// 获取文本输入框var field = document.getElementById(\"field\"); // 检测是否存在 autosave 键值// (这个会在页面偶然被刷新的情况下存在)if (window.sessionStorage.getItem(\"autosave\")) &#123; // 恢复文本输入框的内容 field.value = window.sessionStorage.getItem(\"autosave\");&#125; // 监听文本输入框的 change 事件field.addEventListener(\"change\", function() &#123; // 保存结果到 sessionStorage 对象中 window.sessionStorage.setItem(\"autosave\", field.value);&#125;); 目前pc浏览器支持状态 Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) localStorage 4 3.5 8 10.50 4 sessionStorage 5 2 8 10.50 4 目前手机浏览器支持状况 Feature Android Firefox Mobile (Gecko) IE Phone Opera Mobile Safari Mobile Basic support 2.1 ? 8 11 iOS 3.2","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"localStorage","slug":"localStorage","permalink":"https://mowatermelon.github.io/tags/localStorage/"},{"name":"html5","slug":"html5","permalink":"https://mowatermelon.github.io/tags/html5/"}]},{"title":"知识储备之体素了解（转载）","date":"2017-04-23T16:00:00.000Z","path":"2017/04/24/knowledge-reserves-learning-voxel-reprinted/","text":"为什么是体素（Voxel）原文地址 原文tags:程序员,Unity3D,游戏设计 “对不起，美术外包这件事情，多少钱也不能接了。”朋友在微信里面发消息过来，“现在活儿太多，都忙不过来了。” 然后我就知道我们的游戏似乎找不到美术帮忙做特效了，如果有朋友看到这里，碰巧有认识的朋友在做这方面的工作，不妨给介绍一下。 回想起刚毕业那段日子里，对程序员来说真是 很好的时代。那时候程序员到哪里都是团队的核心。经常会有一些有创意的美术会找我们，就算是年长十岁的前辈，也会低声下气的请吃一顿饭，然后说：我有一个不错的游戏创意，求帮忙实现一下吧。然后毕恭毕敬的倒上一杯啤酒。 许久之后之后，但不知道确切是从什么时候开始的，现在想起来似乎可能是Unity3D引擎出现之后吧，这个好日子就到头了。那些 美术家发现，用了引擎之后，原来写个程序也不是什么很困难的事情啊。随便学一些脚本，加上美术资源，套用一些流行的插件，两三个月之后，一个还不错的，很漂亮的游戏就能制作出来了。从此之后，美术家再也不需要搭理我们这些屌丝程序员了。 好的工具和引擎，让开发过程变得简单易用，这必是极好的 事情。但是作为一个程序员，难免有些孤寂的落寞。 所以我需要找到一个可以不需要依赖别的美术家就能自己开发游戏的方法和工具，这时候，看到了体素（Voxel）。 体素简单来说就是立体像素，是用一个个立方体来组成三维模型的方法。就如同一个生物是由很多细胞组成的一样，体素认为一个3D模型是有很多细微的单元组成，相对于传统的三角片表示，这更接近于物理的真实。 但在这里，出于我们的需要，我们只关注体素的艺术概念，而不是技术方向。所谓体素艺术，是用尽量少的体素元素来组成的3D模型。对于很多人来说，这种类似于2D像素风格的表现形式，能给他们带来简单而变态的美感。 我看到体素艺术，不单独是因为我对艺术的修养，而是没有艺术基础的我只能搞这个。相对于其他艺术形式，体素艺术更适合于程序员来操控，因为其3D的特性，我们可以用很多图形学或游戏物理学的手段建立很多漂亮的特效和动画。 但是这里最大的问题是，我如何能创造出体素模型呢，三年前的GameJam上面我曾经自己做了一个体素编辑器，也做过一个简单的游戏，但是因为超级难用也不怎么好看我也就把它遗忘在尘封的往事中了。 我开始寻找好的体素编辑器，我在网上搜索到Magica Voxel这个很不错的工具，虽然不是开源 但是其文件格式是开放的就能很好的应用到我将来的游戏里面。然后我就开始找这个资料，在微博里面看到@gltracyl也发了很多关于Magica Voxel的帖子，我说：兄弟好巧啊，幸会，你也在研究这个工具。@gltracyl 说，啊，不好意思啊，那个Magica Voxel 是我在开发和维护的。 ——请收下我的膝盖。 layout title subtitle tags post Magica Voxel 体素建模软件 Magica Voxel：A free lightweight 8-bit Voxel editor and interactive path tracing renderer, enjoy :) 美术,建模,体素 像素画，这个词想必都听说过。像下面这样的美术风格，我们可能就比较宽泛的定义为像素画，点阵图等等。以其特殊的美术风格以及这两年的怀旧兴起，像素风格普遍的应用在这几年在国内外的游戏中。 好吧，之后考虑如何在游戏里面使用，为了自己能得到更多的可控性，我决定自己写一个Unity3D里面的文件解析工具，然后自己渲染出来。 在开始时候我有个想法是这个东西最终要在手机上面进行，所以尽量能提高渲染效率而不是渲染效果，所以从开始的时候就没打算用任何光照，也基本上没用什么纹理，然后通过比较傻瓜的算法让整个模型只有一个渲染批次这样渲染效率理应会快很多。 然后我又开始做一些比如爆炸什么的效果，在爆炸瞬间，模型从一个完整的Mesh分解成很多很多立方体Voxel，然后崩裂出去。我也做了变型效果，单没有想象的那么漂亮。 在这个过程中发现了体素的更多的奇妙的优点： 1 体素模型是基于 数据而不是基于资源，所以占用内存和硬盘的空间会非常小，如果用点心，几百个游戏可能只有几兆字节这样的极限也可能达到。 2 体素是真实的一个一个的体积元素，他们是真实的物理数据，如果开发者愿意，可以在这个数据上添加更多的流量咯信息，比如一把体素剑，你可以把其中一个元素绑定冰属性 攻击，另外一个元素绑定火属性攻击。如果这样做，在游戏的逻辑的配合下下能带来无尽的可能。 3 易创造，相对于传统的基于三角面的三维模型而言，体素是更接近于物理真实状态的模型。更适合人类创建编辑。打个比方说，我给你一个体素堆，用户可以 好像木雕一样直接从上面销出一个喜欢的杯子或者足球。但是一样三角面模型，你不得不去考虑每个面片之间的拓扑关系。对于非专业的模型创建者，体素模型更适合， 4 易编辑，因为是基于数据本身而不是资源，体素模型更容易被编辑，特别是程序运行期间编辑，比如你可以在游戏中用体素模型给自己铸造一个武器，拼装一个机器战甲这些，对于体素模型来说，都是手到擒来的事情。 发现到这些，我的野心开始慢慢的膨胀了。这不单单是一堆方块而已，而是屌丝程序员对土豪美术家的集体逆袭啊。 我打算把我的（简陋的）代码公布出去，然后把自己使用的以及在网上找到的美术资源也一起放到网上去让所有被美术家抛弃的角落里破落的程序员能得到充足的弹药反击。 这时候我看到了 国外一个网站Sketchfab，它号称自己是3D模型的YouTube，他让用户可以上传自己的3D模型然后展示给别人，然后他们用这个点子忽悠了很多钱。 然后我忽然醒悟，我TMD可以直接致敬他们的网站啊， 只是我的网站不是传统的模型，而只是体素而已。他们是高大上的只有专业人士才能开发的模型，而我这里只需要保存每个普通人都能构建的“乐高积木”就好。我也想了个口号，我们是3D模型的twitter。任何人都可以简单创造分享获得一个艺术话的体素模型。 我的投资人提出一点质疑 ，说人家的模型是大众化的，你的太小众了吧。 我想了一下，其实然也不然，本质上我们的网站和Sketchfab完全不同，他是一个专业的SaaS （软件既服务）网站，提供给专业人士专业的服务。而我们是一个简单的快乐的UGC（用户创造内容），让每个黎民百姓都可以低成本的展示自己的点子和创意。他们是贵族的雕塑学院，我们就只要做幼儿园的乐高积木游戏班就好。 对没错，我们有自己的优势： 1 我们可以提供在线编辑功能，任何人十分钟就可以创造一个新的模型。 2 我们的所有的资源风格统一，你可以任意组合别人的模型创建巨大的艺术场景。 3 我们可以简单的实体化，通过3D打印机和软陶等技术我们可以把模型做成现实的艺术品，你说传统模型也能做啊，但是我告诉你这个成本是天壤之别。 4 我们是游戏的胚胎，一个专业的模型因为精度的原因未必能很好的适应游戏开发，但我们的模型天生就是为了游戏开发而做的，在 后面我们可以提供大量的游戏资源而Sketchfab基本做不到。 也就是说，我们的表现差但是受众更广阔，我们是模型届的 twitter，或者也可以说我们是模型届的新浪微博把。 说做就做，我学了一点bootstrap的皮毛就开始建立网站了。因为我之前用Unity3D做了体素的渲器，所以在开始的时候我打算直接用Unity3D导出一个网页版本的插件就直接放在网站上，这样可以让我的工作量最少并且可以让代码的复用律最高。 但是华丽丽的失败了。 因为Unity3D网页导出根本没办法适应所有的浏览器，层次没办法管理，载入时间过长，不同浏览器表现效果迥异。我他妈的真想放弃了，再去看看Sketchfab，因为是使用Html5进行渲染，所以可以很好的适配不同的平台和浏览器。 摆在我面前两条路，一是等Unity3D之后出了Html5导出插件我再去做这个网站 ，二是摆脱Unity3D重新写一个Html5的Voxel渲染器。尼玛，屌丝程序员的逆袭是不可阻挡和耽误的，我选择了后者。 可这个选择谈何容易，我基本上已经两三年没碰过Html5的代码，在技术日新月异的今天，基本上等于重新学习一门新的技术了。而且我是一个35岁的老程序员了，随着年龄的增加，智商这东西也飞流直下三千尺了。一点一点肯文档也谈何容易。 但是俗话说的好：功夫不负苦心人，屌丝也有出头日。我他妈的就真正的搞出来了_，底层用了three.js库，因为这个原因，比 Sketchfab还牛，在不支持WebGL的平台上，three.js帮我使用了软渲染功能来模型三维模型。也就是说，我们的网站基本上可以跑在任何平台上了。 总结下，这世界上有两个东西是拦不住的，一个是土豪的钱，一个是屌丝逆袭的心。","tags":[{"name":"知识储备","slug":"知识储备","permalink":"https://mowatermelon.github.io/tags/知识储备/"},{"name":"体素了解","slug":"体素了解","permalink":"https://mowatermelon.github.io/tags/体素了解/"},{"name":"转载","slug":"转载","permalink":"https://mowatermelon.github.io/tags/转载/"}]},{"title":"样式之OOCSS","date":"2017-04-22T16:00:00.000Z","path":"2017/04/23/css-learning-OOCSS/","text":"1 定义 OOCSS将页面可重用元素抽象成一个类，用class加以描述，而其对应的html即可以堪称是此类的一个实例，具有封装，继承，对象特性 2 作用 2.1 加强代码复用方便维护 2.2 减少体积 2.3 提升渲染效率 2.4 组件库思想，栅格布局可共用，减少选择器，方便扩展 3 注意事项 3.1 不要直接定义子节点，使用多层嵌套后代选择器，应该把共性声明放到父类中 即可继承的样式，就直接在父级定义 3.2 结构和皮肤像分离 可分离的样式应该分开独立，减少耦合 3.3 容器和内容相分离 大体框架控制布局，具体板块的样式，不要先选择父级再用后代选择器选自己，子类自己玩自己的，方便后期还可以换父级 3.4 抽象出可复用的元素，建好组件库，在组件库内租着可用的元素组装页面 3.5 往你想要扩展的对象本身增加class，而不是他的父节点 3.6 对象应保持独立性， 正确使用语义化 3.7 避免使用id选择器，权重太高，无法重用 3.8 保证选择器相同的权重 3.9 避免位置相关的样式 12.header .container&#123;&#125;.footer .container&#123;&#125; 这样不太好 3.10 类名简短，清晰，语义化，class命名不影响html的语义化 SEO主要针对标签对","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"OOCSS","slug":"OOCSS","permalink":"https://mowatermelon.github.io/tags/OOCSS/"}]},{"title":"样式之Ioshacker","date":"2017-04-21T16:00:00.000Z","path":"2017/04/22/css-learning-ioshacker/","text":"微信项目迁移pc项目功能的时候，发现原有流程中的iframe滚动条没有出来，总结操作过程 1 前情概要 -webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果：参考 12-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */ 2 放上完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;flowDemo&lt;/title&gt; &lt;link href=\"css/bootstrap.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;style&gt;.flow .flowListBox&#123;&#125;#flowDiv&#123; -webkit-overflow-scrolling:touch;/*重要代码*/ overflow:auto;/*重要代码*/ width: 100%;&#125;iframe#iList&#123; width: 100%;/*重要代码*/ height:100%;/*重要代码*/ border:0 none #000; background-color:#fff; word-wrap: break-word;&#125;button.flowBtn&#123;width:41.666666%&#125;button.flowBtn#btnTJ&#123;float:right&#125;button.flowBtn#btnBack&#123;float:left&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"main\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-12\" id=\"fList\"&gt; &lt;div class=\"flow\"&gt; &lt;div class=\"flowListBox\"&gt; &lt;h1&gt;步骤条&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--第一步/--&gt; &lt;div class=\"col-xs-12\" id=\"flowDiv\"&gt; &lt;iframe id=\"iList\" name=\"iframeSelf\" src=\"demo.html\"&gt; &lt;/iframe&gt; &lt;/div&gt; &lt;div class=\"form-group col-sm-8 col-sm-offset-2\"&gt; &lt;button type=\"button\" class=\"btn btn-primary flowBtn\" id=\"btnBack\"&gt;上一步&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary flowBtn\" id=\"btnTJ\"&gt;下一步&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"js/jquery-2.1.1.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"js/modal.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123; ReFlowHeight();&#125;)//页面重新加载的时候计算iframe高度$(window).resize(function () &#123; ReFlowHeight();&#125;);//重新加载界面计算相关高度function ReFlowHeight() &#123; var bodyH = document.documentElement.clientHeight - 150; $(\"#flowDiv\").css(&#123; \"height\": bodyH + \"px\" &#125;);&#125;&lt;/script&gt;&lt;/html&gt; 3 错误总结 我在很早就搜了这个代码，通过多层选择器给iframe的父级div添加了这个样式，结果一直没有效果，今天一看，样式根本就没有绑上去，所以这边还是通过唯一的id选择器，样式就绑上去了，然后这边ios看iframe就可以正常滚动了，但是还是有一丢丢不太友好就是在屏幕点击触发的时候，有的时候触发的是父级body的点击事件，可是父级body的overflow是hidden的，导致页面iframe滚动机制触发有点不太友好，所以估计后期可能会找看看还有没有其他解决机制优化一下效果。","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"ioshacker","slug":"ioshacker","permalink":"https://mowatermelon.github.io/tags/ioshacker/"}]},{"title":"样式之CSS变量","date":"2017-04-20T16:00:00.000Z","path":"2017/04/21/css-learning-CSSVar/","text":"在上个月了解到CSS变量，懒惰如我，就没有好好看一下，只是惊讶了一下，今天想做一个皮肤切换的功能所以想到了这个，好好研究之后，希望能够极大提高渲染效率。日常搬运 1 现有浏览器支持情况 Chrome/Firefox/Safari浏览器对于cssvar兼容性较为良好，我自己做的项目暂时不需要支持太多的低版本浏览器，也不认为我会去支持ie，结论可以上手了。 2 语法，用法和特性2.1 基础语法CSS中原生的变量定义语法是：--*，变量使用语法是：var(--*)，其中*表示我们的变量名称。关于命名这个东西，各种语言都有些显示，例如CSS选择器不能是数字开头，JS中的变量是不能直接数值的，但是，在CSS变量中，这些限制通通没有，例如： 123456:root &#123; --1: #369;&#125;body &#123; background-color: var(--1);&#125; 注：但是，不能包含$，[，^，(，%等字符，普通字符局限在只要是“数字[0-9]”“字母[a-zA-Z]”“下划线_”和“短横线-”这些组合，但是可以是中文，日文或者韩文，例如： 1234body &#123; --深蓝: #369; background-color: var(--深蓝);&#125; 所以，我们就可以直接使用中文名称作为变量，即使英语4级没过的小伙伴也不会有压力了，我们也不需要随时挂个翻译器在身边了。 无论是变量的定义和使用只能在声明块{}里面，例如，下面这样是无效的： 1234--深蓝: #369;body &#123; background-color: var(--深蓝);&#125; 变量的定义，或者说声明跟CSS计数器的声明类似的，你应该摆脱Sass/Less等预编译工具语法先入为主的语法影响，把CSS的原生变量理解为一种CSS属性。 例如下面这个例子： 1234:root &#123; --color: purple; &#125;div &#123; --color: green; &#125;#alert &#123; --color: red; &#125;* &#123; color: var(--color); &#125; 123456&lt;p&gt;我的紫色继承于根元素&lt;/p&gt;&lt;div&gt;我的绿色来自直接设置&lt;/div&gt;&lt;div id='alert'&gt; ID选择器权重更高，因此阿拉是红色！ &lt;p&gt;我也是红色，占了继承的光&lt;/p&gt;&lt;/div&gt; 上面这个例子我们可以获得这些信息： 变量也是跟着CSS选择器走的，如果变量所在的选择器和使用变量的元素没有交集，是没有效果的。例如#alert定义的变量，只有id为alert的元素才能享有。如果你想变量全局使用，则你可以设置在:root选择器上； 当存在多个同样名称的变量时候，变量的覆盖规则由CSS选择器的权重决定的，但并无!important这种用法，因为没有必要，!important设计初衷是干掉JS的style设置，但对于变量的定义则没有这样的需求。 CSS属性名可以走变量吗？ 类似下面这样： 1234body &#123; --bc: background-color; var(--bc): #369;&#125; 答案是不可以，要是可以支持的话，那CSS的压缩可就要逆天了，估计所有的属性都会变成1~2个字符，CSS变量不支持同时多个声明。 CSS变量使用完整语法 CSS变量使用的完整语法为：var( [, ]? )，用中文表示就是：var( &lt;自定义属性名&gt; [, &lt;默认值 ]? )， 意思就是，如果我们使用的变量没有定义（注意，仅限于没有定义），则使用后面的值作为元素的属性值。举个例子： 123456.box &#123;--1: #369;&#125;body &#123;background-color: var(--1, #cd0000);&#125; 则此时的背景色是#cd0000 2.2 不合法的缺省特性请看下面这个例子： 12345body &#123; --color: 20px; background-color: #369; background-color: var(--color, #cd0000);&#125; 上述&lt;body&gt;的背景色会是transparent,对于CSS变量，只要语法是正确的，就算变量里面的值是个乱七八糟的东西，也是会作为正常的声明解析，如果发现变量值是不合法的，例如上面背景色显然不能是20px，则使用背景色的缺省值，也就是默认值代替，于是，上面CSS等同于： 12345body &#123;--color: 20px;background-color: #369;background-color: transparent;&#125; 千万不能想当然得认为等同于background-color:20px，这也是为什么上面要强调CSS默认值的使用仅限于变量未定义的情况，并不包括变量不合法。 2.3 空格尾随特性请看下面这个例子： 1234body &#123; --size: 20; font-size: var(--size)px;&#125; 实际上，此处font-size:var(--size)px等同于font-size:20 px，注意，20后面有个空格，所以，这里的font-size使用的是&lt;body&gt;元素默认的大小。因此，就不要妄图取消就使用一个数值来贯穿全场，还是使用稳妥的做法： 1234body &#123; --size: 20px; font-size: var(--size);&#125; 或者使用CSS3 calc()计算： 1234body &#123; --size: 20; font-size: calc(var(--size) * 1px);&#125; 此时，&lt;body&gt;的font-size大小才是20px， 2.4 相互传递特性就是说，我们在CSS变量定义的时候可以直接引入其他变量给自己使用，例如： 1234body &#123; --green: #4CAF50; --backgroundColor: var(--green);&#125; 或者更复杂的使用CSS3 calc()计算，例如： 1234body &#123; --columns: 4; --margins: calc(24px / var(--columns));&#125; 对于复杂布局，CSS变量的这种相互传递和直接引用特性可以简化我们的代码和实现成本，尤其和动态布局在一起的时候，无论是CSS的响应式后者是JS驱动的布局变化。 随着浏览器宽度减小，demo中的4栏可能就变成3栏，2栏甚至1栏，实际开发的时候，显然不仅仅是栏目数量变化，宽度小，往往意味着访问设备尺寸有限，此时我们往往会缩小空白间距以及文字字号大小，这样，有限屏幕才能显示更多内容。 也就是说，当我们响应式变化的时候，改变的CSS属性值不是1个，而是3个或者更多，如果我们有3个响应点，是不是就至少需要9个CSS声明？但是，由于我们有了CSS变量，同时，CSS变量可以传递，当我们遭遇响应点的时候，我们只需要改变一个CSS属性值就可以了。 下面就是本demo核心CSS代码（只需要改变–columns这一个变量即可）： 123456789101112131415161718192021.box &#123; --columns: 4; --margins: calc(24px / var(--columns)); --space: calc(4px * var(--columns)); --fontSize: calc(20px - 4 / var(--columns));&#125;@media screen and (max-width: 1200px) &#123; .box &#123; --columns: 3; &#125;&#125;@media screen and (max-width: 900px) &#123; .box &#123; --columns: 2; &#125;&#125;@media screen and (max-width: 600px) &#123; .box &#123; --columns: 1; &#125;&#125; 3 整理思路CSS变量有继承性，变量合法的缺省特性，空格尾随特性，内部传递特性,特别是结合了calc之后，在页面布局这一块还是很有作用的，在响应式布局中，也可以不依赖外部样式进行布局，但是这边还没有看到我想要的效果，我希望能够一个css全局去传，但是我在js中之中也可以进行控制，做到切换皮肤的效果，没有看到，不知道这边应该怎样玩耍，没有思路，希望之后可以继续补充，还有今天还看了count()属性，似乎挺有用，但是想了一下，现在一般都是json串遍历，在遍历的过程中index索引是可以传递的，所以不知道这个在实际项目中的用处，不过，content: counter(wangxiaoer, lower-roman);、counter-reset、counter-increment这个我在去年好像就看过，结果到现在再看，还是感觉像看新的一样，捂脸.jpg。","tags":[{"name":"CSS变量","slug":"CSS变量","permalink":"https://mowatermelon.github.io/tags/CSS变量/"},{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"}]},{"title":"样式之Csshacker","date":"2017-04-20T16:00:00.000Z","path":"2017/04/21/css-learning-csshacker/","text":"1 谷歌中默认蓝色边框按钮和input在谷歌中会有一个默认蓝色边框,由于我用的是bootstrap，所以我这边直接就btn的总样式改了，还有加了input的选中样式修改。 12345678910111213141516input,.btn&#123; outline:0 none;&#125;.btn:focus,.btn:active:focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn.active.focus &#123; outline:0 none;&#125;input:hover,input:focus,input:active&#123; outline:0 none;&#125; 2 自动填充的背景色自动填充的文本框默认有个黄色背景，由于chrome浏览器默认的给自动填充的文本框添加了背景样式属性 1234567891011121314151617/*谷歌默认样式*/input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123; background-color: rgb(250, 255, 189); background-image: none; color: rgb(0, 0, 0);&#125;/*修改版本一 没有用*/input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123; background-color: transparent !important; background-image: none; color: var(--c);/*用了一个css变量*/&#125;/*最终建议修改样式*/input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0px 1000px white inset;&#125; 3 文本自动换行 做网页的时候，我们很经常碰到文本的显示，通常来说，文本太长就会很难看，可以用CSS控制文本自动换行。 方法一：你定死盒子的宽度，即给盒子一个宽度值（是数值，不是百分比） 方法二：强制不换行 1234567div&#123; white-space：normal; /*默认不换行;*/ white-space:nowrap; /*nowrap强制在同一行内显示所有文本，*/ /*直到文本结束或者遭遇 &lt;br/&gt; 对象*/&#125; 方法三：自动换行 123456div&#123; word-wrap: break-word; /*normal 亚洲语言和非亚洲语言的文本规则，*/ /*允许在字内换行*/ word-break: normal; &#125; 方法四：强制英文单词断行 1234div&#123; word-break:break-all; /*word-break可以设置强行换行;*/&#125; 4 table-cell设置宽度无效 简洁版 table中有多行的情况下，其中某行的中tr中td在人工设置宽度的前提下，宽度之和超过了其他tr的宽度，这个时候，设置的宽度会无效，解决办法是设置table的table-layout为fixed。 12345678table &#123; table-layout: fixed;/*防止表格撑破*/ word-wrap:break-word;/*防止单词断裂*/&#125;td&#123; word-break: break-all;/*强制英文单词断行*/ word-wrap:break-word;/*防止单词断裂*/&#125; 啰嗦版 前期有个功能需求，需要table中tbody滚动的时候，thead不动，所以我在请求到后台数据之后，将thead中的内容放到一个table中，设置默认不滚动，设置每个th的display为table-cell，将tbody中的内容放到一个table中，放上页面结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div class=\"bootstrap-table\"&gt; &lt;div class=\"fixed-table-container\"&gt; &lt;div class=\"fixed-table-header\"&gt; &lt;table class=\"table table-hover\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th data-field=\"hc_date\" tabindex=\"0\"\"&gt; &lt;div class=\"th-inner\"&gt; 标题1 &lt;/div&gt; &lt;/th&gt; &lt;th data-field=\"hc_date_00\" tabindex=\"0\"\"&gt; &lt;div class=\"th-inner\"&gt; 标题2 &lt;/div&gt; &lt;/th&gt; &lt;th data-field=\"hc_date_01\" tabindex=\"0\"\"&gt; &lt;div class=\"th-inner\"&gt; 标题3 &lt;/div&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class=\"fixed-table-body\"&gt; &lt;table id=\"table\" data-toggle=\"table\" class=\"table table-hover\"&gt; &lt;tbody id=\"danger_body\" class=\"text-center\"&gt; &lt;tr data-index=\"1\"&gt; &lt;td data-field=\"hc_date\" class=\"text-info\"&gt; 内容内容内容内容内容内容内容内容内容 &lt;/td&gt; &lt;td class=\"pointer\" data-field=\"hc_date_00\"&gt; 内容内容内容内容内容内容内容内容内容 &lt;/td&gt; &lt;td class=\"pointer\" data-field=\"hc_date_01\"&gt; 内容内容内容内容内容内容内容内容内容 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 由于fixed-table-header和fixed-table-body中的table是相对独立的，所以我写了一个方法让两个table的每个td尽量保证一样的宽度，方法很烂，就是遍历fixed-table-body table tr(0)中从第一列到倒数第二列td的宽度，对应绑到fixed-table-header table tr的th中去。 123456789var o_header = $(\".fixed-table-header table tr th\"); //获取header部分的thvar o_contanier = $(\".fixed-table-body table tr\"); //获取body一列trvar o_body = $(\".fixed-table-body table tr\").eq(0).children(\"td\"); //获取body部分的第一排的所有tdvar temp_w = 0;for (var i = 0; i &lt; o_header.length - 1; i++) &#123; temp_w = o_body.eq(i).outerWidth(); temp_c_w = o_body.eq(i).width(); o_header.eq(i).attr(\"width\", temp_w + \"px\").children(\"div\").css(\"width\",temp_c_w+\"px\");&#125; 前期项目加载的字段列比较少，没有出什么问题，但是有个地方部署项目之后，而且用的是比较小尺寸的笔记本，在字典中给这个table设置了很多列，而且每列对应的内容还比较多，fixed-table-body table中出现了横向滚动条，所以布局一下乱套了，我突然发现我给fixed-table-header table tr的th设置宽度没有用了，因为这个时候，我给所有th设置的宽度总和超过了一个tr的宽度，fixed-table-header table就不干了，说这不行，认为是出了异常，所以就忽略了我的宽度，很尴尬，我由于平时对table不怎么在意，所包含的属性值不太熟，所以一下有点懵。 后来发现了这个css属性table-layout，这个是table的一个属性，有三个可选值inherit|auto|fixed。 属性值 含义 inherit 继承父级设置 auto(自动算法) 布局将基于各单元格的内容。表格在每一单元格读取计算之后才会显示出来，速度很慢，就是让table自己判断，超出一行tr长度之后，就不管单个td宽度设置，不满足实际需求。 fixed(固定布局的算法) 在这算法中，水平布局是仅仅基于表格的宽度，表格边框的宽度，单元格间距，列的宽度，而和表格内容无关。也就是说，内容可能被裁切，设置为fixed会保证每一个td的宽度加起来不会超过一行tr的宽度。","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"csshacker","slug":"csshacker","permalink":"https://mowatermelon.github.io/tags/csshacker/"}]},{"title":"样式之页面整体设计","date":"2017-04-19T16:00:00.000Z","path":"2017/04/20/css-learning-pageDesign/","text":"主要是做注册和登录界面,用了很多媒体查询感觉还不错的样子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*** Created by wu Eva on 2017/03/23.*/@charset \"utf-8\";* &#123; margin: 0; padding: 0&#125;.clearfix:after &#123; visibility: hidden; display: block; font-size: 0; content: \".\"; clear: both; height: 0;&#125;.clearfix &#123; display: inline-table; zoom: 1&#125;input &#123; border: 0&#125;h3 &#123; font-weight: 400&#125;* html .clearfix &#123; height: 1%&#125;ul li &#123; list-style: none&#125;a &#123; text-decoration: none; cursor:pointer;&#125;body &#123; background-color: #eee; font-family: \"Microsoft Yahei\"!important;&#125;* &#123; margin: 0 0 0 0; padding: 0 0 0 0;&#125;ul li &#123; list-style: none;&#125;/*header---------------------------------------------------*/#header &#123; background-color: #5bc0de; margin-bottom: 50px; box-shadow: 2px 0 10px #eee; height: 80px; z-index: 2;&#125;#header .headerBox &#123; display: block; overflow: hidden; margin: 0 auto; background-image: url(\"../Image/Login/logo.png\"); background-repeat: no-repeat; background-size: 50px 70%; background-position: 30px center;&#125;#header .headerBox .Rtitle &#123; font-size: 36px; margin-left: 80px; display: inline-block; color: #fff; line-height: 80px; word-break: keep-all;/* 不换行 */ white-space: nowrap;/* 不换行 */&#125;/*main---------------------------------------------------*//*** 页面整体设置*/.main &#123; display: block; margin-top: 50px; background-color: #fff !important; padding: 3%; -moz-box-shadow: inset 0 0.2em 1em 0.2em rgba(205, 255, 246, 0.83);/* Firefox */ -webkit-box-shadow: inset 0 0.2em 1em 0.2em rgba(205, 255, 246, 0.83);/* Safari 和 Chrome */ box-shadow: inset 0 0.2em 1em 0.2em rgba(205, 255, 246, 0.83); -moz-border-radius: 1em;/* Firefox */ -webkit-border-radius: 1em;/* Safari 和 Chrome */ border-radius: 1em;/* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 */&#125;@media (min-width:768px) &#123; #header .headerBox &#123; width: 60%; &#125;&#125;@media (min-width:992px) &#123; #header .headerBox &#123; width: 50%; &#125; .main &#123; width: 700px; height: 650px; &#125; .main .row #mainBox &#123; margin: 5% 25%; &#125;&#125;@media(min-width:1200px) &#123; #header .headerBox &#123; width: 40%; &#125; .main &#123; width: 1200px; height: 710px; &#125; .main .row #mainBox &#123; margin: 5% 25%; &#125;&#125;","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"整体设计","slug":"整体设计","permalink":"https://mowatermelon.github.io/tags/整体设计/"}]},{"title":"样式之横竖屏判断","date":"2017-04-18T16:00:00.000Z","path":"2017/04/19/css-learning-horizontal-vertical-screen-determination/","text":"12345/* 竖屏 */ @media screen and (orientation: portrait) and (max-width: 720px) &#123; 对应样式 &#125; /* 横屏 */ @media screen and (orientation: landscape) &#123; 对应样式 &#125;","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"横竖屏判断","slug":"横竖屏判断","permalink":"https://mowatermelon.github.io/tags/横竖屏判断/"}]},{"title":"样式表小白之路","date":"2017-04-17T16:00:00.000Z","path":"2017/04/18/css-learning-basic/","text":"做了一个图片居中的效果，学习到媒体查询的使用方法 123456789101112131415161718192021222324@charset \"UTF-8\";body&#123; height: 100%;&#125;.box&#123; height: 500px; background-repeat: no-repeat; background-image: url(\"03.jpg\"); background-position: center center; background-size: 100% 100%; text-align: center;&#125;@media (min-width: 992px) &#123; .col-md-8&#123; margin: 0 300px; &#125;&#125;@media screen (min-width: 992px) and (min-width:768px) &#123; .col-md-8&#123; margin: 0 300px; &#125;&#125;","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"小白之路","slug":"小白之路","permalink":"https://mowatermelon.github.io/tags/小白之路/"}]},{"title":"样式表之媒体查询","date":"2017-04-16T16:00:00.000Z","path":"2017/04/17/css-learning-mediaQuery/","text":"来至搬运工 媒体查询相关关键词 @media only screen and only(限定某种设备) screen 是媒体类型里的一种 and 被称为关键字，其他关键字还包括 not(排除某种设备) 常用类型 类型 解释 all 所有设备 braille 盲文 embossed 盲文打印 handheld 手持设备 print 文档打印或打印预览模式 projection 项目演示，比如幻灯 screen 彩色电脑屏幕 speech 演讲 tty 固定字母间距的网格的媒体，比如电传打字机 tv 电视 ps:screen一般用的比较多，下面是我自己的尝试，列出常用的设备的尺寸，然后给页面分了几个尺寸的版本。 常用设备 设备 屏幕尺寸 显示器 1280 x 800 ipad 1024 x 768 Android 800 x 480 iPhone 640 x 960 两种方式1234567891011/*&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styleB.css\" media=\"screen and (min-width: 600px) and (max-width: 800px)\"&gt;意思是当屏幕的宽度大于600小于800时，应用styleB.css*/@media screen and (max-width: 600px) &#123; /*当屏幕尺寸小于600px时，应用下面的CSS样式*/ .class &#123; background: #ccc; &#125;&#125; 媒体查询相关关键词 device-aspect-ratio device-aspect-ratio可以用来适配特定屏幕长宽比的设备，这也是一个很有用的属性，比如，我们的页面想要对长宽比为4:3的普通屏幕定义一种样式，然后对于16:9和16:10的宽屏，定义另一种样式，比如自适应宽度和固定宽度：1@media only screen and (device-aspect-ratio:4/3) -webkit-min-device-pixel-ratio的常见值对比（是设备上物理像素和设备独立像素，设备像素比率） 设备 分辨率 设备像素比率 Android LDPI 320×240 0.75 Iphone 3 &amp; Android MDPI 320×480 1 Android HDPI 480×800 1.5 Iphone 4 960×640 2.0 -webkit-min-device-pixel-ratio: 1.0 所有非 Retina 的 Mac 所有非 Retina 的 iOS 设备 Acer Iconia A500 Samsung Galaxy Tab 10.1 Samsung Galaxy S 其他设备 -webkit-min-device-pixel-ratio为1.3 Google Nexus 7 -webkit-min-device-pixel-ratio为1.5 Google Nexus S Samsung Galaxy S II HTC Desire HTC Desire HD HTC Incredible S HTC Velocity HTC Sensation -webkit-min-device-pixel-ratio为2.0 iPhone 4 iPhone 4S iPhone 5 iPad (3rd generation) iPad 4 所有Retina displays 的MAC Google Galaxy Nexus Google Nexus 4 Google Nexus 10 Samsung Galaxy S III Samsung Galaxy Note II Sony Xperia S HTC One X -webkit-min-device-pixel-ratio: 3.0 1.HTC Butterfly 2.Sony Xperia S @media only screen and (min-resolution:144dpi)（分辨率） 使用于：位图媒体类型,接受max/min前缀：resolution媒体特性描述输出设备的分辨率，例如，像素密度。若查询设备的非方形像素，在min-resolution查询中指定的值必须与最稀疏尺寸进行比较，在max-resolution查询中必须与最密集尺寸进行比较。对于resolution（没有min-或max-前缀）查询从不查询设备的非方形像素。 对于印刷机，相当于分辨率（任意颜色的绘制点的分辨率）。 举例说明：该媒体查询表示样式表适用于分辨率大于每英寸144点的设备：1@media print and (min-resolution: 144dpi) &#123; … &#125;","tags":[{"name":"样式表","slug":"样式表","permalink":"https://mowatermelon.github.io/tags/样式表/"},{"name":"媒体查询","slug":"媒体查询","permalink":"https://mowatermelon.github.io/tags/媒体查询/"}]},{"title":"软件折腾之Vscode小白入门","date":"2017-04-16T16:00:00.000Z","path":"2017/04/17/software-learning-vscode-basic/","text":"前情概要 我主要用过的编辑器是Hbuilder和atom，但是Hbuilder的界面感觉不太好看而且启动很慢。atom最近被我装一堆插件，好像玩坏了，每次一开软件，就各种报错，直接提示是否强制关闭，看到尤大也用vscode了就看看这个软件。 1 下载过程打开官网进行下载,在我点击下载之后，网址跳转到https://vscode-update.azurewebsites.net/latest/win32-x64/stable,没有正在下载的提示，页面直接显示 无法访问此网站连接已重置。 整个人很懵，感觉到了深深的恶意，你好歹能让我下软件，瞅两眼去下载插件的时候再显示这个，我倒还有些心理安慰，我赶紧翻了个墙，插播广告影梭大法好,翻了墙之后，vscode软件下载还是很快的只有40.5 MB，下载的文件名是VSCodeSetup-x64-1.15.1.exe，不过好像在网络情况比较好的情况下不用翻墙就可以下载。 2 安装过程作为一个英语战五渣的人，幸好没有一路点击next，在选择完软件安装路径之后，同意了软件安装协议之后，出现选项是否将vscode添加到右键查看就是在文件管理器选择对应文件夹和文件时能不能通过右键之间选择vscode查看，真的是多看了一眼，赶紧勾选，还有是否将vscode在桌面生成快捷方式，赶紧勾选。之后就是慢慢安装了，感觉安装过程有丢丢慢，我感觉我都刷了半天知乎了，还没安装完。 3 软件初体验软件安装完成之后，会默认直接运行VSCODE,当然这也是我想要的，我就直接点击确定了。VSCODE一打开，第一反应就是安装插件，感觉VSCODE的图标提示作用对我这种小白不太明显，除去header中的一些默认功能，在软件最左侧有些快捷跳转。 3.1 files-文件管理器通过这个入口可以管理当前打开文件夹的目录树，也可以管理当前打开的面板，下载对应的文件图标管理插件，界面显示效果挺好。 3.2 find-单独的搜索界面在VSCODE中通过ctrl+H/F快捷键出来的搜索框只能在当前面板最上方进行显示，并不能移动位置，这个体验有丢丢不太好，所以为了弥补这个在左侧专门弄了一个入口可以将搜索框固定在左侧，可以选择需要查询和替换的文件范围，也可以排除一定文件，对于经常在Studio中在当前项目中进行全部匹配的查找之后，忘记改回仅在当前文档中进行替换的我来说，这个体验要点赞。 可是显示了固定了搜索面板之后，目录树面板就不能显示，感觉体验也不太好，全部替换按钮有丢丢隐蔽，那个按钮我还以为是切换英文大小写。 我写好要查找条件和替换结果之后完全不知道要干嘛，只能尝试性的用了一下ENTER,这个是对当前文件夹下的所有文件进行匹配查询返回查询结果，有多少文件中包含该查询条件，在每个包含中显示当前文件中使用到的次数，我就在查询反馈的结果中选择替换，每一次替换，右侧文件预览的页面就会跳出修改结果的版本对比，感觉这个功能有丢丢鸡肋，我就替换了几个小地方，结果你给我开了一堆面板，这个不太好吧。 3.3 git-版本管理入口我对于git指令几乎就是不熟悉，完全就是开心的把所有的按钮都点击了一遍，日常骄傲.jpg。 首先打开对应的包含.git管理文件夹第一步 先选择同步/避免相关修改冲突/第二步 进行相关修改第三步 暂存所有修改第四步 commit所有修改，将存在暂存区的文件进行提交第五步 拉取所有修改git pull第六步 推送所有修改git push第七步 输入当前git对应文件的远程仓库用户名和密码第八步 如果输出控制台没有任何报错，则说明push成功，如果说有报错请按照报错说明对文件进行相关修改。 3.4 debugging-调试入口这个我目前没有使用到，对于软件主要是编辑markdown和写一些html，以后用到再说。 3.5 plugin-插件管理入口这里说些我目前觉得必装的插件 3.5.1 Auto-Open Markdown Preview你打开一个markdown文件，右侧会对当前文件进行预览显示。 3.5.2 Markdown Preview Github Style你打开一个markdown文件，预览效果与你在Github上的预览效果是一样的，VSCODE上默认的预览高亮不会改变背景颜色，只会改变字体颜色，还有和平常使用atom预览的效果有很多不同，所以你如果要用VSCODE写markdown，建议要安装这个。 3.5.3 markdownlint管理现有markdown的格式正确性 3.5.4 anyview原本专门下载了html preview,结果效果不太好，当时一起下载了好几个关于html预览的插件，感觉这个还不错。 3.5.5 Git History可以在控制台直接打印当前版本操作的git指令，推荐安装。 3.5.1 Material Icon Theme根据文件类型，自动显示对应的文件图标，这个是我看几个主题中，显示的比较友好的一款，推荐安装。","tags":[{"name":"vscode","slug":"vscode","permalink":"https://mowatermelon.github.io/tags/vscode/"},{"name":"软件折腾","slug":"软件折腾","permalink":"https://mowatermelon.github.io/tags/软件折腾/"}]},{"title":"框架学习之学习之Vue学习","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/framework-learning-vue-basic/","text":"很早就知道了vue，在很早之前看过一丢丢官网，上个周末看了一个关于使用了vue-resources插件的vue购物车应用，功能比较齐全，但是代码极为简约，才发现这个使用了mvvm思维的vue是多么方便开发，所以来重新学习一下。搬运vue官网 1. 安装vue1.1 直接下载对应的jsVue 会被注册为一个全局变量。重要提示：在开发时请用开发版本，遇到常见错误它会给出友好的警告。 开发版 包含完整的警告和调试模式 生产版 删除了警告，24.72kb min+gzip CDN 推荐：[unpkg](https://unpkg.com/vue@2.3.0/dist/vue.js), 会保持和 npm 发布的最新的版本一致。可以在 [unpkg.com/vue/](https://unpkg.com/vue) 浏览 npm 包资源。 也可以从 [jsdelivr](https://cdn.jsdelivr.net/vue/2.1.3/vue.js) 或 [cdnjs](https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.3/vue.js) 获取，不过这两个服务版本更新可能略滞后。 &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; tip: 开发环境不要用最小压缩版，不然就失去了错误提示和警告! 1.2 npm1.2.1 推荐 在用Vue.js构建大型应用时推荐使用 NPM 安装， NPM 能很好地和诸如 [Webpack](http://webpack.github.io/) 或 [Browserify](http://browserify.org/) 模块打包器配合使用。 Vue.js 也提供配套工具来开发[单文件组件](https://cn.vuejs.org/v2/guide/single-file-components.html)。 123# shell# 最新稳定版$ npm install vue 1.2.2 独立构建 vs 运行时构建 有两种构建方式，独立构建和运行构建。它们的区别在于前者包含模板编译器而后者不包含。 模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 template 选项，你就需要编译器。 独立构建包含模板编译器并支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。 运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%，只有 17.14 Kb min+gzip大小。 默认 NPM 包导出的是 运行时 构建。为了使用独立构建，在 webpack 配置中添加下面的别名： 123456 // javascriptresolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.common.js' &#125;&#125; 对于Browserify，可以添加一个别名到 package.json 中： 1234 // javascript\"browser\": &#123; \"vue\": \"vue/dist/vue.common\"&#125;, 1.3 CSP 环境 有些环境，如 Google Chrome Apps ，强制应用内容安全策略 (CSP) ，不能使用 new Function() 对表达式求值。这时可以用 CSP 兼容版本。独立的构建取决于该功能编译模板，所以无法使用这些环境。 另一方面，运行时构建的是完全兼容 CSP 的。当通过 Webpack + vue-loader或者 Browserify + vueify 构建时，在 CSP 环境中模板将被完美预编译到 render 函数中。 1.4 命令行工具 Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目： 123456789 # shell# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev tip CLI 工具假定用户对 Node.js 和相关构建工具有一定程度的了解。如果你是新手，我们强烈建议先在不用构建工具的情况下通读指南，熟悉 Vue 本身之后再研究 CLI。 对于大陆用户，建议将 npm 的注册表源设置为[国内的镜像](http://riny.net/2014/cnpm/)，可以大幅提升安装速度。 1.5 开发版本 重要: Github 仓库的 /dist 文件夹只有在新版本发布时才会更新。如果想要使用 Github 上 Vue 最新的源码，你需要自己构建。 12345# shellgit clone https://github.com/vuejs/vue.git node_modules/vuecd node_modules/vuenpm installnpm run build 1.6 Bower12345# shellgit clone https://github.com/vuejs/vue.git node_modules/vuecd node_modules/vuenpm installnpm run build 1.7 AMD 模块加载器 独立下载版本或通过 Bower 安装的版本已用 UMD 包装，因此它们可以直接用作 AMD 模块。 2 vue基础语法","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"vue","slug":"vue","permalink":"https://mowatermelon.github.io/tags/vue/"}]},{"title":"软件折腾之Chrome请求本地文件","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/software-learning-chrome-request-local-files/","text":"今天在做一个demo测试的时候发现谷歌中有如下报错 123XMLHttpRequest cannot load file:///D:/XXX?%20&amp;T=0.2576446940590924. Cross origin requests are only supported for protocol schemes: `http`, `data`,` chrome`, `chrome-extension`, `https`. 报错的意思应该就是chrome下，跨域请求只能通过通过这些协议标准实现：http、data、https、chrom-extension、chrom-extension-resource。 1 什么叫跨域(WHAT)？ 字面理解，跨是跨越，域是别的服务器，跨域就是到别的服务器上取东西。 只要协议、域名、或端口有任何一个不同，就会被当做是不同的域。 2 为何会跨域(WHY)？ chrome在读取本地相对路径脚本时，禁止向第三方请求数据。 只要是通过file://方式访问，或者直接拖进浏览器访问，都叫本地运行 什么叫第三方？那就是不管本地文件、还是服务器url文件都不行。 3 怎么解决(HOW)？查资料，发现有一种解决方法，不用启动服务器模式，直接更改chrome的设置就行。 放上默认的参数 参考官网https://code.google.com/archive/p/xiaody/wikis/ChromiumCommandLineSwitches.wiki 序号 参数 说明 1 –allow-outdated-plugins 不停用过期的插件。 2 –allow-running-insecure-content 默认情况下，https 页面不允许从 http 链接引用 javascript/css/plug-ins。添加这一参数会放行这些内容。 3 –allow-scripting-gallery 允许拓展脚本在官方应用中心生效。默认情况下，出于安全因素考虑这些脚本都会被阻止。 4 –disable-accelerated-2d-canvas 停用 GPU 加速二维画布。 5 –disable-accelerated-video 停用 GPU 加速视频。 6 –disable-dart 停用 Dart。 7 –disable-desktop-notifications 禁用桌面通知，在 Windows 中桌面通知默认是启用的。 8 –disable-extensions 禁用拓展。 9 –disable-file-system 停用 FileSystem API。（注意一些拓展如 Adblock Plus for Google Chrome™ 依赖此 API 运行） 10 –disable-java 停用 Java。 11 –disable-local-storage 禁用 LocalStorage。 12 –disable-preconnect 停用 TCP/IP 预连接。 13 –disable-remote-fonts 关闭远程字体支持。SVG 中字体不受此参数影响。 14 –disable-speech-input 停用语音输入。 15 –disable-sync 停用同步功能。 16 –disable-ssl3 停用 SSL v3。 17 –disable-web-security 不强制遵守同源策略，供网站开发人员测试站点使用。 18 –disk-cache-dir 将缓存设置在给定的路径。 19 –disk-cache-size 设置缓存大小上限，以字节为单位。 20 –dns-prefetch-disable 停用DNS预读。 21 –enable-print-preview 启用打印预览。 22 –extensions-update-frequency 设定拓展自动更新频率，以秒为单位。 23 –incognito 让浏览器直接以隐身模式启动。 24 –keep-alive-for-test 最后一个标签关闭后仍保持浏览器进程。（某种意义上可以提高热启动速度，不过你最好得有充足的内存） 25 –kiosk 启用kiosk模式。（一种类似于全屏的浏览模式） 26 –lang 使用指定的语言。 27 –no-displaying-insecure-content 默认情况下，https 页面允许从 http 链接引用图片/字体/框架。添加这一参数会阻止这些内容。 28 –no-first-run 跳过 Chromium 首次运行检查。 29 –no-referrers 不发送 Http-Referer 头。 30 –no-sandbox 彻底停用沙箱。 31 –no-startup-window 启动时不建立窗口。 32 –proxy-pac-url 使用给定 URL 的 pac 代理脚本。（也可以使用本地文件，如 –proxy-pac-url=”file:\\c:\\proxy.pac”） 33 –proxy-server 使用给定的代理服务器，这个参数只对 http 和 https 有效。（例如 –proxy-server=127.0.0.1:8087 ） 34 –show-component-extension-options 让自带的拓展组件显示在 chrome://settings/extensions 里。（目前有一个 “Bookmark Manager 0.1”） 35 –single-process 以单进程模式运行 Chromium。（启动时浏览器会给出不安全警告） 36 –skip-gpu-data-loading 跳过启动时的 GPU 信息收集、黑名单读取与黑名单自动更新，这样一来，所有的 GPU 功能都可供使用，并且 about:gpu 页面会显示空白。此参数仅供测试使用。 37 –start-maximized 启动时最大化。 38 –touch-optimized-ui 使用对触屏更友好的用户界面。（目前来看似乎只是把一些字体放大了） 39 –user-agent 使用给定的 User-Agent 字符串。 40 –user-data-dir 浏览器存储用户配置文件的目录。 41 –allow-file-access-from-files 允许本地Ajax请求，也叫file协议下的Ajax请求 42 –enable-file-cookies 允许本地的cookies 在chrome属性设置中，添加启动参数：–args –disable-web-security –user-data-dir--allow-file-access-from-files window 设置方法：chrome快捷方式–右键属性–快捷方式–目标1\"D:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" --allow-file-access-from-files mac 1234//chrome 浏览器open -a \"Google Chrome\" //safari 浏览器 open -a '/Applications/Safari.app' --allow-file-access-from-files linux 1chromium-browser --allow-file-access-from-files","tags":[{"name":"chrome","slug":"chrome","permalink":"https://mowatermelon.github.io/tags/chrome/"},{"name":"软件折腾","slug":"软件折腾","permalink":"https://mowatermelon.github.io/tags/软件折腾/"}]},{"title":"前端知识之Json序列化","date":"2017-04-14T16:00:00.000Z","path":"2017/04/15/the-front-end-knowledge-json-serialization/","text":"前情概要，对于json的处理我一直在前端获取对应的值之后，然后利用eval()函数进行处理，将后台传过来的string类型的json进行序列化，但是这样把所有的数据放到前台界面的某个标签中，将该标签隐藏，但是其实页面不渲染，不代表进行源码查看的时候不能看到对应的完整数据，这样对于数据是很不负责的行为，所以今天花了很多时间在后台读取多节点xml数据和将数据序列化上。 1 介绍json 摘抄自某百科 1.1 JSON定义JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在 JS 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型。 对象：对象在 JS 中是使用花括号包裹 {} 起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。 数组：数组在 JS 中是方括号 [] 包裹起来的内容，数据结构为 [“java”, “javascript”, “vb”, …] 的索引结构。在 JS 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引使用得多。同样，值的类型可以是任意类型。 1.2 JSON 与 JS 对象的关系很多人搞不清楚 JSON 和 Js 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 12var obj = &#123;a: 'Hello', b: 'World'&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JS 对象互转要实现从对象转换为 JSON 字符串，使用 JSON.stringify() 方法： 123var json = JSON.stringify(&#123;a: 'Hello', b: 'World'&#125;); //结果是 '&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'要实现从 JSON 转换为对象，使用 JSON.parse() 方法：var obj = JSON.parse('&#123;\"a\": \"Hello\", \"b\": \"World\"&#125;'); //结果是 &#123;a: 'Hello', b: 'World'&#125; 1.3 JSON 与 xml的关系1.3.1 可读性JSON和XML的可读性可谓不相上下，一边是简易的语法，一边是规范的标签形式，很难分出胜负。 1.3.2 可扩展性XML天生有很好的扩展性，JSON当然也有，没有什么是XML可以扩展而JSON却不能扩展的。不过JSON在Javascript主场作战，可以存储Javascript复合对象，有着xml不可比拟的优势。 1.3.3 编码难度XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有提供的工具。无工具的情况下，相信熟练的开发人员一样能很快的写出想要的xml文档和JSON字符串，不过，xml文档要多很多结构上的字符。 1.3.4 解码难度XML的解析方式有两种： 一是通过文档模型解析，也就是通过父标签索引出一组标记。例如：xmlData.getElementsByTagName(&quot;tagName&quot;)，但是这样是要在预先知道文档结构的情况下使用，无法进行通用的封装。 另外一种方法是遍历节点（document 以及 childNodes）。这个可以通过递归来实现，不过解析出来的数据仍旧是形式各异，往往也不能满足预先的要求。 凡是这样可扩展的结构数据解析起来一定都很困难。 JSON也同样如此。如果预先知道JSON结构的情况下，使用JSON进行数据传递简直是太美妙了，可以写出很实用美观可读性强的代码。如果你是纯粹的前台开发人员，一定会非常喜欢JSON。但是如果你是一个应用开发人员，就不是那么喜欢了，毕竟xml才是真正的结构化标记语言，用于进行数据传递。 而如果不知道JSON的结构而去解析JSON的话，那简直是噩梦。费时费力不说，代码也会变得冗余拖沓，得到的结果也不尽人意。但是这样也不影响众多前台开发人员选择JSON。因为json.toJSONString()就可以看到JSON的字符串结构。当然不是使用这个字符串，这样仍旧是噩梦。常用JSON的人看到这个字符串之后，就对JSON的结构很明了了，就更容易的操作JSON。 以上是在Javascript中仅对于数据传递的xml与JSON的解析。在Javascript地盘内，JSON毕竟是主场作战，其优势当然要远远优越于xml。如果JSON中存储Javascript复合对象，而且不知道其结构的话，我相信很多程序员也一样是哭着解析JSON的。 除了上述之外，JSON和XML还有另外一个很大的区别在于有效数据率。JSON作为数据包格式传输的时候具有更高的效率，这是因为JSON不像XML那样需要有严格的闭合标签，这就让有效数据量与总数据包比大大提升，从而减少同等数据流量的情况下，网络的传输压力。 2 介绍json序列化 公司使用的是c#做后台所以需要注意using，参考某博客 2.1 serialize将string转化为jsonList或者jsonArray类型 123456Product product = new Product();product.Name = &quot;Apple&quot;;product.Expiry = new DateTime(2008, 12, 28);product.Sizes = new string[] &#123; &quot;Small&quot; &#125;;string json = new JavaScriptSerializer().Serialize(product); 2.2 Deserialize将jsonList或者jsonArray转化为string类型 12345678910111213141516171819using System.Web.Script.Serialization;protected void Page_Load(object sender, EventArgs e) &#123; Personnel personnel = new Personnel(); personnel.Id = 1; personnel.Name = &quot;小白&quot;; JavascriptSerializer jsonSerializer = new JavascriptSerializer(); //执行序列化 string r1 = jsonSerializer.Serialize(personnel); //执行反序列化 Personnel _Personnel = jsonSerializer.Deserialize&lt;Personnel&gt;(r1); &#125;public class Personnel &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; &#125; 2.3 小技巧可以使用IgnoreDataMember:指定该成员不是数据协定的一部分且没有进行序列化，DataMember:定义序列化属性参数，使用DataMember属性标记字段必须使用DataContract标记类 否则DataMember标记不起作用。12345678[DataContract] public class People &#123; [DataMember(Name = &quot;id&quot;)] public int Id &#123; get; set; &#125; [IgnoreDataMember] public string Name &#123; get; set; &#125; &#125; 输出结果: {“id”:1} 2.4 完整案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;using System.Xml;//读取xml这个一定要usingusing System.Text;using XXX.Model;using System.Web.Script.Serialization;//序列化json这个一定要usingnamespace GREI.Suite&#123; public partial class Main : System.Web.UI.Page &#123; //public string LeftList; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; LoadLeftList(); &#125; &#125; public void LoadLeftList() &#123; String LeftList =LoadListXml(); List&lt;LeftLists&gt; LeftLs = new JavaScriptSerializer().Deserialize&lt;List&lt;LeftLists&gt;&gt;(LeftList); //将json数据转化为对象类型并赋值给list String modules =&quot;&lt;div class=\\&quot;panel-group wrap\\&quot; id=\\&quot;accordion\\&quot; role=\\&quot;tablist\\&quot; aria-multiselectable=\\&quot;true\\&quot;&gt;\\n&quot;; for (int n = 0; n &lt; LeftLs.Count; n++) &#123; modules += &quot;&lt;div class=&apos;panel&apos; id=&apos;panel-&quot;+n+&quot;&apos;&gt;\\n&quot;; modules += &quot; &lt;div class=\\&quot;panel-heading\\&quot; role=\\&quot;tab\\&quot; id=&apos;heading-&quot;+n+&quot;&apos;&gt;\\n&quot;; modules += &quot; &lt;h4 class=\\&quot;panel-title\\&quot;&gt;&lt;a role=\\&quot;button\\&quot; data-toggle=\\&quot;collapse\\&quot; data-parent=\\&quot;#accordion\\&quot; href=&apos;#panel-in-&quot; + n + &quot;&apos; aria-expanded=\\&quot;true\\&quot; aria-controls=&apos;panel-in-&quot; + n + &quot;&apos;&gt;&quot; + LeftLs[n].ParentName + &quot;&lt;/a&gt;&lt;/h4&gt;\\n&quot;; modules += &quot; &lt;/div&gt;\\n&quot;; modules += &quot; &lt;div id=&apos;panel-in-&quot; + n + &quot;&apos; class=\\&quot;panel-collapse collapse\\&quot; role=\\&quot;tabpanel\\&quot; aria-labelledby=&apos;panel-in-&quot; + n + &quot;&apos;&gt;\\n&quot;; modules += &quot; &lt;div class=\\&quot;panel-body\\&quot;&gt;\\n&quot;; modules += &quot; &lt;div class =&apos;list-group&apos; id=&apos;panel-list-&quot;+n+&quot;&apos;&gt;\\n&quot;; for (int m = 0; m &lt; LeftLs[n].data.Count; m++) &#123; modules += &quot; &lt;a onclick=&apos;open_xml_win(&apos;Rlist&apos;,&quot; + LeftLs[n].data[m].Url + &quot;)&apos; class =&apos;list-group-item&apos;&gt;&quot; + LeftLs[n].data[m].Name + &quot;&lt;/a&gt;\\n&quot;; &#125; modules += &quot; &lt;/div&gt;\\n&quot;; modules += &quot; &lt;/div&gt;\\n&quot;; modules += &quot; &lt;/div&gt;\\n&quot;; modules += &quot;&lt;/div&gt;\\n&quot;; &#125; modules += &quot;&lt;/div&gt;\\n&quot;; leftTree.InnerHtml = modules; &#125; public string LoadListXml() &#123; XmlDocument XmlDoc = new XmlDocument(); string paths = &quot;XXX/XXX.xml&quot;; paths = Server.MapPath(paths); StringBuilder sb = new StringBuilder(); try &#123; XmlDoc.Load(paths); XmlNode xnroot = XmlDoc.SelectSingleNode(&quot;WorkFlow&quot;); sb.Append(&quot;[&quot;); int index = 0; foreach (XmlNode xnType in xnroot.ChildNodes) &#123; if (xnType.NodeType == XmlNodeType.Comment) &#123; continue; &#125; if (index &gt; 0) &#123; sb.Append(&quot;,&quot;); &#125; XmlAttribute attribute = xnType.Attributes[&quot;Name&quot;]; string parentname =attribute.Value; string strJson = CommonHelper.GetActByProcessName(parentname, paths); string res = &quot;&#123;\\&quot;ParentName\\&quot;:\\&quot;&quot;+parentname+&quot;\\&quot;,\\&quot;data\\&quot;:&quot;+strJson+&quot;&#125;&quot;; sb.Append(res); index++; &#125; sb.Append(&quot;]&quot;); return sb.ToString(); &#125; catch (Exception err) &#123; throw; &#125; &#125; public struct LeftLists &#123; public string ParentName &#123; get; set; &#125; //属性的名字，必须与json格式字符串中的&quot;key&quot;值一样。 public List&lt;dataList&gt; data &#123; get; set; &#125;//数组处理 &#125; public struct dataList &#123; public int ID &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Type &#123; get; set; &#125; public string Url &#123; get; set; &#125; &#125;; &#125;&#125; 3 今天遇见的主要问题在之前我主要是用的时候序列化，但是为了在后台方便操作json数据节点，所以我使用了反序列化，在使用的最开始，一直不得其法还去.net with json下载了相关dll文件。 12345678910using Newtonsoft.Json;using Newtonsoft.Json.Linq;public string cutJson(string json,string item,int index)&#123; JObject jo = (JObject)JsonConvert.DeserializeObject(json); string value = jo[item][index].ToString(); return value;&#125;JArray LeftLists = (JArray)JsonConvert.DeserializeObject(LeftList); 3.1 第一种123456789101112131415JArray array = new JArray();array.Add(\"Manual text\");array.Add(new DateTime(2000, 5, 23));JObject o = new JObject();o[\"MyArray\"] = array;string json = o.ToString();// &#123;// \"MyArray\": [// \"Manual text\",// \"2000-05-23T00:00:00\"// ]// &#125;LINQ to JSON 3.2 第二种1234567891011121314string json = @\"&#123; 'Name': 'Bad Boys', 'ReleaseDate': '1995-4-7T00:00:00', 'Genres': [ 'Action', 'Comedy' ]&#125;\";Movie m = JsonConvert.DeserializeObject&lt;Movie&gt;(json);string name = m.Name;// Bad BoysDeserialize JSON 3.3 第三种1234567891011121314Product product = new Product();product.Name = \"Apple\";product.Expiry = new DateTime(2008, 12, 28);product.Sizes = new string[] &#123; \"Small\" &#125;;string json = JsonConvert.SerializeObject(product);// &#123;// \"Name\": \"Apple\",// \"Expiry\": \"2008-12-28T00:00:00\",// \"Sizes\": [// \"Small\"// ]// &#125;Serialize JSON 4 结论结果使用了结果发现不用另外下载dll，直接使用System.Web.Script.Serialization就好，还有就是在构造对应的public struct上，我也花费了很多时间，之前不知道怎么用，需要注意的是在json数组对象中多层嵌套数组，在反序列对应的struct上怎样多层对应定义，然后在反序列化之后怎么对应，那一部分是用对象的方法LeftLs[n].ParentName进行取值，哪一块是通过数组下标的方式LeftLs[n].data[m].Name进行取值，还有反序列化之后的list应该怎样正确声明 1234//正确List&lt;LeftLists&gt; LeftLs = new JavaScriptSerializer().Deserialize&lt;List&lt;LeftLists&gt;&gt;(LeftList);//错误LeftLists LeftLists = new JavaScriptSerializer().Deserialize&lt;LeftLists&gt;(LeftList); 花费了大量时间，后期逐步了解了，才发现其实很好用，希望我之后能够将现有项目中json转化解析的部分功能进行进一步的优化。不过后期如果有时间有应该把.net with json好好学习一下，还有之前以为return的json可以通过length控制，后期才发现使用了很多firstchild比较麻烦，还是序列化方便一些，直接通过下表或者取对象值的方式就可以了。","tags":[{"name":"json序列化","slug":"json序列化","permalink":"https://mowatermelon.github.io/tags/json序列化/"},{"name":"前端知识","slug":"前端知识","permalink":"https://mowatermelon.github.io/tags/前端知识/"},{"name":"javascript","slug":"javascript","permalink":"https://mowatermelon.github.io/tags/javascript/"},{"name":"c#","slug":"c","permalink":"https://mowatermelon.github.io/tags/c/"},{"name":"xml","slug":"xml","permalink":"https://mowatermelon.github.io/tags/xml/"}]},{"title":"前端知识之学习之页面缓存","date":"2017-04-13T16:00:00.000Z","path":"2017/04/14/the-front-end-knowledge-page-caching/","text":"前提概要，基于现在有你有我网站的页面缓存效果的分析 目前的有你有我界面主要后台逻辑支持是通过java进行支持的，由于文章数据还有图片数据较多，导致页面加载的时候比较缓慢，在这个快餐时代，很多时候用户连一秒的等待都不愿意，何况现有的项目是在首页加载的时候，或者选择跳转到其他界面的时候大部分都是十秒左右，这样的用户体验是极其不好的。所以做了一定优化。 1 初次访问 初次访问的用户，所看的的界面是服务器从查询各种相关表，动态生成的页面显示效果，服务器会记录用户搜索相关关键词，所拼接的界面，一个纯静态资源其实占用的地方很少，但是这样会极大提高后期页面加载的速度。 2 再次访问访问服务器后台是否有相关已经生成过的界面，如果有则直接读取记录自动渲染在页面上，如果没有网站也可以通过相关搜索关键词，重新进行页面拼接，通用服务器后台也会记录相关操作界面，便于后期进行检索和渲染。 3 设置服务器请求刷新有效期 页面是会有很多动态操作，但是后台存的的静态网页不是不会自动更新相关数据和效果的，所以，需要设置服务器自动刷新缓存的有效期，这个目前默认的时间是一个小时。 4 目前效果预览 原来在访问网站的时候，选择相关界面的时候，需要等待的时间至少是十秒左右，现在访问首页是四秒左右，访问其他子页面也是一秒左右，极大的提高页面的访问速度。","tags":[{"name":"前端知识","slug":"前端知识","permalink":"https://mowatermelon.github.io/tags/前端知识/"},{"name":"页面缓存","slug":"页面缓存","permalink":"https://mowatermelon.github.io/tags/页面缓存/"}]},{"title":"前端知识之学习之项目管理","date":"2017-04-12T16:00:00.000Z","path":"2017/04/13/the-front-end-knowledge-project-managment/","text":"CMMI、ISO9000和ISO 20000有什么区别和联系？ 1 IS09000与CMMI均可作为软件企业的过程改善框架。CMMI仅仅适用于软件行业，而IS09000的适应更广泛，但绝不是说IS09000不适合软件企业。实际上ISO9001和CMMI遵循共同的管理思想，它已经彻底解决了94版的制造业痕迹较重、标准按要素描述、难于在软件行业实施的问题。从软件企业实施IS09000失败的原因来看，主要是未考虑软件行业特点和企业特点，盲目照搬其它行业和企业的模式，领导的重视程度和推行力度不够。这些问题不解决，实施CMM同样会失败。 就内容来讲，IS09001不覆盖CMMI，也不完全覆盖IS09000。一般而言，通过ISO9001认证的企业可达到CMMI 2级或略高的程度，通过CMMI 3级的企业只要稍做补充，就可较容易地通过ISO9001认证。粗略地说，ISO9001近似于CMMI 2.5级。 2 IS09001与CMMI均可作为软件企业的过程改进框架，其不同之处是，一个是泛用，一个是专用。ISO9001标准面向合同环境，站在用户立场，要求对质量要素进行控制，规定了质量体系的最低标准。而CMMI标准则强调软件开发过程的成熟度，即内部过程的不断改进和提高。在形式上，ISO9001审核只有通过和不通过两个结论，而CMMI评定则是一个动态过程，软件组织在通过低级别评估后，可根据高级别的要求确定改进方略。 3 CMMI全称是Capability Maturity Model Integration, 即软件能力成熟度模型集成，是由美国国防部与卡内基-梅隆大学和美国国防工业协会共同开发和研制的，其目的是帮助软件企业对软件工程过程进行管理和改进，增强开发与改进能力，从而能按时地、不超预算地开发出高质量的软件。 4 而ISO9001质量管理体系是对组织（包括政府、企业、事业单位都可）的产品（包括服务）进行质量管理控制的标准体系。这是一个基础的管理平台，从企业的设备管理、文件管理、人员管理到研发、生产和交付产品以及售后服务都进行管理控制的一个标准。所以两者区别还是比较大。前者CMMI是针对软件公司能力的评估，后者ISO9001是对所有企业都可以进行评定的管理体系认证。 5 ISO 20000是面向机构的IT服务管理标准，目的是提供建立、实施、运作、监控、评审、维护和改进IT服务管理体系(ITSM)的模型。建立IT服务管理体系(ITSM)已成为各种组织，特别是金融机构、电信、高科技产业等管理运营风险不可缺少的重要机制。ISO 20000让IT管理者有一个参考框架用来管理IT服务，完善的IT管理水平也能通过认证的方式表现出来。 6 ISO20000标准着重于通过“IT服务标准化”来管理IT问题，即将IT问题归类，识别问题的内在联系，然后依据服务水准协议进行计划、推行和监控，并强调与客户的沟通。该标准同时关注体系的能力，体系变更时所要求的管理水平、财务预算、软件控制和分配。","tags":[{"name":"前端知识","slug":"前端知识","permalink":"https://mowatermelon.github.io/tags/前端知识/"},{"name":"项目管理","slug":"项目管理","permalink":"https://mowatermelon.github.io/tags/项目管理/"}]},{"title":"前端知识之学习之Mvvm和mvc","date":"2017-04-11T16:00:00.000Z","path":"2017/04/12/the-front-end-knowledge-mvvm-mvc/","text":"现在都讲究前端工程化，说的最多的是mvvm，但是之前一直不理解，今天系统的学习一些 1 观点学习来源woodk在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。 MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。 有人做过测试：使用Angular（MVVM）代替Backbone（MVC）来开发，代码可以减少一半 此外，MVVM另一个重要特性，双向绑定。它更方便你同时维护页面上都依赖于某个字段的N个区域，而不用手动更新它们。 2 观点学习来源indream2.1 Model-View-Controller在ASP还在奋斗的时候WebForm突然到来，正如WebForm还在奋斗的时候MVC突然到来。当然，我这里讲的MVC还是最原始的MVC，因为MVC在我们还在争论的时候已经发展了许多不同分支了。 有一点相信大家同意的就是，我们今天讨论争论的MVC、MVP、MVVM、Code Behind等等都源自于职能分化和规划的思想与目的，MVC不是它们的开始，但是一个很好的开始。 相信MVC的模型大家很熟悉，也很容易找到，我们可以看到的是，界面被分到了View，数据分到了载体Model上由Model携带，业务集中在Controller中，而推动业务的事件由用户与View交互，通过View向Controller发动。 当然，实现由很多种，每种细节上都有不同，所以我才只讲也只能讲大致的MVC。MVC的其中一个缺点便是没有明确的定义，所以不同的实现（比如Struts和ASP.NET MVC）细节上都是不一样的。 我们需要知道的是，MVC并不是像上面所说的一些事情那样是一种必然的结果，它是一系列必然结果问题中的一种解决方案，而且是不完美的解决方案。我们顺着推理去到一个地方很容易犯的一个错误就是认为路只有这一条而忽视其他可能性（估计这也是导致很多争斗的原因）。另外，我们在讨论一件事物不完美的时候是有一个情境的，所以请不要像我说它色彩单一，然后你把它涂成彩色后证明我是错的。 MVC的一般流程是这样的：View（界面）触发事件–》Controller（业务）处理了业务，然后触发了数据更新–》不知道谁更新了Model的数据–》Model（带着数据）回到了View–》View更新数据 2.2 Model-View-Presenter和一些衍生像我们之前推理的，分化是一种需求的必然结果，但却没有个一个确定的结果，比如Code Behind和Code Block的问题等等。 MVC顺着需求把UI相关的工作分化成了三份，这点经过实践证明无可厚非。但是它们的三角关系却被一些人认为带来了一些问题，或者应该说他们有更好的解决方案。 在只有Code Behind和Code Block的那个时候维护是很直接的，不是在同一段代码内解决就是在同一个关联的事件上解决。三角关系的问题就是维护问题。在MVC，当你有变化的时候你需要同时维护三个对象和三个交互，这显然让事情复杂化了。 我们之前说到，随着摩尔定律，软件的需求不断地变化和变得庞大。随着需求变得庞大的时候，需求变化也变得频繁，这是一个出现了无数次以后也将会出现无数的无数次的一个问题，所以它需要一个解决方案，哪怕它不一定能被解决。 为了解决需求变化，从《人月神话》到敏捷到DDD，它不是我们已经解决了的问题，而是我们正在解决的问题。放在UI的模式和MVC上来讲，就是优化或者替代MVC模式，其中之一就是Model-View-Presenter（MVP）模式。 我们先看看两个MVP模式的图： 两幅图是不同的，但是对MVC的改进的思想却是一样的：切断的View和Model的联系，让View只和Presenter（原Controller）交互，减少在需求变化中需要维护的对象的数量。 这种方式很符合我们的期待，因为我们倾向于： 用更低的成本解决问题 用更容易理解的方式解决问题 许多时候并不是一种模式不好，而是因为人没办法执行，比如不容易理解，我们就会选择容易理解的方式。计算机依赖摩尔定律用数量的增长来解决问题，而人是用方式的改变来解决问题的。同样因为客观原因我们不善于维护多个对象和多个对象之间的关系，所以我们改变了，或者说简化了这种方式。 MVP定义了Presenter和View之间的接口，让一些可以根据已有的接口协议去各自分别独立开发，以此去解决界面需求变化频繁的问题。上面两图都有接口，不过接口的实现和使用细节不一样，不过思想上是一致的。 在这里要提到的是，事实上，需求变化最频繁的并不一定是最接近用户的界面，但基本可以确定的是，最接近用户的界面是因为需求变化而需要最频繁更改的。当然，如果View如果是API而不是UI，那就另说了。 还有一些用来解决MVC这项缺点的比如有：ASP.NET MVC的ViewBag，Cocoa的delegate。它们都为了简化数据更新的问题而存在，包括MVVM。 2.3 MVVM 从图上看是比MVP简单了，更不用说MVC了。个人不认为MVVM是从MVP进化而来，我只觉得这是在MVP之后出现的一种更好的UI模式解决方案，但是用MVP来与之对比比较容易说明问题。 ViewModel大致上就是MVP的Presenter和MVC的Controller了，而View和ViewModel间没有了MVP的界面接口，而是直接交互，用数据绑定的形式让数据更新的事件不需要开发人员手动去编写特殊用例，而是自动地双向同步。数据绑定你可以认为是Observer模式或者是Publish/Subscribe模式，原理都是为了用一种统一的集中的方式实现频繁需要被实现的数据更新问题。 比起MVP，MVVM不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。 至此，我们能理解为什么许多人认为MVVM是最好的一种模式，没有之一。但事实上，MVVM也是依赖于我们至今所讲的特有的情境。 当然，最优雅的也是第一个能作代表的实践就是Windows Presentation Foundation（WPF）了。 个人总结我看了这些相关blog对于mvvm的评价大致都是比较中肯，在一定程度上能够提高开发效率，之前我比较熟悉的mvc模式中，m和v的关系过于紧密，导致如果想将现有版本移植到不同平台，会产生类似需要重构的结果，但是在mvvm中，m和v是没有什么关系的，vm可以自动同步的更新m和v，不需要重复写相关代码，手动去更新，这样可以提高代码的复用率，这样也提高了办事效率。","tags":[{"name":"前端知识","slug":"前端知识","permalink":"https://mowatermelon.github.io/tags/前端知识/"},{"name":"mvvm","slug":"mvvm","permalink":"https://mowatermelon.github.io/tags/mvvm/"},{"name":"mvc","slug":"mvc","permalink":"https://mowatermelon.github.io/tags/mvc/"}]},{"title":"Js学习之学习之attr和prop","date":"2017-04-10T16:00:00.000Z","path":"2017/04/11/js-Learning-jquery-attr-prop/","text":"背景提示，项目中需要动态绑定checkbox的选中状态，同事通过attr方法进行赋值的时候，效果一直不是他需要的，我查了一下资料，同事在使用了prop之后才得到了想要的效果，所以今天就总结一下这两者的区别，参考文档 1 介绍attrattr是单词attribute的缩写，表示属性的意思。在jQuery中attribute表示HTML文档节点的属性。attr()函数的设计目标是用于设置或获取指定DOM元素所对应的文档节点上的属性(attribute)。 12&lt;!-- 这里的id、class、data_id均是该元素文档节点的attribute --&gt;&lt;div id=\"message\" class=\"test\" data_id=\"123\"&gt;&lt;/div&gt; 2 介绍propprop是单词property的缩写，表示属性的意思。在jQuery中，property表示JS对象的属性。prop()函数的设计目标是用于设置或获取指定DOM元素(指的是JS对象，Element类型)上的属性(property)； 12// 这里的name、age、url均是obj的propertyvar obj = &#123; name: \"CodePlayer\", age: 18, url: \"http://www.365mini.com/\" &#125;; 3 介绍两者区别在jQuery的底层实现中，函数attr()和prop()的功能都是通过JS原生的Element对象(如上述代码中的msg)实现的。attr()函数主要依赖的是Element对象的getAttribute()和setAttribute()两个方法。prop()函数主要依赖的则是JS中原生的对象属性获取和设置方式。 12345678910111213141516171819202122&lt;div id=\"message\" class=\"test\" data_id=\"123\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var msg = document.getElementById(\"message\");var $msg = $(msg);/* *** `attr()`依赖的是Element对象的element.getAttribute( attribute ) 和 element.setAttribute( attribute, value ) *** */// 相当于 msg.setAttribute(\"data_id\", 145);$msg.attr(\"data_id\", 145);// 相当于 msg.getAttribute(\"data_id\");var dataId = $msg.attr(\"data_id\"); // 145/* *** `prop()`依赖的是JS原生的 element[property] 和 element[property] = value; *** */// 相当于 msg[\"pid\"] = \"pid值\";$msg.prop(\"pid\", \"pid值\");// 相当于 msg[\"pid\"];var testProp = $msg.prop(\"pid\"); // pid值&lt;/script&gt; 虽然prop()针对的是DOM元素的property，而不是元素节点的attribute。不过DOM元素某些属性的更改也会影响到元素节点上对应的属性。例如，property的id对应attribute的id，property的className对应attribute的class。 12345678910&lt;div id=\"message\" class=\"test\" data_id=\"123\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var msg = document.getElementById(\"message\");var $msg = $(msg);document.writeln( $msg.attr(\"class\") ); // test$msg.prop(\"className\", \"newTest\");// 修改className(property)导致class(attitude)也随之更改document.writeln( $msg.attr(\"class\") ); // newTest&lt;/script&gt; 3.1 应用版本不同attr()是jQuery 1.0版本就有的函数，prop()是jQuery 1.6版本新增的函数。毫无疑问，在1.6之前，你只能使用attr()函数；1.6及以后版本，你可以根据实际需要选择对应的函数。 3.2 用于设置的属性值类型不同由于attr()函数操作的是文档节点的属性，因此设置的属性值只能是字符串类型，如果不是字符串类型，也会调用其toString()方法，将其转为字符串类型。prop()函数操作的是JS对象的属性，因此设置的属性值可以为包括数组和对象在内的任意类型。 3.3 其他细节问题在jQuery 1.6之前，只有attr()函数可用，该函数不仅承担了attribute的设置和获取工作，还同时承担了property的设置和获取工作。例如：在jQuery 1.6之前，attr()也可以设置或获取tagName、className、nodeName、nodeType等DOM元素的property。 直到jQuery 1.6新增prop()函数，并用来承担property的设置或获取工作之后，attr()才只用来负责attribute的设置和获取工作。 此外，对于表单元素的checked、selected、disabled等属性，在jQuery 1.6之前，attr()获取这些属性的返回值为Boolean类型：如果被选中(或禁用)就返回true，否则返回false。但是从1.6开始，使用attr()获取这些属性的返回值为String类型，如果被选中(或禁用)就返回checked、selected、disabled，否则(即元素节点没有该属性)返回undefined。并且，在某些版本中，这些属性值表示文档加载时的初始状态值，即使之后更改了这些元素的选中(或禁用)状态，对应的属性值也不会发生改变。 因为jQuery认为：attribute的checked、selected、disabled就是表示该属性初始状态的值，property的checked、selected、disabled才表示该属性实时状态的值(值为true或false)。因此，在jQuery 1.6及以后版本中，请使用prop()函数来设置或获取checked、selected、disabled等属性。对于其它能够用prop()实现的操作，也尽量使用prop()函数。","tags":[{"name":"js学习","slug":"js学习","permalink":"https://mowatermelon.github.io/tags/js学习/"},{"name":"attr","slug":"attr","permalink":"https://mowatermelon.github.io/tags/attr/"},{"name":"prop","slug":"prop","permalink":"https://mowatermelon.github.io/tags/prop/"},{"name":"jquery","slug":"jquery","permalink":"https://mowatermelon.github.io/tags/jquery/"}]},{"title":"前端思考之字体图标与Ps","date":"2017-04-09T16:00:00.000Z","path":"2017/04/10/thinking-in-the-front-end-knowledge-fonts-icon-ps/","text":"前情概要，最近比较懒，上次听有人直接画对应的svg给界面上用，当前项目中有一个雪碧图，最近又要适应各种尺寸，所以我这边想尝试可以直接换成svg，然后做字体图标让界面上使用。 1 各种尝试和犯傻今天下午尝试在ps中制作svg图标，然后上传到icomoon中制作相关子图文件，首先发现这边在ps中没有导出为svg选项，我在保存文件格式那里看了很久，然后用了某度，下载了插件 save-ps-to-svg1.0，安放路径是ps安装路径下的Presets\\Scripts中，某度的那个攻略贴中是安装成功之后，可以在想要导出的图层上右键，就可以直接导出svg文件，当然也并没有成功啊，不知道是什么原因导致。 2 发现尝试方向错了我发现这边导出是支持导出为svg格式的，日常犯傻的我，之前竟然没有看到，这边我测试了一个图层，写了两个字，插播一句，这边如果选择文件\\生成\\图片资源，这边会根据你的图层命名自动生成相关文件的，我就上传到icomoon,界面上面倒是显示上传成功，可是，显示的图标是空的，我又尝试画了一个路径，这边上传上来之后，有正确显示图标，我以为是第一次是什么莫名的bug，又用现有图片切了一下，上传上去还是不行。 3 比较繁琐的成功逻辑用了某度，告诉我需要将图层转成矢量图再存成svg才行，我这边突然发现不知道怎么将图层转化为矢量形状，这边将现有图层进行选中之后，转化为路径这个我知道，但是之后怎么转成自定义形状，我忘记了，用了某度进行搜索，这边ps工具箱的自定义形状的上一个，是一个箭头形状，这边是路径选择器，选择相关路径之后，在画布该图层上面右键，就有了定义自定形状，需要输入对应名称，存储之后，就可以在自定义形状中找到，在使用这个自定义形状的图层导出为svg，上传到icomoon上，就可以正常显示了下载对应的字体文件，就可以使用这些字体图标了。 总结 利用快速选择图层—–&gt;然后将该选区，转化为路径—–&gt;用路径选择器选择路径—–&gt;存储为自定义形状—–&gt;用自定义形状画出的图层导出为svg之后—–&gt;上传就成了。 4 后续发现这边我发现只要设置文件\\导出\\导出首选项,设置默认的导出文件格式是svg，这边在图层上右键就会有快速导出为svg了,日常觉得我查了那么多插件真的是犯傻，毕竟都是ps2016，怎么可能没有导出为svg功能，今天虽然生成字体文件成功了，但是这边操作步骤还是很繁琐，希望之后，有插件，可以直接将非形状图层导出为svg，并且上传到icomoon中可以正常显示，那就好了。","tags":[{"name":"前端思考","slug":"前端思考","permalink":"https://mowatermelon.github.io/tags/前端思考/"},{"name":"字体图标","slug":"字体图标","permalink":"https://mowatermelon.github.io/tags/字体图标/"}]},{"title":"前端思考之字体图标与图片","date":"2017-04-08T16:00:00.000Z","path":"2017/04/09/thinking-in-the-front-end-knowledge-fonts-icon-img/","text":"前情概要 我自从用了雪碧图之后，一般我写的界面上不会有img标签，当然不排除如果引用外部插件，安装插件demo的形式，我会去直接在页面上用到img标签。 1 对于img标签的认识我对img标签的印象不好，是因为我觉得设置背景图片的位置颜色，还有其他的自适应容器大小之类的，都比较方便，但是在做img的自适应容器大小居中，特别是容器垂直居中的情况，真的很烦人，而且很容易和盒子中的文字样式起冲突，感觉很麻烦，特别是做了很多页面的盒子垂直居中的兼容时候，感觉真的是，特别当时还不知道怎么写媒体查询，真的是写的头都要炸，（日常捂脸自己的小白）。 2 对于字体图标的认识我对于字体图标其实是今年才学会怎么使用，之后就一发不可收拾的爱上这个玩意，毕竟用背景图片会有各种缩放问题，但是这个字体图标是矢量的svg不存在这问题，而且基于字体图标我可以做很多的效果，而且还可以兼容很多低版本的浏览器，而且都是封装好的，今天还看了bootstrap的扩展字体图标，感觉种类很多啊，还是很好用的，不过我眼睛都看花了，也没有找到我想要的字体图标，也是有的心累，还是老老实实的用bgposition，切的图，感觉还是有些麻烦，话说我明天再去看一下有没有合适的字体图标。 3 总结我现在写的节目一般用到的都是字体图标，但是项目中其他人写界面的时候，用的全是图片，还有很多样式都是直接在标签中写的，这个样子很不符合mvc的定义，显示层，和行为层都在一起，更不说很多时候都是在页面上写的js，显示层，行为层还有控制层，三者都在一块，感觉界面上各种东西都揉杂在一块，有的时候看了之后觉得页面上内容太多，改都没有办法改，如果自己要去改，费心费力如果效果有一点问题，还会让人觉得不舒服，还觉得你这个是背着石头上山，可是作为自己参与开发的一个系统，自己就这样，真的随意好吗，有些茫然。","tags":[{"name":"前端思考","slug":"前端思考","permalink":"https://mowatermelon.github.io/tags/前端思考/"},{"name":"字体图标","slug":"字体图标","permalink":"https://mowatermelon.github.io/tags/字体图标/"}]},{"title":"前端思考之必备技术栈","date":"2017-04-07T16:00:00.000Z","path":"2017/04/08/thinking-in-the-front-end-knowledge-necessary-technology-stack/","text":"前天我看了一篇关于前端必备技术栈，有很多我都不太了解，所以今天整理一下 1 HTML1.1 网页常见尺寸 一般网站宽为996px；国内网站大部分还是以1000个像素为界限，因超过1000像素适合在大屏幕上浏览，小屏幕会显得拥挤。国内尺寸设置比较保守，这样可以保证大部分用户舒适的浏览网页。 1.2 主流浏览器12345chromeIEfirefoxsafariopera 知道了浏览器的设计特点才能更好的设计页面，比如浏览器的头部的操作高度和信息的展示都会有所不同，那么页面在每个浏览器上面的展现就会有所不同。 1.3 语义化标签HTML5的革新之一：语义化标签一节元素标签(header,footer)、文本元素标签(article,aside,setion)、分组元素标签(menu,hgroup,nav)。 在HTML5出来之前，我们用div来表示页面章节，但是这些div都没有实际意义。（即使我们用css样式的id和class形容这块内容的意义）。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分。但现在，那些之前没意义的标签因为因为html5的出现消失了，这就是我们平时说的语义。 但是也不要因为html5新标签的出现，而随意用之，错误的使用肯定会事与愿违。所以有些地方还是要用div的，就是因为div没有任何意义的元素，他只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。 W3C定义了这些语义标签，不可能完全符合我们有时的设计目标，就像制定出来的法律不可能流传100年都不改变，更何况它才制定没多久，不可能这些语义标签对所以设计目标的适应。只是一定程度上的通用，我们的目标是让爬虫读懂重要的东西就够了。 结论：不能因为有了HTML5标签就弃用了div，每个事物都有它的独有作用的。 1.4 SPA1.4.1 WHAT单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。 1.4.2 WHY 速度：更好的用户体验，让用户在web app感受native app的速度和流畅， MVC：经典MVC开发模式，前后端各负其责。 ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。 路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。 单页Web应用（single page web application，SPA）是当今网站开发技术的弄潮儿，很多传统网站都在或者已经转型为单页Web应用，新的单页Web应用网站（包括移动平台上的）也如雨后春笋般涌现在人们的面前，如Gmail、Evernote、Trello等。 单页Web应用和前端工程师们息息相关，因为主要的变革发生在浏览器端，用到的技术其实还是HTML+CSS+JavaScript，所有的浏览器都原生支持，当然有的浏览器因为具备一些高级特性，从而使得单页Web应用的用户体验更上一层楼。 单页Web应用，顾名思义，就是只有一张Web页面的应用。浏览器一开始会加载必需的HTML、CSS和JavaScript，之后所有的操作都在这张页面上完成，这一切都由JavaScript来控制。因此，单页Web应用会包含大量的JavaScript代码，复杂度可想而知，模块化开发和设计的重要性不言而喻。 1.4.3 HOW 用循环的视角审视Web应用开发 框定一个一致的SPA图形用户界面（GUI）和模型 将SPA的原则带回服务器端 聚集于对合适的应用进行早期SPA开发 SPA协调的起点是认识到SPA与脚本和网页编程有关，而不是与后端应用有关。 SPA的主要目标是围绕着Web 2.0,页面时间交互原则重构Web应用，以便体验可容易地转化到多个设备中，并对用户有效。这意味着首先要抱着支持这样一个逻辑活动为目标来设计用户交互，该活动应该涉及单页面与一套脚本，实现一次加载并执行直到活动完成。 一旦用户交互设计完成，下一步就是框定一个本地状态或事件模型，该模型应能描述页面处理与用户的交互及与任何后端应用交互。尽管这并非不可能，但是开发与服务器端功能多组件交互的SPA会更加困难。 这会产生一种要对应用服务器进行重构的诱因，其目的是为了以1:1的比例来支持SPA。就最大程度上而言，该模型应该让自己的变量及命名空间本地化，并通过应用的服务器端与其他SPA交互。这是为了减少对于用本地SPA控制器或模型来在多个SPA之间保留状态的需求。 2 CSS2.1 模块化2.1.1 WHAT在某度的解释是，在系统的结构中，模块是可组合、分解和更换的单元。模块化是一种处理复杂系统分解成为更好的可管理模块的方式。它可以通过在不同组件设定不同的功能，把一个问题分解成多个小的独立、互相作用的组件，来处理复杂、大型的软件。 模块化，有点像拼图的即视感，可以把大图分成各个小图，然后把小图拼成大图，分与合的艺术感。那么css模块化思想，也就是在css编写环境中，用上模块化的思想，把一个大的项目，分解成独立的组件，不同的组件负责不同的功能，最后把模块组装，就成了我们要完成的项目了。 2.1.2 WHY当做一个大项目，几个人团队合作开发，结果看不懂彼此的代码，怎么办，当面对前人已经写好代码，需要修改，可是无处下手，怎么办.当代码耦合，修改费时费力，怎么办，当需要迭代，面对庞大的代码，牵一发动全身的悲催时刻，怎么办，这个时候，模块化思想就是救星了。css写法特别的灵活，也因为灵活，所以容易耦合在一起，这时候就需要进行模块化的分离。那么css模块化的好处多多，列举了一些如下： 提高代码重用率 提高开发效率、减少沟通成本 提高页面容错 降低耦合 降低发布风险 减少Bug定位时间和Fix成本 更好的实现快速迭代 便于代码维护 包括但不限于以上好处 2.1.3 HOW2.1.3.1 css样式文件名：1234567/*1）*/ master.css/*主要的样式*/ layout.css/*布局，版面的样式*/ columns.css/*专栏的样式*/ font.css/*文字的样式*/ print.css/*打印样式的样式*/ themes.css/*主题的样式*/ 1234567/*2）*/reset.css /*对浏览器的默认样式进行重设*/layout.css /*管理页面的布局*/typeset.css /*图文的编排*/color.css /*统一管理颜色的搭配*/print.css /*打印效果样式*/ie.css /*iehacker样式*/ 1234567/*3）*/reset.css/*对浏览器的默认样式进行重设*/header.css /*头部的所有样式*/container.css /* 除头部/底部外的中间区域样式*/footer.css /*底部样式*/print.css /*打印样式*/ie.css /*iehacker样式*/ 123456789/*4）*/reset.css /*页面样式充值*/header.css /*全站头部样式*/footer.css /*全站尾部样式*/public.css /*全站公共模块样式*/index.css /*首页特有样式*/container.css /*二级及以下主体样式*/print.css /*打印样式*/ie.css /*IE hack*/ 还是那句话，没有最好的命名方式，只有最合适的命名方式。主要就是从html结构和bug的快速定位和便于其他成员的修改上去考虑。 假如你的网站是新闻类的门户网站，然后html的结构就主要是布局，版面 layout.css，专栏 columns.css ，文字 font.css ，打印样式 print.css 就比较适合，因为跟html很一致，也很契合。 假如是企业官网的话，一般html结构都是头和尾都有标准的，所以与html结构最契合的就是第三种了，同时我们可以优化第三种，在container里面再分类，分成common,layout，就方便进一步的修改，至于common里就可以放入font,color一些公用的样式。 没有完美的生活，也没有完美的人，所以也没有完美的文件命名，只有尽量做到与html布局契合，然后重在从每次的项目中反省，总结，条条大路通罗马，能抓住老鼠的就是好猫。 2.1.3.2 css选择器相关规范css选择器的命名，是个老生常谈的问题，对它的规范，不仅是模块化实现的一环，便于团队开发，同时也规避了一些兼容性的麻烦。因为各个浏览器，IE，火狐，谷歌，safari，每个浏览器,都会因为命名不规范会产生不同样式。 所有的CSS语法是不区分大小写的ASCII范围（即，i.e., [a-z] and [A-Z]是等价的）中，除了部分不属于CSS的控制之下。例如，在HTML中值的区分大小写属性ID的字体名称和class，和URI就在于本规范的范围之内。请特别注意，元素名称是不区分大小写的HTML，但区分大小写的XML。 在CSS中，标识符（包括元素名称，类别，并在选择的ID）只能包含字符[A-ZA-Z0-9]和ISO 10646字符U + 00A0高，加上连字符（ - ）和下划线（ _）; 他们不能以数字开头，两个连字符，或一个连字符后跟数字。标识符也可以包含转义字符和任何ISO 10646字符作为一个数字代码（见下项）。 具体请查看参考网页,例如，识别符B&amp;W?可被写为B \\＆W \\？或B \\ 26W¯¯\\ 3F。请参考W3C CSS2.1的4.1.3节,链接地址：http://www.w3.org/TR/CSS21/syndata.html#characters 选择器的命名在各浏览器下的支持情况有所不同。因此，如果选择器的命名不规范，将影响各浏览器下的渲染效果。为了兼容以上的浏览器，省麻烦，我们尽量命名以字母开头。可以保证都兼容。 2.1.3.3 常用的css命名规则(一) 注释的写法:123/* Header */内容区/* End Header */ (二) id的命名:(1)页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center (2)导航 导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary (3)功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop（如购物车） 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guide 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright (三) class的命名(1)颜色:使用颜色的名称或者16进制代码,如12345.red &#123; color: red; &#125;.f60 &#123; color: #f60; &#125;.ff8600 &#123; color: #ff8600; &#125; (2)字体大小,直接使用”font+字体大小”作为名称,如123.font10px &#123; font-size: 10px; &#125;.font6pt &#123;font-size: 6pt; &#125; (3)对齐样式,使用对齐目标的英文名称,如123.left &#123; float:left; &#125;.bottom &#123; float:bottom; &#125; (4)标题栏样式,使用”类别+功能”的方式命名,如123.barNews &#123; &#125;.barProduct &#123; &#125; (四) 注意事项 尽量用英文; 不加中杠和下划线; 尽量不缩写； class 名称应当尽可能短，并且意义明确。 使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。 基于最近的父 class 或基本（base） class 作为新 class 的前缀。 使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。 (五) 选择器 对于通用元素使用 class ，这样利于渲染性能的优化。 对于经常出现的组件，避免使用属性选择器（例如，[class^=”…”]）。浏览器的性能会受到这些因素的影响。 选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。 只有在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的 class 时 – 前缀类似于命名空间）。 2.2 弹性布局2.2.1 Flexbox2.2.1.1 WHAT2009年，W3C提出了一种崭新的方案-Flex布局（即弹性伸缩布局），它可以简便、完整、响应式地实现各种页面布局，包括一直让人很头疼的垂直水平居中也变得很简单地就迎刃而解了。但是这个布局方式还处于W3C的草案阶段，并且它还分为旧版本、新版本以及混合过渡版本三种不同的编码方式。其中混合过渡版本主要是针对IE10做了兼容。目前flex布局用得比较多的还是在移动端的布局。 2.2.1.1 HOW下面将通过一个简单的实例来讲解旧版本的各个属性：12345&lt;div&gt; &lt;p&gt;helloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOnehelloOne&lt;/p&gt; &lt;p&gt;helloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwohelloTwo&lt;/p&gt; &lt;p&gt;helloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThreehelloThree&lt;/p&gt;&lt;/div&gt; 可以看到我们这个例子是很简单的，一个div元素内包含三个p元素，它们都是块元素（block）。接下来给段落加一些基础的样式，然后p标签会在页面上垂直成三行进行展示1234567p&#123; width:150px; border:3px solid lightblue; background:lightgreen; padding:5px; margin:5px;&#125; 给div添加以样式1234div&#123; display:-webkit-box; display:box;&#125; 现在每一个p元素都变成一个box了，这就是弹性布局的神奇所在！ 在上面中，我们将div元素的display设置为box，这就是旧版本的弹性布局。对于比较旧的浏览器版本，我们需要加上-webkit-前缀。 旧版本的弹性布局有两个属性值： box : 将容器盒模型作为块级弹性伸缩盒显示inline-box : 将容器盒模型作为内联级弹性伸缩盒显示 PS：我们知道块级它是占用整行的，比如div元素；而内联级不占用整行，比如span元素。但是我们设置了整个盒子，他们都不占用，保持一致。就像我们上面的例子一样，给div元素设置了盒子，那么div元素里面的p元素就不占用了。 2.2.1.2 PROP (一) box-orient 属性box-orient属性主要实现盒子内部元素的流动方向。1234horizontal ： 伸缩项目从左到右水平排列vertical ： 伸缩项目从上到下垂直排列inline-axis ： 伸缩项目沿着内联轴排列显示block-axis ： 伸缩项目沿着块轴排列显示 大家不妨试一下：horizontal 和 inline-axis 都是水平排列，而vertical 和 block-axis 都是垂直排列。123456div&#123; display:-webkit-box; display:box; -webkit-box-orient:vertical; box-orient:vertical; &#125; (二) box-direction属性box-direction 属性主要是设置伸缩容器中的流动顺序。12normal : 正常顺序，默认值reverse : 反序 下例是反序显示的例子123456div&#123; display:-webkit-box; display:box; -webkit-box-direction:reverse; box-direction:reverse;&#125; (三) box-pack属性box-pack 属性用于伸缩项目的分布方式。1234start : 伸缩项目以起始点靠齐 end : 伸缩项目以结束点靠齐center : 伸缩项目以中心点靠齐justify : 伸缩项目平局分布 以下是让项目整体水平居中的例子1234div&#123; -webkit-box-pack:center; box-pack:center;&#125; (四) box-align属性box-align 属性用来处理伸缩容器的额外空间。12345start ： 伸缩项目以顶部为基准，清理下部额外空间end ： 伸缩项目以底部为基准，清理上部额外空间center ： 伸缩项目以中部为基准，平均清理上下部额外空间baseline ： 伸缩项目以基线为基准，清理额外的空间stretch ： 伸缩项目填充整个容器，默认值 12345678div&#123; display:-webkit-box; display:box; -webkit-box-orient:horizontal; box-orient:horizontal; -webkit-box-align:baseline; box-align:baseline;&#125; (五) box-flex 属性可以使用浮点数分配伸缩项目的比例。此属性是给容器内的项目设置的，它们会基于父容器的宽度来分配它们所占的比例 123456789101112p:nth-child(1)&#123; -webkit-box-flex:1; box-flex:1;&#125;p:nth-child(2)&#123; -webkit-box-flex:3; box-flex:3;&#125;p:nth-child(3)&#123; -webkit-box-flex:1; box-flex:1;&#125; 当然也可以有些项目是固定宽度的，那么其他的项目也会分配剩余的宽度，比如这里第一个p元素设置为固定宽度： 12345678p:nth-child(2)&#123; -webkit-box-flex:2; box-flex:2;&#125;p:nth-child(3)&#123; -webkit-box-flex:1; box-flex:1;&#125; (六) box-ordinal-group 属性box-ordinal-group 属性可以设置伸缩项目的显示位置。123456789101112p:nth-child(1)&#123; -webkit-box-ordinal-group:2; box-ordinal-group:2;&#125;p:nth-child(2)&#123; -webkit-box-ordinal-group:3; box-ordinal-group:3;&#125;p:nth-child(3)&#123; -webkit-box-ordinal-group:1; box-ordinal-group:1;&#125; 可以看到：第一个p元素排在了第二，第二个p元素排在了第三，第三个p元素排在了第一。可以单独给某一个p元素设置此属性，其他项目会按照原来的顺序做变动。12345678910div&#123; display:-webkit-box; display:box; height:500px; border:1px solid #f00; -webkit-box-pack:center; box-pack:center; -webkit-box-align:center; box-align:center;&#125; 2.2.2 Flex2.2.2.1 WHAT新版本的Flexbox模型是2012年9月提出的工作草案，这个草案是由W3C 推出的最新语法。这个版本立志于指定标准，让新式的浏览器全面兼容，在未来浏览器的更新换代中实现统一。 2.2.2.2 PROP (一) flex-direction属性flex-direction属性用于设置伸缩项目的排列方式。1234row ： 设置从左到右排列row-reverse ： 设置从右到左排列column ： 设置从上到下排列column-reverse ： 设置从下到上排列 1234div&#123; display:flex; flex-direction:column;&#125; 结果就是容器内的所有项目按照从上到下排列的,当你设置为row-reverse时，效果就是这个是从浏览器的右边往左边排列的。 (二) flex-wrap属性flex-wrap属性设置项目的换行方式（当容器宽度不足以容纳所有子项目时）。123nowrap ： 默认值，都在一行或者一列中显示wrap ： 伸缩项目无法容纳时，自动换行wrap-reverse ： 伸缩项目无法容纳时，自动换行，方向和wrap相反 1234div&#123; display:flex; flex-wrap:wrap;&#125; 可以看到，当把浏览器窗口缩小时，第三个p元素因为容纳不下而被挤下来了。 (三) flex-flow属性flex-flow 属性是 flex-direction 和 flex-wrap 属性的速记属性。 1234div&#123; display:flex; flex-flow:row wrap;&#125; 上面这个例子就相当于设置了flex-direction为row，flex-wrap为wrap。 (四) justify-content属性justify-content 在当灵活容器内的各项没有占用主轴上所有可用的空间时对齐容器内的各项（水平）。12345flex-start ： 伸缩项目以起始点靠齐flex-end ： 伸缩项目以结束点靠齐center ： 伸缩项目以中心点靠齐space-between ： 伸缩项目平均分布space-around ： 伸缩项目平均分布，但两端保留一半的空间 1234div&#123; display:flex; justify-content:space-around;&#125; 可以看到所有项目平均分布，而且两端也有保留一半的空间。 (五) align-items属性align-items 属性规定灵活容器内的各项的默认对齐方式，和旧版本中的box-align一样，处理伸缩项目容器的额外空间。 12345flex-start ： 伸缩项目以顶部为基准，清理下部的额外空间flex-end ： 伸缩项目以底部为基准，清理上部的额外空间center ： 伸缩项目以中部为基准，平均清理上下部的额外空间baseline ： 伸缩项目以基线为基准，清理额外的空间stretch ： 伸缩项目填充整个容器，默认值 1234div&#123; display:flex; align-items:center;&#125; 这些效果跟旧版本的box-align基本是一样的，具体怎么用，大家自己试一下就知道了。 (六) align-self属性align-self 和align-items 一样，都是清理额外空间，但它是单独设置某一个伸缩项目的。所有的值和align-itmes 一致。123p:nth-child(2)&#123; align-self:center;&#125; 其他属性值的效果同align-items，这里就不赘述。 (七) flex属性flex 属性和旧版本中的box-flex 类似，用来控制伸缩容器的比例分配。123456789p:nth-child(1) &#123;flex: 1;&#125;p:nth-child(2) &#123;flex: 3;&#125;p:nth-child(3) &#123;flex: 1;&#125; (八) order属性order 属性和旧版本的box-ordinal-group 属性一样控制伸缩项目出现的顺序。 123456789p:nth-child(1) &#123; order: 2;&#125;p:nth-child(2) &#123; order: 3;&#125;p:nth-child(3) &#123; order: 1;&#125; 2.2.3 GridCSS Grid现在已经被W3C纳入到CSS3的一个布局模块当中，被称为CSS Grid Layout Module。而我们较为熟悉的还是将其想像成网格或者栅格，也就是早期的960gs。 2.2.3.1 WHY在我们的Web内容中，可以将其分割成很多个内容块，而这些内容块都占据自己的区域(regions)，可以将这些区域想像成是一个虚拟的网格。 到目前为止，在一个模板中使用不同的结构标签，使用多个浮动和手动计算实现一个布局。这对于Web前端人员来说，这是一件痛苦之事。而网格布局将让你摆脱这样的困局，让你的布局方法变得非常简单与清晰。 网格布局给了我们一种方法——创建的结构与使用表格(table)布局并没有什么不同。然而，他是在CSS中实现而不是在HTML中实现，同时还可以依赖于媒体查询根据不同的上下文得新定义布局。 这对于喜欢响应式设计的同学来说是一个绝对利好的消息。因为你不在需要再担心你的HTML结构而影响你的布局。 网格布局还可以让我们摆脱现在布局中存在的文档流限制，换句话说，你的结构不需要根据设计稿从上往上布置了。这也意味着您可以自由地更改页面元素位置。 这最适合你在不同的断点位置实现你最需要的布局，而不再需要为响应你的设计而担心HTML结构的问题。 2.2.3.2 WHATCSS Grid Layout是CSS为布局新增的一个模块。网格布局特性主要是针对于Web应用程序的开发者。可以用这个模块实现许多不同的布局。网络布局可以将应用程序分割成不同的空间，或者定义他们的大小、位置以及层级。 就像表格一样，网格布局可以让Web设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。 此外，没有内容结构的网格布局有助于使用流体、调整顺序等技术管理或更改布局。通过结合CSS的媒体查询属性，可以控制网格布局容器和他们的子元素，使用页面的布局根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容。 Grid vs Flexbox 在www-list邮件中常常会看到一种Pk的现像：谈到网格就会扯到Flexbox。假设浏览器都支持这两个模块，你将选择grid还是flexbox来给页面布局。其实当你了解两者之后你会很轻松的做出选择。 flexbox是一维布局，他只能在一条直线上放置你的内容区块；而grid是一个二维布局。前面也简单说到，你可以根据你的设计需求，将内容区块放置到任何你想要放的地方。那么不用多说，你应该知道哪一种更适合你的布局。 2.2.3.3 PROP(一) 网格线(Grid Lines)网格线组成了网格，他是网格的水平和垂直的分界线。一个网格线存在行或列的两侧。我们可以引用它的数目或者定义的网格线名称。 (二) 网格轨道(Grid Track)网格轨道是就是相邻两条网格线之间的空间，就好比表格中行或列。所在在网格中其分为grid column和grid row。每个网格轨道可以设置一个大小，用来控制宽度或高度。 (三) 网格单元格(Grid Cell)网格单元格是指四条网格线之间的空间。所以它是最小的单位，就像表格中的单元格。 (四) 网格区域(Grid Area)网格区域是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格。相当于表格中的合并单元格之后的区域。 (五) 网格容器(Grid Containers)通过使用display属性给元素显式设置了属性值grid或inline-grid，此时这个元素将自动变成网格容器。这个类似于flexbox一样，将元素设置设置为display:flex，元素将自动变成弹性盒模型。 (六) 网格容器(Grid Containers)通过使用display属性给元素显式设置了属性值grid或inline-grid，此时这个元素将自动变成网格容器。这个类似于flexbox一样，将元素设置设置为display:flex，元素将自动变成弹性盒模型。123div&#123; display:grid;&#125; 由于网格容器不是块容器，所以有部分属性在网格布局中将会失效：多列布局模块中的所有column-*属性运用在网格容器上将失效float和clear使用在网格项目（网格单元格Grid Cell）上将失效vertical-align使用在网格单元格上将失效::first-line和::first-letter这样的伪元素不能应用在网格容器上。 (七) 网格单元格顺序(order)网格单元格顺序和Flexbox模块一样，通过order属性来对网格单父元格进行顺序重排。123456789p:nth-child(1) &#123; order: 2;&#125;p:nth-child(2) &#123; order: 3;&#125;p:nth-child(3) &#123; order: 1;&#125; 推荐相关优秀网站 2.2.4 css变量参考之前写的样式之css变量 3 CSS 规范3.1 BEM3.1.1 WHAT3.1.1.1 B（Block） 块（Block）一个块是一个独立的实体，就像应用的一块“积木”。一个块既可以是简单的也可以是复合的（包含其他块）。 3.1.1.2 E（Element）3.1.1.3 M（Modifier）著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。 3.1.1 WHY3.1.1 HOW3.2 SMACSS3.2.1 WHAT3.2.1 WHY3.2.1 HOW3.33.3.1 WHAT3.3.1 WHY3.3.1 HOW3.4 OOCSS3.4.1 WHAT3.4.1 WHY3.4.1 HOW3.5 ACSS3.5.1 WHAT3.5.1 WHY3.5.1 HOW4 CSS 预处理器4.1 LESS4.2 SCSS4.3 PostCSS5 现代 CSS5.1 字体图标5.2 resetcss5.3 fcss5.4 boostrap5.5 MDUI5.6 MUI5.7 ZUI6 JS6.1 Js文件的引入众所周知，js程序应该尽量放在.js程序中，需要调用的时候在页面中以的形式包含进来。JavaScript代码若不是该页面专用的，则应尽量避免在页面中直接编写javascript代码。 6.2 js中命名规范6.2.1 camel命名法(骆驼式命令法，也叫小驼峰命名lowercamel)，除了第一个单词之外，函数名中的每一个逻辑断点都有一个大写字母来标记，形如thisIsAnApple。近年来越来越流行了，在许多新的函数库和Microsoft Windows这样的环境中，它使用得当相多另一方面。 6.2.2 pascal命名法（帕斯卡）,与骆驼命名法类似只不过骆驼命名法是首字母小写，而帕斯卡命名法是首字母大写，形如ThisIsAnApple 6.2.3 下划线命名法形如this_is_an_apple，下划线法是c出现后开始流行起来的。 6.2.4 中划线命名法形如this-is-an-apple 6.2.5 匈牙利命名法(Hungarian)：广泛应用于象Microsoft Windows这样的环境中Windows 编程中用到的变量（还包括宏）的命名规则匈牙利命名法，这种命名技术是由一位能干的 Microsoft 程序员查尔斯- 西蒙尼(Charles Simonyi) 提出的 匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等这些符号可以多个同时使用，顺序是先m_（成员变量）， 再指针，再简单数据类型，再其它 例如：m_lpszStr 表示指向一个以0字符结尾的字符串的长指针成员变量 匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途123456789101112131415属性+类型+描述属性一般是小写字母+_:g_:全局变量m_:类成员变量s_:静态变量c_:常量类型就多了：b:boolsz:以零结束的字符串p:指针n:整整dw:双字l:长整型无符号:u函数:fn 6.2.6 变量名必须使用camel命名法 6.2.7 参数名必须使用camel命名法 6.2.8 函数名必须使用camel命名法 6.2.9 方法/属性必须使用camel命名法 6.2.10 私有（保护）成员必须以下划线_开头 6.2.11 常量名必须使用全部大写的下划线命名法，如IS_DEBUG_ENABLED 6.2.12 类名必须使用pascal命名法 6.2.13 枚举名必须使用pascal命名法 6.2.14 枚举的属性必须使用全部大写的下划线命名法 6.2.15 命名空间必须使用camel命名法 6.2.16 语义命名同时还需要关注语义， 6.2.16.1 变量名应当使用名词 6.2.16.2 boolean类型应当使用is、has等起头，表示其类型；· 6.2.16.3 函数名应当用动宾短语 6.2.16.4 类名应当用名词。6.3 js中注释规范简单，清晰明了，见明知义。对不太明了的部分进行注解，一般变量的注释写在分号的末尾，不占行。123var xSpeed=0;//x轴的移动速度var ySpeed=0;//y轴的移动速度…… 6.4 js中变量、函数和类的声明等6.4.1 变量的声明尽管 JavaScript 语言并不要求在变量使用前先对变量进行声明。这样可以比较容易的检测出那些未经声明的变量，避免其变为隐藏的全局变量，造成隐患。 在函数的开始应先用 var 关键字声明函数中要使用的局部变量，注释变量的功能及代表的含义，且应以字母顺序排序。 每个变量单独占一行，以便添加注释。这是因为 JavaScript 中只有函数的 {} 表明作用域，用 var 关键字声明的局部变量只在函数内有效，而未经 var 声明的变量则被视为全局变量。示例：1234567891011var valueA = \"a\";var valueB = \"b\";function showMessage() &#123; var valueA = \"c\"; alert(\"valueA=\" + valueA);//valueA=c valueB =\"d\"; alert(\"valueB=\" + valueB);//valueB=d&#125;showMessage();alert(\"valueA=\" + valueA);//valueA=aalert(\"valueB=\" + valueB);//valueB=d 用 var 声明过的变量 valueA 和没有声明的变量 valueB 是有区别的。特别需要注意的是，在函数内部用 var 声明的变量为局部变量，这样可以有效地避免因局部变量和全局变量同名而产生的错误。 6.4.2 函数的声明函数也应在调用前进行声明，内部函数应在 var 声明内部变量的语句之后声明，可以清晰地表明内部变量和内部函数的作用域。 此外，函数名紧接左括号’(‘之间，而右括号’)’和后面的’{‘之间要有个空格，以清楚地显示函数名以其参数部分，和函数体的开始。 若函数为匿名 / 无名函数，则 function 关键字和左括号’(‘之间要留空格，否则可能误认为该函数的函数名为 function。内部函数声明示例：123456789101112131415var valueA =\"a\";var valueB =\"b\";function outF() &#123; var valueA =\"c\"; alert(\"valueA=\" + valueA);//valueA=c valueB = \"d\"; alert(\"valueB=\" + valueB + inF(valueB));//valueB=dd1 function inF(value) &#123; var innerB = value+1; return innerB; &#125;&#125;outF();alert(\"valueA=\" + valueA);//valueA=aalert(\"valueB=\" + valueB);//valueB=d 从上例的输出可以看出，inF()函数仅在outF() 函数的内部生效，局部变量 innerB对内部函数的作用域生效。这样的编码方式使得变量和函数的作用域变得清晰 6.5 js中对齐缩进和换行6.5.1 缩进在同一系统中应采用同一种缩进标准，本文提倡缩进大小为4个空格。各编译器对Tab键所代替的空白大小定义不同。建议在设置开发环境时，将编辑器里的Tab快捷键重新设置成4个空格。多数编译器提供了此功能。否则建议按4次空格来进行缩进。 6.5.2 换行在以下位置必须换行：每个独立语句结束后；if、else、catch、finally、while等关键字前；运算符处换行时，运算符必须在新行的行首。对于因为单行长度超过限制时产生的换行，参考行长度中的策略进行分隔。 6.5.3 字符串过长截断每行代码应小于80个字符。若代码较长应尽量换行，换行应选择在操作符和标点符号之后，最好是在分号“;”或逗号“,”之后。下一行代码相对上一行缩进4个空格。这样可以有效防止复制粘贴引起的代码缺失等错误并增强可读性。 按一定长度截断字符串，并使用+运算符进行连接。分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。特别的，对于HTML片段的拼接，通过缩进，保持和HTML相同的结构： 12345 var html=’’//空字符串，以便这个html片段 +‘&lt;article&gt;’ +’&lt;h1&gt;标题一&lt;/h1&gt;’ +‘&lt;p&gt;段落&lt;/p&gt;’+‘&lt;/article&gt;’ 也可使用数组来进行拼接，相对+运算容易调整和缩进123456 var html=[ ‘&lt;article&gt;’, ’&lt;h1&gt;标题一&lt;/h1&gt;’, ‘&lt;p&gt;段落&lt;/p&gt;’,‘&lt;/article&gt;’;]; 6.5.4 三元运算符过长三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成3种不同的情况：12345678//无需换行var resultTempA = condition ? resultA : resultB;//条件超长的情况var resultTempB = thisIsAVeryVeryLongCondition ? resultA : resultB;//结果超出分支的情况var resultTempC = condition ? thisIsAVeryVeryLongResult : resultB; 6.5.5 过长的逻辑条件组合当因为较复杂的逻辑条件组合导致80个字符无法满足需求时，应当将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。最终将右括号)与左大括号{放在独立一行，保证与if内语句块能容易视觉辨识。如：12345678//注意逻辑运算符前的缩进if(user.isAuthenticaterd() &amp;&amp; user.isInRole('admin') &amp;&amp; user.hasAuthority('add-admin') || user.hasAuthority('delete-admin'))&#123; //dosomething&#125; 6.5.6 过长的JSON和数组如果对象属性较多导致每个属性一行占用空间过大，可以按语义或逻辑进行分组的组织，如：1234var mapping =&#123; a:1,b:2,c:3,d:4,e:5,f:6,g:7,h:8,i:9,j:10, k:11,l:12,m:13,n:14,o:15,p:16,q:17,r:18,s:19&#125; 通过10个一组的分组，将每一行控制在合理的范围内，并且按逻辑进行了切分。 6.5.7 return语句return如果用表达式的执行作为返回值，请把表达式和 return 放在同一行中，以免换行符被误解析为语句的结束而引起返回错误。return关键字后若没有返回表达式，则返回 undefined。构造器的默认返回值为 this。 7 现代 JS7.1 ES67.2 babel7.3 Typescript7.4 AMD7.4.1 WHY当我们称一个应用程序是模块化的的时候，我们通常是指它由一组高度解耦的、存放在不同模块中的独特功能构成。你可能已经知道，松散耦合通过尽可能地去除依赖性来让可维护性更加简单易得。当这一点被有效实现的时候，系统中某一部分的变化将如何影响其它部分就会变得显而易见。 然而，与一些更传统的编程语言不同的是，JavaScript 的当前版本（ECMA-262) ）并没有为开发者们提供以一种简洁、有条理地的方式来引入模块的方法。规范的一大问题，就是未曾在这方面投入足够多的考量。直到近年来，人们对更为有序组织的 JavaScript 应用的需求变得越来越显著，这一情况才有所改观。 作为代替，当前的开发者们只能被迫降级使用模块模式或是对象字面量模式的各种变体。通过很多这样的方法，各模块的脚本被串在一起注入到 DOM 中（译注：感谢 @lkaihua 的确认，指的是作为 script 标签注入到 DOM 中），其命名空间是由单一的全局对象来描述的。 你的整个体系架构在这种模式下，仍然有可能发生命名冲突。想要简洁地管理依赖关系，不通过一些手工处理或借助第三方库往往是不可能的。 尽管这些问题的原生解决方案在 ES Harmony 中才会被引入，但好消息是，编写模块化的 JavaScript 目前已经变得极为简单，甚至今天就可以开始动手。 7.4.2 HOW要讨论 AMD 和 CommonJS 模块，我们必然会谈及一个显而易见的话题——脚本加载器。目前，脚本加载是为了让我们能在现今的各种应用中都能使用模块化的 JavaScript 这个目标而服务的。 为此，使用一个兼容的脚本加载器不得不成为必须。为使大家能更好地读懂本文，我推荐大家先大致了解一下主流的脚本加载工具的工作原理，这样在这儿对模块格式所作的讨论也就更有意义了。 用来处理基于 AMD 和 CJS 格式进行模块加载的加载器为数众多，但我个人最偏爱的还是 RequireJS 和 curl.js。这些工具完整的入门教程已经在本文的讨论范围之外，但我还是推荐大家读一读 John Hann 关于 curl.js 的文章以及 James Burke 的 RequireJS 的 API 文档来了解更多相关内容。 从生产的角度，在处理这样的模块时，使用优化工具（例如 RequireJS Optimizer，即 RequireJS 优化器）来拼合脚本来进行部署是值得推荐的。有趣的是，只要有了 Almond AMD shim，RequireJS,甚至无须加入到部署完的站点之中，你当做脚本加载器的那个东西可以被轻松地从开发过程中移除出去。 尽管如此，James Burke 还是很可能会说，在页面加载完毕以后还能动态加载脚本的使用场景依然存在，并且 RequireJS 在这些场景下也有用武之地。 7.4.3 WHATAMD（异步模块定义，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化 JavaScript 的解决方案。它诞生于 Dojo 在使用 XHR+eval 时的实践经验，其支持者希望未来的解决方案都可以免受由于过去方案的缺陷所带来的麻烦。 AMD 模块格式本身是一个关于如何定义模块的提案，在这种定义下模块和依赖项都能够异步地进行加载。它有很多独特的优势，包括天生的异步及高度灵活等特性，这些特性能够解除常见的代码与模块标识间的那种紧密耦合。它被许多开发者所青睐，可以认为它是迈向 ES Harmony 中提出的模块系统的一块可靠基石。 AMD 最初是一份 CommonJS 列表中模块格式的规范草案，但因为没能达成完整的共识，格式的后续开发就被移到了 amdjs 讨论组中。 目前它已经被包括 Dojo (1.7)、MooTools (2.0)、Firebug (1.8) 甚至 jQuery (1.7) 这样的项目所接纳。尽管我们时不时还是会遇到 CommonJS AMD 格式 这个说法，但由于不是所有 CJS 列表上的参与者都愿意支持它，我们最好还是称它为 AMD 或是异步模块支持。 7.5 commonJs7.5.1 WHATCommonJS 为服务器端优化的模块格式CommonJS是一个志愿性质的工作组，它致力于设计、规划并标准化 JavaScript API。至今为止他们已经尝试着认可了模块标准以及程序包标准。CommonJS 的模块提案为在服务器端声明模块指定了一个简单的 API。不像 AMD，它试图覆盖更宽泛的方面比如 IO、文件系统、promise 模式等等。 7.5.2 HOW从结构的角度来看，一个 CJS 模块是一段可重用的 JavaScript，它导出一系列特定的对象给依赖它的代码调用——通常来说这样的模块外围没有函数包裹（所以你在这里的例子中不会看到 define）。 从高一点的层次来看，他们主要包含两个部分：一个名叫 exports 的自由变量，它包含模块希望提供给其它模块的对象；以及一个 require 函数，让模块用来导入其它模块的导出。 理解 CJS：require() 与 exports12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// package/lib 是我们须要的一个依赖项var lib = require('package/lib');// 我们的模块的一些行为function foo()&#123; lib.log('hello world!');&#125;// 把 foo 导出（暴露）给其它模块exports.foo = foo;exports 的基本用法// 定义我们希望暴露的更多行为function foobar()&#123; this.foo = function()&#123; console.log('Hello foo'); &#125; this.bar = function()&#123; console.log('Hello bar'); &#125;&#125;// 把 foobar 暴露给其它模块exports.foobar = foobar;// 一个使用了 'foobar' 的应用// 相对于使用文件与模块文件所在的同一目录路径获取模块var foobar = require('./foobar').foobar, test = new foobar();test.bar(); // 'Hello bar'//第一个 CJS 例子的 AMD 等价写法define(['package/lib'], function(lib)&#123; // 我们的模块的一些行为 function foo()&#123; lib.log('hello world!'); &#125; // 把 foo 导出（暴露）给其它模块 return &#123; foobar: foo &#125;;&#125;); 使用多个依赖项 app.js1234567891011121314151617var modA = require('./foo');var modB = require('./bar');exports.app = function()&#123; console.log('Im an application!');&#125;exports.foo = function()&#123; return modA.helloWorld();&#125;bar.jsexports.name = 'bar';foo.jsrequire('./bar');exports.helloWorld = function()&#123; return 'Hello World!!'&#125; 哪些加载器和框架支持 CJS? 浏览器端： curl.js http://github.com/unscriptable/curl SproutCore 1.1 http://sproutcore.com PINF http://github.com/pinf/loader-js （还有更多） 服务器端： Node http://The Only Real Dev Language.org Narwhal https://github.com/tlrobinson/narwhal Persevere http://www.persvr.org/ Wakanda http://www.wakandasoft.com/ CJS 适用于浏览器吗？ 有些开发者觉得 CommonJS 更适合于服务器端开发，这一定程度上说明了为什么在目前这个 Harmony 到来前的时代，对于哪个格式更适合用来作为事实标准存在某种程度的分歧。 不利于 CJS 的论据包括：很多处理面向服务器端特性的 CommonJS API 根本无法用 JavaScript 在浏览器级别实现——比如 io、system 以及 js 就因为其天生的功能特性无法实现。 尽管这样，了解如何架构 CJS 模块还是很有用的，这样当我们在定义在所有地方都可能会用到的模块时，我们就能更好地体会它们是否合适了。在客户端与服务器端都有所应用的模块包括验证、转换和模板引擎。一些开发者选择使用哪个格式的方法是，当一个模块可以在服务器端环境中使用时选择 CJS，否则就选择 AMD。 因为 AMD 模块可以使用插件，也可以定义更细粒度的东西比如构造器与函数，这时用AMD 就有意义了。CJS 模块只能定义对象。当你试图从中获取构造器时，处理这种模块就会变得冗长乏味了。 虽然在超出了本文的范围，但是你可能已经注意到在讨论 AMD 和 CMJ 的过程中我们提到了不同类型的require 方法。 相似命名约定让人担忧的一点，当然是它会导致混乱。而且社区目前在用一个全局 require 函数带来的优缺点上尚有分歧。John Hann 对此的建议是，与其称它为 require，从而很可能无法成功让用户了解全局与内层 require 间的区别，把全局加载器方法重命名为别的东西反而会更有意义（例如这个类库的名字）。也就是这个原因使类似 curl.js 这样的加载器用 curl() 而非 require。 参考网站 Demystifying CommonJS Modules JavaScript Growing Up The RequireJS Notes On CommonJS Taking Baby Steps With Node.js And CommonJS - Creating Custom Modules Asynchronous CommonJS Modules for the Browser The CommonJS Mailing List 7.6 ECMAScriptTC39——负责制定 ECMAScript 语法和语义以及其未来迭代的标准团体，是由一部分非常聪明的开发者组成的。其中的一些人（比如 Alex Russell）在近几年一直在密切关注 JavaScript 在大规模开发中的使用情况的演进，而且也敏感地意识到了需要有更好的语言特性来编写更加模块化的 JS。 基于这个原因，目前有提案已经提出了一系列令人振奋的对语言的补充，包括灵活的、可以同时在客户端与服务器端使用的 模块、一个模块加载器以及其它。在这个章节中，我将向你展示一些 ES.next 中语法的代码样例，让你能对即将到来的东西一睹为快。（译注：关于 ES.next 与 ES Harmony 的关系，可以参考这篇文章。） 注：尽管 Harmony 仍然在提案阶段中，多亏了 Google 的 Traceur 编译器，你已经可以（部分地）尝试 ES.next 引入的对编写模块化 JavaScript 进行原生支持的特性。想要立刻获取并运行 Traceur，请阅读这篇入门指南。如果你有兴趣对这个项目了解更多的话，还有一个 JSConf 上相关的演讲也值得一看。 包含导入与导出的模块 如果你已经读完了关于 AMD 与CJS 模块的章节，你可能已经对模块依赖（导入）以及模块导出（或者说公用 API/我们允许其它模块使用的变量）的概念比较熟悉了。在 ES.next 中，这些概念被以一种更为精简的方式提出，用了一个关键字 import 来指定模块的依赖项。export 则和我们想象的没有多大差别，我认为很多开发者看了下面的代码就能立刻明白。 import声明 把某个模块的导出绑定为本地变量，并可以重命名来避免命名冲突。 export声明 声明了某个模块的本地绑定是外部可见的，这样其它模块就能够读取它们但却无法进行修改。有趣的是，模块可以导出子模块，却无法导出已经在别处定义过的模块。你同样可以给导出重命名来让它们不同于本地的名字。 12345678910111213141516171819202122232425262728293031module staff&#123; // 指定其它模块可以使用的（公用）导出 export var baker = &#123; bake: function( item )&#123; console.log('Woo! I just baked ' + item); &#125; &#125;&#125;module skills&#123; export var specialty = \"baking\"; export var experience = \"5 years\";&#125;module cakeFactory&#123; // 指定依赖项 import baker from staff; // 通过通配符导入所有东西 import * from skills; export var oven = &#123; makeCupcake: function( toppings )&#123; baker.bake('cupcake', toppings); &#125;, makeMuffin: function( mSize )&#123; baker.bake('muffin', size); &#125; &#125;&#125; 远程载入的模块 模块提案同样也适用于远程存放的模块（比如一个第三方 API 包裹器），使其简化了从外部位置载入模块的过程。这里是一段拉取我们上面定义的模块来使用的例子： 123module cakeFactory from 'http://addyosmani.com/factory/cakes.js';cakeFactory.oven.makeCupcake('sprinkles');cakeFactory.oven.makeMuffin('large'); 模块加载器 API 被提出的模块加载器为在高度受控的上下文中读取模块描述了一个动态的 API。加载器支持的方法签名有，用来加载模块的 load( url, moduleInstance, error)，以及 createModule( object, globalModuleReferences)等等。 下面是我们动态加载最开始定义的模块的例子。注意和上一个例子中我们从远程拉取一个模块不同，这里的模块加载器API 更适合用于动态上下文。 1234Loader.load('http://addyosmani.com/factory/cakes.js', function(cakeFactory)&#123; cakeFactory.oven.makeCupcake('chocolate'); &#125;); 针对服务器的类 CommonJS 模块对于面向服务器的开发者来说，在 ES.next 中提出的模块系统并非局限于对浏览器端模块的关注。通过下面的例子，你可以看见一个被提出用于服务器的类 CJS 模块：1234567891011121314151617// io/File.jsexport function open(path) &#123; ... &#125;;export function close(hnd) &#123; ... &#125;;// compiler/LexicalHandler.jsmodule file from 'io/File';import &#123; open, close &#125; from file;export function scan(in) &#123; try &#123; var h = open(in) ... &#125; finally &#123; close(h) &#125;&#125;module lexer from 'compiler/LexicalHandler';module stdlib from '@std';//... scan(cmdline[0]) ... 带有构造器、Getter 与 Setter 的类 类的记号向来都是和语言纯正癖们间有争议的问题。我们目前一直沿用的是要么退回到JavaScript 基于原型的天生特性，要么使用可让人使用类进行定义的、实质上在脱糖（译注：desugar，意为去掉语法糖，把代码转换为语法上更严密的形式，可参考李松峰老师的这篇文章）以后同样是原型行为的框架或抽象。 在Harmony中，类与构造器一同作为语言的一部分出现，（终于）有了一些真正的私有性。在下面的例子中，我引入了一些行内的注释来帮助你理解类是如何组织的，但是你可能会注意到这里缺少了“函数”这个词汇。这并非一个排印错误：TC39 一直以来都在有意识地努力减少我们对 function 关键字的到处滥用，希望这有助于帮助我们简化代码的编写。 1234567891011121314151617181920212223242526272829303132333435363738394041class Cake&#123; // 我们可以用 'constructor' 关键字后面紧跟一个公有及私有声明 // 的参数列表来定义一个类的构造器主体。 constructor( name, toppings, price, cakeSize )&#123; public name = name; public cakeSize = cakeSize; public toppings = toppings; private price = price; &#125; // 作为 ES.next 对于减少不必要的到处使用 function 的努力的一部 // 分，你会看到它在如同下面那样的使用场景中被抛弃了。在这里一个标 // 识符后面紧跟一个参数列表和一个定义了新方法的主体。 addTopping( topping )&#123; public(this).toppings.push(topping); &#125; // Getter 可以通过在标识符、方法名以及花括号主体前 // 声明一个 get 来定义。 get allToppings()&#123; return public(this).toppings; &#125; get qualifiesForDiscount()&#123; return private(this).price &gt; 5; &#125; // 与 getter 类似，setter 也能通过在标识符前使用 'set' // 关键字来定义。 set cakeSize( cSize )&#123; if( cSize &lt; 0 )&#123; throw new Error('Cake must be a valid size - either small, medium or large'); &#125; public(this).cakeSize = cSize; &#125;&#125; 参考网站 A First Look At The Upcoming JavaScript Modules David Herman On JavaScript/ES.Next (Video) ES Harmony Module Proposals ES Harmony Module Semantics/Structure Rationale ES Harmony Class Proposals ES Harmony 总结 如你所见，ES.next 带来了一些令人振奋的新东西。虽然 Traceur 可以在某种程度上用来在当前尝试一下这样的特性，但是要记住可能用 Harmony 来规划你的系统可能并不是个好主意（只是说目前还不是）。 规范发生变化以及潜在的在跨浏览器层面的问题都会带来风险（比如 IE9 可能会要过较长的时间才会消亡），所以在标准最终确定及其覆盖率不成问题之前，你最好还是把注下在 AMD（用于浏览器内运行的模块）与 CJS（用于服务器）身上。 8 JS 框架8.1 node8.2 Angular8.3 React8.4 Vue8.5 avalon8.6 knockout8.7 dojo8.8 backbone9 JS 方法9.1 函数式编程9.2 面向对象9.3 canvas10 JS 库10.1 Immutable10.2 Ramda10.3 Lodash11 响应式设计原则指的是不同设备、屏幕、分辨率、操作方式（鼠标、键盘、触摸），保证信息在不同环境下表现一致，保证可交互可操作。做响应式设计时需要遵循一个原则。 由于页面的宽度发生了变化，进而信息展现也改变了就是响应式设计。直到最后在手机屏幕上的显示图片信息变成了一列。 临界点 当页面宽度发生变化的尺寸范围就是临界点的概念。所以做响应式设计时我们需要知道每一个尺寸的宽度范围在多少时我们就可以制定出相对应清晰的一个临界点，制定了临界点之后就知道，当屏幕的宽度范围位于哪一个点的时候，我们的页面信息该如何展示。 栅格：将页面分成几栏、几块。 例如bootstrap是以12栅格为基础设计的。它的设计原则就是将页面分成12个等分的栏，然后把页面的内容设计在12栏内。比如左边的一些商品展示它用到了一个栅格的单位；其中的一个最大面积的商品展示它用到了比较多的栅格；最右侧的操作信息用到了四个栅格的比例。 使用Native App的UI控件 在设计H5页面的同时，能够尽量让样式与Native保持一致；文字字号颜色均可与APP设计一致；减少不必要的手势操作；避免与浏览器的交互冲突，如左右滑动。 12 测试12.1 黑盒测试12.2 自动化测试12.3 单元测试12.4 TDD13 测试框架13.1 Jasmine13.2 Karma14 SVG15 WebGL16 动画技术17 可访问性18 可用性19 性能20 构建工具20.1 Grunt20.2 Gulp20.3 NPM21 资源打包工具21.1 WebPack21.2 Browserify21.322 NPM 生态系统23 了解不同浏览器的怪癖24 协同工作24.1 Git24.2 SVN24.3 敏捷开发24.4 良好的开发文档24.5 markdown24.6 思维导图25 视觉设计基础26 软技能，时间管理27 对使用的后端语言有基本的了解27.1 PHP27.2 JAVA27.3 C27.4 C27.5 python python *.py console.log(“hello world”); 28 参考网页 前端必备技术栈的文章 web端设计规范 2017年JavaScript编码规范技能图谱-全栈工程师熊盼 常用命名法 html5语义化 css模块化 CSS3弹性伸缩布局——box布局 CSS3弹性伸缩布局——flex布局 CSS Grid布局 使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript 如何更好的使用BEM BEM的定义","tags":[{"name":"前端思考","slug":"前端思考","permalink":"https://mowatermelon.github.io/tags/前端思考/"},{"name":"必备技术栈","slug":"必备技术栈","permalink":"https://mowatermelon.github.io/tags/必备技术栈/"}]},{"title":"框架学习之Html2canvas学习","date":"2017-04-05T16:00:00.000Z","path":"2017/04/06/framework-learning-html2canvas/","text":"最近微信项目中，希望能够把流程的最后一步以图片形式保存下来，我之前想触发手机的截屏键，然后在流程的最后一步点击保存按钮，直接可以把最后一步的界面截图保存下来 1 什么是html2canvas1.1 作用可以通过纯JS对浏览器端进行截屏，但截图的精确度还有待提高，部分css不可识别，所以在canvas中不能完美呈现原画面样式 1.2 支持的浏览器 12345Firefox 3.5+Google ChromeOpera 12+IE9+Safari 6+ 1.3 基本语法 123456 //两个参数：所需要截图的元素id，截图后要执行的函数， canvas为截图后返回的最后一个canvas html2canvas(document.getElementById('id')) .then(function(canvas) &#123; document.body.appendChild(canvas); &#125;); 1.4 可用参数 参数名称 类型 默认值 描述 allowTaint boolean false Whether to allow cross-origin images to taint the canvas—允许跨域 background string #fff Canvas background color, if none is specified in DOM. Set undefined for transparent—canvas的背景颜色，如果没有设定默认透明 height number null Define the heigt of the canvas in pixels. If null, renders with full height of the window.—canvas高度设定 letterRendering boolean false Whether to render each letter seperately. Necessary if letter-spacing is used.—在设置了字间距的时候有用 logging boolean false Whether to log events in the console.—在console.log()中输出信息 proxy string undefined Url to the proxy which is to be used for loading cross-origin images. If left empty, cross-origin images won’t be loaded.—代理地址 taintTest boolean true Whether to test each image if it taints the canvas before drawing them—是否在渲染前测试图片 timeout number 0 Timeout for loading images, in milliseconds. Setting it to 0 will result in no timeout.—图片加载延迟，默认延迟为0，单位毫秒 width number null Define the width of the canvas in pixels. If null, renders with full width of the window.—canvas宽度 useCORS boolean false Whether to attempt to load cross-origin images as CORS served, before reverting back to proxy–这个我也不知道是干嘛的 2 html2canvas结合图片保存2.1 PC端网页截图保存 12345678910111213141516171819202122232425262728293031323334353637383940var g_width=$(\"#restable\").width()&gt;bindHeight().width?bindHeight().width:$(\"#restable\").width();//代码在多个浏览器中测试，图片只有在火狐和ie中才显示出来，ie触发下载事件机制不同，只有火狐中保存的图片包含网页中的图片其他浏览器都没有显示图片，文字都是正常被重绘了html2canvas(document.getElementById('restable'), &#123; width:g_width, height:bindHeight().height*0.6, background: \"#fff\",//一定要设置啊，要不然背景色默认是透明色 onrendered: function(canvas) &#123; //document.getElementById('restable').appendChild(canvas); $(\"#showM\").showmodal(&#123; flag: \"info\", //设置弹出modal的状态 success:成功窗体,warning:警告窗体,info:信息窗体,default:默认无样式 title: \"截屏\", //设置模态窗标题 content: \"\", //设置模态窗内容 SWidth: g_width, AutoBtn:\"截屏保存\" &#125;); $(\"#showModal\").on(\"shown.bs.modal\",function()&#123; $(\"#showModal .modal-dialog\").css(&#123;\"margin-top\":\"40px\"&#125;); $(\".modal-body\").attr(\"id\",\"m_body\").css(&#123;\"padding\":\"0px\",\"overflow\":\"auto\"&#125;); //在模态框加载的同时做一些动作 document.getElementById('m_body').appendChild(canvas); $(\".modal-body\").children(\"canvas\").css(&#123;\"margin\":\"0px auto\"&#125;); &#125;); $(\"#close\").click(function()&#123; dataURL =canvas.toDataURL(\"image/png\"); var imgName=\"PC页面截图_EVA\"; //下载图片 //以下代码为下载此图片功能 var triggerDownload = $(\"&lt;a&gt;\").attr(\"href\", dataURL).attr(\"download\", imgName + \".png\").appendTo(\"body\"); triggerDownload[0].click(); &#125;) &#125;&#125;); 2.2 移动端网页截图保存 123456789101112131415//移动端不支持直接保存base64图片，所以页面加载之后，直接将页面重绘成图片，移动端可以直接长按进行保存html2canvas(document.getElementById('main'), &#123; background: \"#fff\", onrendered: function (canvas) &#123; var imgName=\"移动端页面重绘_EVA\"; var image = canvas.toDataURL(\"image/png\").replace(\"image/png\", \"image/octet-stream\"); $(\".res_table\").html(\"&lt;img src='\" + image + \"' alt='from canvas' name='\" + imgName + \"'/&gt;\"); $(\"#showM\").showmodal(&#123; content: \"请长按图片进行保存结果告知单\", SWidth: \"200\", fontSize:\"14px\" &#125;); &#125;&#125;); 3 踩坑心得之前demo中传的直接是body，我以为是直接传id或者class类，结果并不是，我还以为只能重绘body，后来才发现需要传入的是选择器选中之后的对象，可以自定义绘制的内容。","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"html2canvas","slug":"html2canvas","permalink":"https://mowatermelon.github.io/tags/html2canvas/"}]},{"title":"框架学习之Vue-Cli学习","date":"2017-04-05T16:00:00.000Z","path":"2017/04/06/framework-learning-vue-cli/","text":"上周末学习了vue-elm，看相关的组件新建和使用，看了如何修改相关webpack，修改相关linter规则，感觉需要用项目来实战一些，之前看相关教学视频的时候，写了一个总结，今天按照总结一直不成功遇见了很多坑，所以在这里重新再总结一下。 1 设置环境变量 1 win+e打开文件夹 2 计算机/属性/高级系统设置/高级/环境变量 3 在系统用户和当前用户下修改path变量，增加node的安装路径\\nodejs\\node_global 2 先全局安装vue-cli 1npm install -g vue-cli 3 选择想要使用的目录 注意使用cd进入相关文件夹,注意是进入你想要新建项目的父级 12345//先进入demo所在盘Your environment has been set up for using Node.js 6.9.4 (x64) and npm.D:\\Users\\Administrator&gt;F:F:&gt; cd F:\\documentbak\\7_10\\bak 4 错误示范 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748npm init webpack demoThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt; --save` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.name: (bak) vuedemoversion: (1.0.0) 1.0.0description: this a demo for webpack with vue familyentry point: (index.js) index.jstest command: npm run indexgit repository: nothingkeywords: vue cli rounter resourcesauthor: mowatermelonlicense: (ISC) MITAbout to write to F:\\documentbak\\7_10\\bak\\package.json:&#123; \"name\": \"vuedemo\", \"version\": \"1.0.0\", \"description\": \" this a demo for webpack with vue family\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"npm run index\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"nothing\" &#125;, \"keywords\": [ \"vue\", \"cli\", \"rounter\", \"resources\" ], \"author\": \"mowatermelon\", \"license\": \"MIT\"&#125;Is this ok? (yes) YESF:\\documentbak\\7_10\\bak&gt; 5 配置项目相关数据 大部分都默认，记得最后我们是webapp所以最后两项可以选择写no123456789101112131415161718192021222324252627282930313233vue init webpack demoYour environment has been set up for using Node.js 6.9.4 (x64) and npm.D:\\Users\\Administrator&gt;f:F:\\&gt;cd F:\\documentbak\\7_15\\bakF:\\documentbak\\7_15\\bak&gt;vue init webpack demo'git' �����ڲ����ⲿ���Ҳ���ǿ����еĳ����������ļ�? Project name demo? Project description a vue demo? Author wu eva? Vue build standalone? Install vue-router? Yes? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes vue-cli · Generated \"demo\". To get started: cd demo npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpackF:\\documentbak\\7_15\\bak&gt;^A 6 打包项目 12cd demo #进入相关文件夹npm install #安装项目 7 监听端口 运行相关环境，查看页面效果 1npm run dev 8 开启命令如何关闭 开启了npm run dev命令以后，如何关闭或者退出。 1234#按下ctrl+c#会显示终止批处理操作吗(Y/N)? y 9 开启服务如何停止 开启node服务之后，如何停止 1234567#osx下pkill node#或者killall nodesudo lsof -i:80 //列出80端口下的进程sudo kill -9 xxxx // xxxx指的是进程的PID","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://mowatermelon.github.io/tags/vue-cli/"}]},{"title":"框架学习之Bootstrapinput不换行","date":"2017-04-04T16:00:00.000Z","path":"2017/04/05/framework-learning-bootstrap-inputNoBr/","text":"如果需要在表单中将一行纯文本和 label 元素放置于同一行，为 &lt;p&gt; 元素添加 .form-control-static类即可。 当您需要在一个水平表单内的表单标签后放置纯文本时，请在&lt;p&gt;上使用 class.form-control-static 如下面的实例所示： 12345678910111213141516171819202122232425262728&lt;form class=\"form-horizontal\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-sm-2 control-label\"&gt;Email&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;p class=\"form-control-static\"&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputPassword\" class=\"col-sm-2 control-label\"&gt;Password&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"password\" class=\"form-control\" id=\"inputPassword\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;form class=\"form-inline\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"sr-only\"&gt;Email&lt;/label&gt; &lt;p class=\"form-control-static\"&gt;email@example.com&lt;/p&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputPassword2\" class=\"sr-only\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"inputPassword2\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Confirm identity&lt;/button&gt;&lt;/form&gt;","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"bootstrap-input","slug":"bootstrap-input","permalink":"https://mowatermelon.github.io/tags/bootstrap-input/"}]},{"title":"框架学习之Bootstrap链接导航affix","date":"2017-04-03T16:00:00.000Z","path":"2017/04/04/framework-learning-bootstrap-affix/","text":"前期概要，项目中需要使用到点击左侧目录树，右侧文档跳转到对应的锚点地点，所以使用了bootstrap的affix，结果点开了一堆bug，主要是太粗心，所以写一篇文章记录一些基础使用情况 1 默认情况 自定义样式 123456789/* Custom Styles */ul.nav-pills.affix&#123; top: 30px; /* 在页面滚动的时候会给添加了affix-top的样式修改为affix,修改左侧目录树距离顶端的距离，这个和js中写偏移一样的效果 */&#125;p.h4&#123; line-height:2; /*text-indent:2em;*/&#125; 默认的html,注意要引用jquery.js和bootstrap.js 12345678910111213141516171819&lt;body data-spy=\"scroll\" data-target=\"#myScrollspy\"&gt;&lt;div class=\"container\"&gt; &lt;div class=\"col-xs-3\" id=\"myScrollspy\"&gt; &lt;ul class='nav nav-pills nav-stacked affix-top' id='scrollUL' data-spy=\"affix\" data-offset-top=\"125\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#section-1\"&gt;第一部分&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#section-2\"&gt;第二部分&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#section-3\"&gt;第三部分&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"col-xs-9\" id='scrollDiv'&gt; &lt;h2 id=\"section-1\"&gt;第一部分&lt;/h2&gt; &lt;p class='h4'&gt;partpartpartpartpartpartpartpartpartpart&lt;/p&gt; &lt;h2 id=\"section-2\"&gt;第一部分&lt;/h2&gt; &lt;p class='h4'&gt;partpartpartpartpartpartpartpartpartpart&lt;/p&gt; &lt;h2 id=\"section-3\"&gt;第一部分&lt;/h2&gt; &lt;p class='h4'&gt;partpartpartpartpartpartpartpartpartpart&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 2 触发bug左侧盒子的idmyScrollspy，左侧盒子ul的idscrollUL，右侧盒子的idscrollDiv bug 1 我觉得默认的左侧目录树样式有些丑，希望bootstrap提供其他选择 bug原因:提供的nav-tabs,需要修改的太多，这边发现了nav-pills，需要修改的地方很少，提供的样式也还好。其实这个也不算bug，懒惰如我。 bug 2 我发现我点击左侧目录树，右侧文本毫无反应，甚至还对我笑了笑，摊手.jpg bug原因:我没有放body控制，没有绑定左侧目录树ul中的相对定位地址，这边触发一直不成功，应该为&lt;body data-spy=&quot;scroll&quot; data-target=&quot;#myScrollspy&quot;&gt;。注意这个绑定的id是左侧目录盒子的id不是其他的。 bug 3 我发现页面滚动的时候，右侧的文本就漂浮到页面最左侧了，右侧页面滚动的时候对应的左侧的li也不对，更换了在线资源之后也是这样，当时我觉得左右两侧的盒子都在笑我。 bug原因:我在body中绑定的是左侧盒子的id，但是在js中我需要绑定的是左侧盒子中ul的id，我需要但是左侧盒子中的ul在页面滚动的时候，一般来说js的优先级高于css的执行情况，所以这边页面就只管js，导致页面效果出现问题，放上正确的js。 12345$('#scrollUL').affix(&#123; offset: &#123;2 top: 100/*修改左侧目录树距离顶端的距离，这个和css中写偏移一样的效果 */2 &#125;&#125;) 3 暂停总结使用affix，在当前界面进行锚点跳转还是比较好用的，横向列表进行锚点链接就是用默认的nav,如果想用纵向的锚点跳转，就添加nav-stacked,这在页面使用的时候其实是比较常用的功能，而且nav在移动端会自动折叠成一个目录图标，这个默认媒体查询比较友好，在使用bootstrap的时候，用过很多插件，这边总感觉bootstrap只有样式，其实是了解比较少，希望之后用到更多，还有我最近越来越发现很多时候先检查基础问题，再看代码问题，很多都是细节没有注意好，导致bug出现。","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"bootstrap-affix","slug":"bootstrap-affix","permalink":"https://mowatermelon.github.io/tags/bootstrap-affix/"}]},{"title":"框架学习之Bootstrap表格可编辑学习","date":"2017-04-02T16:00:00.000Z","path":"2017/04/03/framework-learning-bootstrap-table/","text":"因为页面整体风格需要，所以需要使用到bootstrap的table Editable插件 1 引入对应的js和css 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;meta name=\"author\" content=\"watermelon,why\" /&gt; &lt;meta name=\"Description\" content=\"MSHK\" /&gt; &lt;meta name=\"Keywords\" content=\"MSHK,公司,demo\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=\"css/bootstrap.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;link href=\"css/bootstrap-editable.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"js/jquery-2.1.1.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"js/bootstrap.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt; &lt;script src=\"js/bootstrap-editable.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 基础测试 带参数功能测试 12345&lt;a href=\"#\" id=\"username\" data-type=\"text\" data-title=\"用户名\"&gt;用户名&lt;/a&gt;&lt;script type=\"text/javascript\"&gt;$(function()&#123; $('#username').editable();&#125;) 不带参数功能测试 1234567891011121314 &lt;a href=\"#\" id=\"status\"&gt;&lt;/a&gt; $('#username').editable(&#123; type: \"text\", //编辑框的类型。支持text|textarea|select|date|checklist等 title: \"用户名\", //编辑框的标题 disabled: false, //是否禁用编辑 emptytext: \"空文本\", //空值的默认文本 mode: \"inline\", //编辑框的模式：支持popup和inline两种模式，默认是popup validate: function (value) &#123; //字段验证 if (!$.trim(value)) &#123; return '不能为空'; &#125; &#125; &#125;); &lt;/script&gt; 两者测试结果是都是可行的 注意需要按照实际项目图片安放地址，修改table Editable css中clear和loading地址 3 测试table编辑功能 引入对应的js和css 123456789&lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\" /&gt;&lt;link href=\"css/bootstrap-editable.css\" rel=\"stylesheet\" /&gt;&lt;link href=\"bootstrap-table.css\" rel=\"stylesheet\" /&gt;&lt;script src=\"js/jquery-2.1.1.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap-table.js\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap-table-zh-CN.js\"&gt;&lt;/script&gt;&lt;script src=\"js/bootstrap-editable.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 简单测试 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div class=\"container\"&gt; &lt;table class=\"table\"&gt; &lt;caption&gt;基本的表格布局&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表名&lt;/th&gt; &lt;th&gt;列名&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Username:&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\" id=\"username\" data-type=\"text\" data-placement=\"right\" data-title=\"Enter username\"&gt;superuser&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Status:&lt;/td&gt; &lt;td&gt;&lt;a href=\"#\" id=\"status\"&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; //toggle `popup` / `inline` mode $.fn.editable.defaults.mode = 'inline'; //make username editable 文本 $('#username').editable(); //make status editable 下拉框 $('#status').editable(&#123; type: 'select', title: 'Select status', placement: 'right', value: 2, source: [ &#123;value: 1, text: 'status 1'&#125;, &#123;value: 2, text: 'status 2'&#125;, &#123;value: 3, text: 'status 3'&#125; ] &#125;);&lt;/script&gt; 4 多数据测试效果 在编辑完成提交之后，如果提交之后的文本内容过多，表格的thead里面th的宽度和tbody里面td的宽度不对齐，下次再结合bootstrap table一起测试 1$(\"#table\").bootstrapTable(\"resetView\"); 5 后续改进 之前在使用了Editable之后，我这边项目提出新需求这边需要现在新增需求是，当修改的input失去焦点的时候，当前值依旧会触发保存事件，现有的是没有选中编辑框中的对钩，是不会触发保存事件的，之前同事以为是bootstrap的Editable，所以参考那个的api，查看相关属性Option其中有shown和hidden事件是我们需要监控的，但是一直断点没能成功进入，我当时看着也觉得不可思议，后来在自己的工位上看api的时候，才发现同事看的api有问题，应该是看x-editable的api，应该修改的是savenochange和onblur，两者都是String属性，默认的是false和submit， 5.1 默认情况12onblur (since 1.1.1) string 'cancel'savenochange (since 1.2.0 ) boolean false 5.2 修改之后12onblur：submitsavenochange:true","tags":[{"name":"框架学习","slug":"框架学习","permalink":"https://mowatermelon.github.io/tags/框架学习/"},{"name":"bootstrap-table","slug":"bootstrap-table","permalink":"https://mowatermelon.github.io/tags/bootstrap-table/"}]},{"title":"阶段总结之201704","date":"2017-04-01T16:00:00.000Z","path":"2017/04/02/stage-summary-201704/","text":"前情概要，从201604确定自己做前端到现在201704已经有一年时间了，对之前的学习和工作做个总结，也是对之后的学习和生活制定相关列表。 1 前期总结1.1 前台掌握技术栈 html4 70% 问题可以解决，除了table布局相关，还有就是不同浏览内核兼容 html5 50% 问题可以解决，对于新增的画布还有header，nav，等等新标签使用不多。 css 80% 问题可以解决，除了一些csshack相关，近期新知识媒体查询与js结合做界面响应式 css3 50% 问题可以解决，主要是使用雪碧图，还有文字和盒子的阴影圆角等特性，对于css动画这块使用比较少。 js 原生js纯手写的话，就记得几个getelement（s）byTagName byClass byId，基本阅读能力还在（仅限原生es5,es6和es7都不会），手写功底很差了，记得最熟的应该是console.log .info .error 等等，还有几个基础的构建数组，字符串，list数组，最近学习了json的序列化和反序列化。 jquery 目前主要使用到技术，基础选择器基本掌握，parent(),children(),eq(),hasClass(),attr(),width(),height(),css({}),removeAttr(),removeClass()基本方法使用,可以用来获取相关值，也可以用来设定相关值,正则表达式^=/|=某某以某某开头,$=某某以某某结束,~=/*=某某选择包含某某的元素，参考网址。还有就是append()和after(),toggleClass(&quot;true&quot;,&quot;false&quot;)等等用的不是很熟练的函数。 bootstrap 在纯bootstrap（不使用插件的情况下），我目前用的比较多的就是btn和panel，还有container和row(col-(xs768/sm992/md1024/lg1200)(-offset)-N)，还有modal和alert.还有使用到bootstrap的面包屑，formgroup，inputgroup，listgroup，(“#aaa”).modal({}),dismiss属性，还有就是bootstrap的字体图标，通过后台的IO文件流做目录树，在btn中添加可以有更好的提示作用，还有在横向list目录上也可以更好的提示相关操作行为，而且字体图标为svg矢量，不存在失真情况，而且通过font-size，font-weight和Color就可以直接控制对应的图标效果兼容性也很不错，还可以通过:hover和:selected等等伪类做相关动画效果，这个还不错。 LigerUI $.liger.(panel ,tip,grid,toolbar)等等，format，icon等等，如果是只需要使用ligerui的某部分功能可以直接引用对应的js和css，就可以直接使用了，如果需要使用全部功能，js方面就直接引用liger.min.js就可以了，liger在数据前后台交互上，封装了很多属性，但是，在响应式方面，有很多问题，所以在最初使用的时候就被抛弃了。 echartjs 目前是百度管理的在线图表管理插件，主要使用了圆饼图和k线图。这个是基于canvas技术的一个在线绘制插件，扩展性也比较好，图表显示的主题可比较多。 PS AI FLASH ULEADGIF 思维导图等等 1.2 后台掌握技术栈vue 学习了20%左右，官方文档的数据双向绑定学习完了，之后还有很多都没有学习，手脚架vue-cli和vuex等等都没有学习完成。 12345678910111213141516171819&lt;!--v-on的缩写是@；v-bind的缩写是:（冒号）；--&gt;var eg1 = new Vue(&#123; el: \"#eg2\", data: &#123; gameNames: ['魔兽世界', '暗黑破坏神Ⅲ', '星际争霸Ⅱ', '炉石传说', '风暴英雄', '守望先锋' ], activeName: '' //active:&#123;'styleObjectA':true&#125; &#125;, methods: &#123; selected: function(gameName) &#123; this.activeName = gameName; alert('Hello ' + this.activeName + '!'); //console.log('Hello ' + this.active.styleObjectA.backgroundColor + '!'); &#125; &#125;&#125;); node 学习了5%左右，学习了怎么启动项目，基础的就在node.js中直接用node 文件路径就好了，协议共存之类。还有很多需要学习的地方。 c# 公司主要使用的后台，基本函数构建，public void之类，使用struct构建 list 数组对象，协助json进行反序列化，先声明变量为public，前台调用&lt;%= %&gt;就可以了，不一定要把值直接传给某个标签，再从前台通过eval对json进行序列化，前台通过ajax发送请求过来，如果不标明网址，默认为当前界面的的后台处理。TSQL JAVA等等 1.3 其他掌握技术栈markdown重复学习了两三次，目前主要是使用 # 和 _(下划线) ,前者用于切换字体字号，后者用于修改字体样式是为粗体还是斜体，还有英文状态下的`和```,用于字体高亮和保留程序的原格式，还有[demo](http:\\)中括号中用于输入超链接的显示文字，小括号中用于设置超链接地址，还有注意在使用 # _ 1 &gt; 之后需要包含一个空格才能使用，还用就是使用反斜杠进行符号转义。 github page目前在github上有9个项目，其中主要的pagemowatermelon.github.io,还有使用github wiki和issue记录自己的技术栈或者学习日志。还可以通过本地的github客户端及时sync同步远程和本地仓库文件。 svn 版本管理软件，及时的与在线仓库文件进行版本对照和版本管理。 小插件 在一个拼音和汉字转化插件基础上，写了一个支持中英文虚拟键盘输入的插件，支持动态增加输入行，动态获取焦点；做了一个自动化流程插件，支持动态配置流程个数，流程走向颜色，还有流程上下步绑定；在bootstrap modal的基础上做了一个modal的插件，支持定义modal的宽度高度，title，如果modalbody需要为iframe，支持传进src等等参数，还在进一步开发中。 2 后期列表2.1 前台掌握技术栈less sass amazeui es6 es7 vue node angular ng 2.2 后台掌握技术栈php 2.3 其他掌握技术栈cenos ubuntu git","tags":[{"name":"阶段总结","slug":"阶段总结","permalink":"https://mowatermelon.github.io/tags/阶段总结/"}]},{"title":".NET学习之MVC指令学习","date":"2017-03-31T16:00:00.000Z","path":"2017/04/01/NET-learning-MVC/","text":"Usage: 1dotnet [host-options] [command] [arguments] [common-options] Arguments: parameter content [command] The command to execute [arguments] Arguments to pass to the command [host-options] Options specific to dotnet (host) [common-options] Options common to all commands Common options: parameter content -v or –verbose Enable verbose output -h or –help Show help Host options (passed before the command): parameter content -d or –diagnostics Enable diagnostic output –version Display .NET CLI Version Number –info Display .NET CLI Info Commands: parameter content new Initialize .NET projects. restore Restore dependencies specified in the .NET project. build Builds a .NET project. publish Publishes a .NET project for deployment (including the runtime). run Compiles and immediately executes a .NET project. test Runs unit tests using the test runner specified in the project. pack Creates a NuGet package. migrate Migrates a project.json based project to a msbuild based project. clean Clean build output(s). sln Modify solution (SLN) files. Project modification commands: parameter content add Add items to the project remove Remove items from the project list List items in the project Advanced Commands: parameter content nuget Provides additional NuGet commands. msbuild Runs Microsoft Build Engine (MSBuild). vstest Runs Microsoft Test Execution Command Line Tool.","tags":[{"name":".NET","slug":"NET","permalink":"https://mowatermelon.github.io/tags/NET/"},{"name":"MVC","slug":"MVC","permalink":"https://mowatermelon.github.io/tags/MVC/"}]}]